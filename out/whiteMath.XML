<?xml version="1.0"?>
<doc>
  <assembly>
    <name>whiteMath</name>
  </assembly>
  <members>
    <member name="T:whiteMath.WhiteMath`2">
      <summary>
            This class provides generic mathematic algorithms for different purposes.
            It makes heavy use of <see cref="T:whiteMath.Numeric`2" /> class
            so that many of the algorithms work for arbitrary numeric types which have a valid calculator 
            (i.e. an <see cref="T:whiteMath.ICalc`1" /> instance). For various algorithms various restrictions are
            applied, though, e.g. a GCD algorithm would require the <typeparamref name="T" /> type to be an integer type.
            </summary>
      <typeparam name="T">The type of numbers passed to mathematic functions.</typeparam>
      <typeparam name="C">A calculator type for the <typeparamref name="T" /> type.</typeparam>
    </member>
    <member name="M:whiteMath.WhiteMath`2.PI_Leibnitz(System.Int64)">
      <summary>
            --- For real number types only! ---
            --- Higher precision recommended ---
            
            Returns the rational approximation of transcend PI constant
            using the Leibnitz series. May be inaccurate, non-generic version is recommended if possible.
            </summary>
      <param name="members" />
      <returns />
    </member>
    <member name="M:whiteMath.WhiteMath`2.RootsOfUnity(`0,System.Collections.Generic.IEnumerable{`0},System.Nullable{whiteMath.BoundedInterval{`0,`1}})">
      <summary>
            For residue class rings modulo <c>N</c> where <c>N &gt;= 1</c>,
            this method finds all modular roots of unity in the specified search interval.
            </summary>
      <param name="searchInterval">
            The interval on which the search will be performed.
            The inclusive bounds of the interval specified should be both located within the interval <c>[0; N-1]</c>.
            The default value of this parameter is <c>null</c>, and in this case, the interval <c>[0; N-1]</c> will be
            substituted automatically.
            </param>
      <param name="module">The module of the residue class ring, expected to be &gt;= 2.</param>
      <param name="rootDegrees">
            An enumeration of root degrees for which the primitive roots should be found.
            </param>
      <returns />
      <requires description="This method supports only integral types." exception="T:whiteMath.NonIntegerTypeException" csharp="Calculator.isIntegerCalculator" vb="Calculator.isIntegerCalculator">whiteMath.Numeric&lt;T, C&gt;.Calculator.isIntegerCalculator</requires>
      <exception cref="T:whiteMath.NonIntegerTypeException">Numeric&gt;=T</exception>
      <requires description="module" exception="T:System.ArgumentNullException" csharp="(object)module != null" vb="((Object)module) &lt;&gt; Nothing">(object)module != null</requires>
      <exception cref="T:System.ArgumentNullException">module == null</exception>
      <requires description="The module should be more than 1." exception="T:System.ArgumentOutOfRangeException" csharp="op_Implicit(module) &gt; _1" vb="operator module &gt; _1 ">whiteMath.Numeric&lt;T, C&gt;.op_Implicit(module) &gt; whiteMath.Numeric&lt;T, C&gt;._1</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(module &gt; Numeric&lt;T)</exception>
      <requires description="All of the root degrees specified should be located inside the [1; N-1] interval." exception="T:System.ArgumentOutOfRangeException" csharp="for all x in rootDegrees 
{
    if (op_Implicit(x) &gt;= _1)
    {
        return op_Implicit(x) &lt; op_Implicit(module);

    }
    return false;

}
" vb="for all x in rootDegrees &lt;unprintable lambda&gt;">for all x in rootDegrees 
{
    if (whiteMath.Numeric&lt;T, C&gt;.op_Implicit(x) &gt;= whiteMath.Numeric&lt;T, C&gt;._1)
    {
        return whiteMath.Numeric&lt;T, C&gt;.op_Implicit(x) &lt; whiteMath.Numeric&lt;T, C&gt;.op_Implicit(module);

    }
    return false;

}
</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(Contract.ForAll&lt;T&gt;(rootDegrees, (x =&gt; x &gt;= Numeric&lt;T, C&gt;._1 &amp;&amp; x &lt; (Numeric&lt;T, C&gt;)module)))</exception>
    </member>
    <member name="M:whiteMath.WhiteMath`2.sine(`0,System.Int32)">
      <summary>
            Return the sine of the argument using Taylor series.
            
            It is strongly recommended that the argument is in range [-pi; pi],
            precision may be lost otherwise.
            <see cref="M:whiteMath.WhiteMath`2.sineCosineDivideNormalize(`0,`0)" /><see cref="M:whiteMath.WhiteMath`2.sineCosineSubstractNormalize(`0,`0)" /></summary>
      <param name="argument">The number whose sine is to be found.</param>
      <param name="taylorMemberCount">The amount of numbers in the taylor series.</param>
      <returns>The result of the sine computation.</returns>
    </member>
    <member name="M:whiteMath.WhiteMath`2.cosine(`0,System.Int32)">
      <summary>
            Return the cosine of the argument using Taylor series.
            It is strongly recommended that the argument is in range [-pi; pi]
            </summary>
      <param name="argument" />
      <param name="taylorMemberCount" />
      <returns />
    </member>
    <member name="M:whiteMath.WhiteMath`2.Tangent(`0,System.Int32)">
      <summary>
            Returns the tangent of the argument using Taylor series.
            </summary>
      <param name="argument" />
      <param name="taylorMemberCount" />
      <returns>The result of tangent computation.</returns>
    </member>
    <member name="M:whiteMath.WhiteMath`2.cotangent(`0,System.Int32)">
      <summary>
            Returns the cotangent of the argument using Taylor series
            using calls to sine and cosine functions.
            </summary>
      <param name="argument">The number whose cotangent is to be found.</param>
      <param name="taylorMemberCount">The amount of Taylor series member for sine and cosine functions.</param>
      <returns>The result of cotangent computation.</returns>
    </member>
    <member name="M:whiteMath.WhiteMath`2.sineCosineDivideNormalize(`0,`0)">
      <summary>
            Normalizes the number to the period [-pi; pi] as recommended by sine() and cosine() 
            methods of the class.
            
            Performes dividing the number by 2pi, substracting the integral part, multiplying by 2pi again and
            (possibly) shifting to reach the [-pi; pi] boundaries. May be inaccurate with low-precision types,
            but only way to use when the argument's absolute value is quite large.
            
            <see cref="M:whiteMath.WhiteMath`2.sineCosineSubstractNormalize(`0,`0)" /></summary>
      <param name="argument" />
      <param name="pi" />
      <returns />
    </member>
    <member name="M:whiteMath.WhiteMath`2.sineCosineSubstractNormalize(`0,`0)">
      <summary>
            Normalizes the number to the period [-pi; pi] as recommended by sine() and cosine() 
            methods of the class.
            
            Performed by iterative substraction/addition of the 2pi period from the numbers.
            Shows VERY poor performance when the argument's absolute value is large, but
            may be more precisive at "near-boundaries" ranges, depending on the type.
            
            <see cref="M:whiteMath.WhiteMath`2.sineCosineDivideNormalize(`0,`0)" /></summary>
      <param name="argument" />
      <param name="pi" />
      <returns />
    </member>
    <member name="M:whiteMath.WhiteMath`2.tangentCotangentDivideNormalize(`0,`0)">
      <summary>
            Normalizes the number to the period [0; pi] as recommended by the tangent() and cotangent()
            method of the class.
            
            Performes dividing the number by pi, substracting the integral part, multiplying by 2pi again and
            (possibly) shifting to reach the [0; pi] boundaries. May be inaccurate with low-precision types,
            but only way to use when the argument's absolute value is quite large.
            <see cref="M:whiteMath.WhiteMath`2.tangentCotangentSubstractNormalize(`0,`0)" /></summary>
      <param name="argument" />
      <param name="pi" />
      <returns />
    </member>
    <member name="M:whiteMath.WhiteMath`2.tangentCotangentSubstractNormalize(`0,`0)">
      <summary>
            Normalizes the number to the period [-pi; pi] as recommended by tangent() and cotangent() 
            methods of the class.
            
            Performed by iterative substraction/addition of the pi period from the numbers.
            Shows VERY poor performance when the argument's absolute value is large, but
            may be more precisive at "near-boundaries" ranges, depending on the type.
            
            <see cref="M:whiteMath.WhiteMath`2.sineCosineDivideNormalize(`0,`0)" /></summary>
      <param name="argument" />
      <param name="pi" />
      <returns />
    </member>
    <member name="M:whiteMath.WhiteMath`2.Modulus(`0,`0)">
      <summary>
            Returns the first number modulo second.
            Equivalent to the remainder operation; the formula for the modulus is:
            
            MODULUS = sgn(dividend) * (|dividend| - (|divisor| * floor(|dividend| / |divisor|))).
            
            May produce non-integer results for floating point numbers, use 
            Ceiling() / Floor() or Round() if needed!
            </summary>
      <see cref="M:whiteMath.WhiteMath`2.Ceiling(`0)" />
      <see cref="M:whiteMath.WhiteMath`2.Floor(`0)" />
      <see cref="M:whiteMath.WhiteMath`2.Round(`0)" />
      <param name="dividend">The number to be divided.</param>
      <param name="divisor">The number to be divided by.</param>
      <returns>The first operand modulo second operand.</returns>
    </member>
    <member name="M:whiteMath.WhiteMath`2.Round(`0)">
      <summary>
            Rounds a number to the nearest integer number.
            </summary>
      <param name="number">The number to be rounded.</param>
      <returns>The nearest integer number.</returns>
    </member>
    <member name="M:whiteMath.WhiteMath`2.Floor(`0)">
      <summary>
            Returns the nearest lower integer number.
            </summary>
      <param name="number">The number to be rounded.</param>
      <returns>The nearest lower integer number.</returns>
      <ensures csharp="op_Implicit(number) - op_Implicit(result) &gt;= Zero" vb="operator number - operator result  &gt;= Zero ">whiteMath.Numeric&lt;T, C&gt;.op_Implicit(number) - whiteMath.Numeric&lt;T, C&gt;.op_Implicit(result) &gt;= whiteMath.Numeric&lt;T, C&gt;.Zero</ensures>
      <ensures csharp="op_Implicit(number) - op_Implicit(result) &lt; _1" vb="operator number - operator result  &lt; _1 ">whiteMath.Numeric&lt;T, C&gt;.op_Implicit(number) - whiteMath.Numeric&lt;T, C&gt;.op_Implicit(result) &lt; whiteMath.Numeric&lt;T, C&gt;._1</ensures>
    </member>
    <member name="M:whiteMath.WhiteMath`2.Ceiling(`0)">
      <summary>
            Returns the nearest bigger integer number.
            </summary>
      <param name="number">The number to be rounded.</param>
      <returns>The nearest bigger integer number.</returns>
      <ensures csharp="op_Implicit(result) - op_Implicit(number) &gt;= Zero" vb="operator result - operator number  &gt;= Zero ">whiteMath.Numeric&lt;T, C&gt;.op_Implicit(result) - whiteMath.Numeric&lt;T, C&gt;.op_Implicit(number) &gt;= whiteMath.Numeric&lt;T, C&gt;.Zero</ensures>
      <ensures csharp="op_Implicit(result) - op_Implicit(number) &lt; _1" vb="operator result - operator number  &lt; _1 ">whiteMath.Numeric&lt;T, C&gt;.op_Implicit(result) - whiteMath.Numeric&lt;T, C&gt;.op_Implicit(number) &lt; whiteMath.Numeric&lt;T, C&gt;._1</ensures>
    </member>
    <member name="M:whiteMath.WhiteMath`2.Power(`0,`0,System.Int32)">
      <summary>
            Returns the number raised to the power specified by the user.
            Uses the Taylor series.
            </summary>
      <param name="number">The number to be raised to the power.</param>
      <param name="power">The power to be raised to.</param>
      <param name="taylorMemberCount">The minimal amount of Taylor series members used in calculations.</param>
      <returns />
    </member>
    <member name="M:whiteMath.WhiteMath`2.Exponent(`0,System.Int32)">
      <summary>
            Returns the exponent of a real (or complex) number.
            Uses the Taylor series, user can explicitly specify the amount of members used in calculations.
            </summary>
      <param name="number">The number whose exponent is to be found.</param>
      <param name="taylorMemberCount">The amount of Taylor member series used.</param>
      <returns />
    </member>
    <member name="M:whiteMath.WhiteMath`2.LogarithmNatural(`0,System.Int32)">
      <summary>
            Returns the natural logarithm of a real number.
            Uses the Taylor series, user can explicitly specify the amount of members used in calculations.
            </summary>
      <param name="number" />
      <param name="taylorMemberCount" />
      <returns />
    </member>
    <member name="M:whiteMath.WhiteMath`2.Sign(`0)">
      <summary>
             The signum function.
             Let 'zero' be the calculator's zero() method result/
             Signum of the number equals:
             
             a) 1, if (number &gt; zero);
             b) 0, if (number == zero);
             c) -1, if (number &lt; zero);
             </summary>
      <param name="number">The number to evaluate.</param>
      <returns>
             a) 1, if (number &gt; zero);
             b) 0, if (number == zero);
             c) -1, if (number &lt; zero);
            </returns>
    </member>
    <member name="M:whiteMath.WhiteMath`2.SquareRootHeron(`0,`0)">
            HERON SQUARE ROOT
            
            <summary>
            Performs a square root calculation using simple Heron algorithm.
            Works only for "positive" (number &gt;= calculator.zero()) numbers.
            Calculator should have reasonable fromInt() method implemented, because of the formula:
            
            x_{n+1} = 1/2 * (x_{n} + a/x_{n})
            
            Iteration would stop when the absolute difference between the numbers
            is less than epsilon parameter or when the iteration step results in no change.
            
            Restrictions:
            
            1. The calculator should have reasonable fromInt() method implemented and return a correct
            equivalent for "2".
            2. Suitable for floating-point numbers.
            
            Speed:
            
            Due to genericity, the x_{0} is evaluated equal to the passed number.
            About log(N) iterations is needed.
            
            </summary><param name="number">The number whose square root is to be found.</param><param name="epsilon">The precision of the calculation.</param><returns>The result of square root computation.</returns></member>
    <member name="M:whiteMath.WhiteMath`2.PowerInteger(`0,System.Int64)">
            POWER INTEGER
            
            <summary>
            Performs the quick mathematical power operation.
            Works only for integer exponent values.
            </summary><param name="number">The number to raise to the power.</param><param name="power">The exponent of the power.</param><returns>The number raised to the integer power.</returns></member>
    <member name="M:whiteMath.WhiteMath`2.PowerInteger_Generic(`0,`0)">
            POWER INTEGER
            
            <summary>
            Performs the quick mathematical power operation.
            Works only for integer exponent values.
            
            WARNING! The power value here should be an integer number,
            that is, the calculator method 'integerPower(power)' should
            return the same value as power. Otherwise, the result
            would be unpredictable AND INCORRECT.
            </summary><param name="number">The number to raise to the power.</param><param name="power">The INTEGER exponent of the power.</param><returns>The number raised to the integer power.</returns></member>
    <member name="M:whiteMath.WhiteMath`2.JacobiSymbol(`0,`0)">
      <summary>
            Returns the value of the Jacobi symbol for
            the two numbers, that is, the multiplication product
            of Legendre symbols with numerators all equal to the Jacobi symbol's
            numerator and denominators taken from the factorization
            of Jacobi symbol's denominator.
            </summary>
      <param name="num">The numerator of the Jacobi symbol.</param>
      <param name="denom">The denominator of the Jacobi symbol. Should be odd and positive.</param>
      <returns>The value of the Jacobi symbol for <paramref name="num" /> and <paramref name="denom" />.</returns>
      <requires description="The method works only for integer numeric types." exception="T:whiteMath.NonIntegerTypeException" csharp="Calculator.isIntegerCalculator" vb="Calculator.isIntegerCalculator">whiteMath.Numeric&lt;T, C&gt;.Calculator.isIntegerCalculator</requires>
      <exception cref="T:whiteMath.NonIntegerTypeException">Numeric&gt;=T</exception>
      <requires description="The denominator of the Jacobi symbol should be odd and positive." exception="T:System.ArgumentException" csharp="op_Implicit(denom) &gt; Zero &amp;&amp; !Calculator.isEven(denom)" vb="operator denom &gt; Zero  AndAlso Not Calculator.isEven(denom)">whiteMath.Numeric&lt;T, C&gt;.op_Implicit(denom) &gt; whiteMath.Numeric&lt;T, C&gt;.Zero &amp;&amp; !whiteMath.Numeric&lt;T, C&gt;.Calculator.isEven(denom)</requires>
      <exception cref="T:System.ArgumentException">!(denom &gt; Numeric&lt;T)</exception>
    </member>
    <member name="M:whiteMath.WhiteMath`2.ExtendedEuclideanAlgorithm(`0,`0,`0@,`0@)">
      <summary>
            Performs an Extended Euclidean algorithms on two positive numbers <c>one, two</c>,
            calculates their GCD and finds such integer <c>x, y</c> which satisfy Bezout's identity <c>one*x + two*y = 1</c>.
            </summary>
      <param name="one">The first number.</param>
      <param name="two">The second number.</param>
      <param name="x">The first coefficient in Bezout's identity <c>one*x + two*y = 1</c>.</param>
      <param name="y">The second coefficient in Bezout's identity <c>one*x + two*y = 1</c>.</param>
      <returns>The greatest common divisor of <paramref name="one" /> and <paramref name="two" />.</returns>
      <requires description="The method works only for integer numeric types." exception="T:whiteMath.NonIntegerTypeException" csharp="Calculator.isIntegerCalculator" vb="Calculator.isIntegerCalculator">whiteMath.Numeric&lt;T, C&gt;.Calculator.isIntegerCalculator</requires>
      <exception cref="T:whiteMath.NonIntegerTypeException">Numeric&gt;=T</exception>
      <requires description="None of the numbers should be zero." exception="T:System.ArgumentException" csharp="op_Implicit(one) != Zero &amp;&amp; op_Implicit(two) != Zero" vb="operator one &lt;&gt; Zero  AndAlso operator two &lt;&gt; Zero ">whiteMath.Numeric&lt;T, C&gt;.op_Implicit(one) != whiteMath.Numeric&lt;T, C&gt;.Zero &amp;&amp; whiteMath.Numeric&lt;T, C&gt;.op_Implicit(two) != whiteMath.Numeric&lt;T, C&gt;.Zero</requires>
      <exception cref="T:System.ArgumentException">!(one != Numeric&lt;T)</exception>
      <ensures csharp="op_Implicit(result) &gt; Zero" vb="operator result &gt; Zero ">whiteMath.Numeric&lt;T, C&gt;.op_Implicit(result) &gt; whiteMath.Numeric&lt;T, C&gt;.Zero</ensures>
      <ensures csharp="op_Implicit(one) % op_Implicit(result) == Zero" vb="operator one % operator result  = Zero ">whiteMath.Numeric&lt;T, C&gt;.op_Implicit(one) % whiteMath.Numeric&lt;T, C&gt;.op_Implicit(result) == whiteMath.Numeric&lt;T, C&gt;.Zero</ensures>
      <ensures csharp="op_Implicit(two) % op_Implicit(result) == Zero" vb="operator two % operator result  = Zero ">whiteMath.Numeric&lt;T, C&gt;.op_Implicit(two) % whiteMath.Numeric&lt;T, C&gt;.op_Implicit(result) == whiteMath.Numeric&lt;T, C&gt;.Zero</ensures>
    </member>
    <member name="M:whiteMath.WhiteMath`2.MultiplicativeInverse(`0,`0)">
      <summary>
            Using an Extended Euclidean Algorithm, finds a multiplicative
            inverse of a positive number on a coprime module.
            </summary>
      <param name="number">A positive number coprime to and less than '<paramref name="module" />'.</param>
      <param name="module">A positive number coprime to and bigger than '<paramref name="number" />'.</param>
      <remarks>
            If <paramref name="number" /> and <paramref name="module" /> are not coprime, the result
            of the function is incorrect.
            </remarks>
      <returns>A number which, multiplied by <paramref name="number" />, results in <see cref="T:whiteMath.Numeric`2" />.CONST_1</returns>
      <requires description="The module should be bigger than the number." exception="T:System.ArgumentOutOfRangeException" csharp="op_Implicit(module) &gt; op_Implicit(number)" vb="operator module &gt; operator number ">whiteMath.Numeric&lt;T, C&gt;.op_Implicit(module) &gt; whiteMath.Numeric&lt;T, C&gt;.op_Implicit(number)</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!((Numeric&lt;T, C&gt;)module &gt; number)</exception>
      <requires description="The number should be positive." exception="T:System.ArgumentOutOfRangeException" csharp="op_Implicit(number) &gt; Zero" vb="operator number &gt; Zero ">whiteMath.Numeric&lt;T, C&gt;.op_Implicit(number) &gt; whiteMath.Numeric&lt;T, C&gt;.Zero</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(number &gt; Numeric&lt;T)</exception>
      <requires csharp="op_Implicit(GreatestCommonDivisor(number, module)) == _1" vb="operator GreatestCommonDivisor(number, module) = _1 ">whiteMath.Numeric&lt;T, C&gt;.op_Implicit(whiteMath.WhiteMath&lt;T, C&gt;.GreatestCommonDivisor(number, module)) == whiteMath.Numeric&lt;T, C&gt;._1</requires>
      <ensures csharp="op_Implicit(number) * op_Implicit(result) % op_Implicit(module) == _1" vb="operator number * operator result  % operator module  = _1 ">whiteMath.Numeric&lt;T, C&gt;.op_Implicit(number) * whiteMath.Numeric&lt;T, C&gt;.op_Implicit(result) % whiteMath.Numeric&lt;T, C&gt;.op_Implicit(module) == whiteMath.Numeric&lt;T, C&gt;._1</ensures>
    </member>
    <member name="M:whiteMath.WhiteMath`2.GreatestCommonDivisor(`0,`0)">
      <summary>
            Finds the greatest common divisor of two integer-like numbers
            using the simple Euclid algorithm.
            
            The calculator for the numbers is recommended to provide reasonable implementation
            of the remainder operation (%) - otherwise, the function
            Modulus from whiteMath class will be used.
            
            Will work with floating-point type numbers only if they are integers;
            In case of division errors the result will be rounded and thus not guaranteed.
            </summary>
      <param name="one" />
      <param name="two" />
      <returns />
      <requires description="None of the numbers may be zero." exception="T:System.ArgumentException" csharp="op_Implicit(one) != Zero &amp;&amp; op_Implicit(two) != Zero" vb="operator one &lt;&gt; Zero  AndAlso operator two &lt;&gt; Zero ">whiteMath.Numeric&lt;T, C&gt;.op_Implicit(one) != whiteMath.Numeric&lt;T, C&gt;.Zero &amp;&amp; whiteMath.Numeric&lt;T, C&gt;.op_Implicit(two) != whiteMath.Numeric&lt;T, C&gt;.Zero</requires>
      <exception cref="T:System.ArgumentException">!(one != Numeric&lt;T)</exception>
      <ensures csharp="op_Implicit(result) &gt; Zero" vb="operator result &gt; Zero ">whiteMath.Numeric&lt;T, C&gt;.op_Implicit(result) &gt; whiteMath.Numeric&lt;T, C&gt;.Zero</ensures>
      <ensures csharp="op_Implicit(one) % op_Implicit(result) == Zero" vb="operator one % operator result  = Zero ">whiteMath.Numeric&lt;T, C&gt;.op_Implicit(one) % whiteMath.Numeric&lt;T, C&gt;.op_Implicit(result) == whiteMath.Numeric&lt;T, C&gt;.Zero</ensures>
      <ensures csharp="op_Implicit(two) % op_Implicit(result) == Zero" vb="operator two % operator result  = Zero ">whiteMath.Numeric&lt;T, C&gt;.op_Implicit(two) % whiteMath.Numeric&lt;T, C&gt;.op_Implicit(result) == whiteMath.Numeric&lt;T, C&gt;.Zero</ensures>
    </member>
    <member name="M:whiteMath.WhiteMath`2.LowestCommonMultiple(`0,`0)">
      <summary>
            Finds the lowest common multiple of two integer-like numbers from the equation:
            A * B = gcd(A,B) * lcm(A,B)
            </summary>
      <param name="one">The first number.</param>
      <param name="two">The second number.</param>
      <returns />
    </member>
    <member name="M:whiteMath.WhiteMath`2.LowestCommonMultiple(`0,`0,`0)">
      <summary>
            Finds the lowest common multiple of two integer-like numbers from the equation:
            A * B = gcd(A,B) * lcm(A,B)
            </summary>
      <param name="one">The first number.</param>
      <param name="two">The second number.</param>
      <param name="greatestCommonDivisor">The greatest common divisor for the numbers. Optional, if nothing is specified, it will be calculated.</param>
      <returns />
    </member>
    <member name="M:whiteMath.WhiteMath`2.Factorial(`0)">
      <summary>
            Returns the exact factorial of an integer number.
            Uses simple iteration.
            It is recommended that you use long integers (ex. LongInt) to avoid overflow exceptions.
            </summary>
      <param name="integer" />
      <returns />
    </member>
    <member name="M:whiteMath.WhiteMath`2.IsNaturalIntegerPowerOf(whiteMath.Numeric{`0,`1},whiteMath.Numeric{`0,`1},System.Nullable{System.Int32}@)">
      <summary>
            Checks whether the first number is some natural integer power of
            the argument passed. The exact value of the power is either null (if false)
            or int.
            </summary>
      <param name="one">The argument to test if it is the natural power of the second.</param>
      <param name="two">The second argument.</param>
      <param name="powerValue">The value of the integer power. Contains either null or the value of the integer power.</param>
      <returns>True if the first argument is the natural power of the second, false otherwise.</returns>
    </member>
    <member name="M:whiteMath.WhiteMath`2.PowerIntegerModular(`0,System.UInt64,`0)">
      <summary>
            Performs a fast modular integral modular exponentiation.
            </summary>
      <param name="number">An integer number to be exponentiated.</param>
      <param name="power">A non-negative integer exponent.</param>
      <param name="modulus">An integer modulus of the operation.</param>
      <returns>The result of raising <paramref name="number" /> to power <paramref name="power" /> modulo <paramref name="modulus" />.</returns>
      <pure />
      <requires description="This method works only for integer numeric types." exception="T:whiteMath.NonIntegerTypeException" csharp="Calculator.isIntegerCalculator" vb="Calculator.isIntegerCalculator">whiteMath.Numeric&lt;T, C&gt;.Calculator.isIntegerCalculator</requires>
      <exception cref="T:whiteMath.NonIntegerTypeException">Numeric&gt;=T</exception>
    </member>
    <member name="M:whiteMath.WhiteMath`2.SquareRootIntegerSimple(`0)">
      <summary>
            Returns the integer part of the square root
            of the number.
            </summary>
      <remarks>This method works only for integer numeric types.</remarks>
      <param name="number">A non-negative number for which the integer part of its square root is to be found.</param>
      <returns>The integer part of the square root of the <paramref name="number" />.</returns>
      <requires description="This method works only for integer numeric types." exception="T:whiteMath.NonIntegerTypeException" csharp="Calculator.isIntegerCalculator" vb="Calculator.isIntegerCalculator">whiteMath.Numeric&lt;T, C&gt;.Calculator.isIntegerCalculator</requires>
      <exception cref="T:whiteMath.NonIntegerTypeException">Numeric&gt;=T</exception>
      <requires description="The number passed to this method should not be negative." exception="T:System.ArgumentException" csharp="op_Implicit(number) &gt;= Zero" vb="operator number &gt;= Zero ">whiteMath.Numeric&lt;T, C&gt;.op_Implicit(number) &gt;= whiteMath.Numeric&lt;T, C&gt;.Zero</requires>
      <exception cref="T:System.ArgumentException">!((Numeric&lt;T,C&gt;)number &gt;= Numeric&lt;T)</exception>
    </member>
    <member name="M:whiteMath.WhiteMath`2.SquareRootInteger(`0,`0)">
      <summary>
            Returns the integer part of the square root
            of the number.
            </summary>
      <remarks>This method works only for integer numeric types.</remarks>
      <param name="number">A strictly positive number for which the integer part of its square root is to be found.</param>
      <param name="firstEstimate">
            A first estimate of the square root. 
            WARNING! This number should be more than or equal to the real 
            square root of the <paramref name="number" />, otherwise the behaviour 
            of this method is undefined.
            </param>
      <returns>The integer part of the square root of the <paramref name="number" />.</returns>
      <requires description="This method works only for integer numeric types." exception="T:whiteMath.NonIntegerTypeException" csharp="Calculator.isIntegerCalculator" vb="Calculator.isIntegerCalculator">whiteMath.Numeric&lt;T, C&gt;.Calculator.isIntegerCalculator</requires>
      <exception cref="T:whiteMath.NonIntegerTypeException">Numeric&gt;=T</exception>
      <requires description="The number passed to this method should not be negative." exception="T:System.ArgumentException" csharp="op_Implicit(number) &gt;= Zero" vb="operator number &gt;= Zero ">whiteMath.Numeric&lt;T, C&gt;.op_Implicit(number) &gt;= whiteMath.Numeric&lt;T, C&gt;.Zero</requires>
      <exception cref="T:System.ArgumentException">!((Numeric&lt;T, C&gt;)number &gt;= Numeric&lt;T)</exception>
    </member>
    <member name="M:whiteMath.WhiteMath`2.Min(`0,`0)">
      <summary>
            Finds the minimum of two numbers.
            
            If T is a reference type, please notice that no new objects are created
            during this procedure, consider calling MinCopy() if necessary.
            </summary>
      <param name="one" />
      <param name="two" />
      <returns />
    </member>
    <member name="M:whiteMath.WhiteMath`2.MinCopy(`0,`0)">
      <summary>
            Finds the minimum of two numbers and returns its copy.
            Safe for use with reference types - no changes made
            to the value returned will be reflected on any of the arguments.
            </summary>
      <param name="one" />
      <param name="two" />
      <returns />
    </member>
    <member name="M:whiteMath.WhiteMath`2.Max(`0,`0)">
      <summary>
            Finds the maximum of two numbers.
            
            If T is a reference type, please notice that no numbers are created
            during this procedure, consider calling MaxCopy() if necessary.
            </summary>
      <param name="one" />
      <param name="two" />
      <returns />
    </member>
    <member name="M:whiteMath.WhiteMath`2.MaxCopy(`0,`0)">
      <summary>
            Finds the maximum of two numbers and returns its copy.
            Safe for use with reference types - no changes made
            to the value returned will be reflected on any of the arguments.
            </summary>
      <param name="one" />
      <param name="two" />
      <returns />
    </member>
    <member name="M:whiteMath.WhiteMath`2.Abs(`0)">
            ABSOLUTE VALUE
            
            <summary>
            Returns the absolute value of a generic number.
            The method calls to the calculator's zero field representing
            a zero value for the number.
            
            If the result of the call to zero() is mor() than the number, 
            it is considered "negative", positive otherwise.
            
            Safe to use with reference-types, changes on the value returned
            won't be reflected on the argument passed.
            </summary><param name="number" /><returns /></member>
    <member name="M:whiteMath.WhiteMath.rootsOfUnity(System.Int32)">
      <summary>
            Returns the full series of complex roots of unity, starting with <c>(1, 0i)</c>.
            Used in Discrete Fourier Transform and has some other appliances.
            </summary>
      <param name="rootDegree">A positive integer degree of the root. May be 1.</param>
      <returns>
            The full series of complex roots of unity of 
            degree <paramref name="rootDegree" />, starting with <c>(1, 0i)</c>.
            </returns>
    </member>
    <member name="M:whiteMath.WhiteMathConstants.E_SpigotAlgorithm(System.Int32,System.Int32,System.Int32,System.Int64@)">
      <summary>
            Runs a spigot algorithm that calculates the first <paramref name="digitsCount" />
            digits for the transcend constant e.
            
            The digits returned are of base <paramref name="decimalBase" />,
            which should be a power of ten: 10, 100, 1000 etc.
            
            REQUIREMENTS:
            
            1. Memory consumption for the array of [n+<paramref name="safetyStorage" />] longs and the array of [n] ints.
            </summary>
      <param name="decimalBase">The decimal base of digits to be returned.</param>
      <param name="digitsCount">The overall digits count to be calculated.</param>
      <param name="safetyStorage">The safety storage of type long that is used to reduce the errors of calculations.</param>
      <returns>The array of 'e' digits.</returns>
    </member>
    <member name="M:whiteMath.WhiteMathConstants.PI_Rational_Leibnitz_Slow(System.Int32)">
      <summary>
            Returns the rational approximation of transcend PI constant
            using the Leibnitz series. Works slower than the other variation, but consumes
            significantly less memory.
            </summary>
      <param name="members" />
      <returns />
    </member>
    <member name="M:whiteMath.WhiteMathConstants.PI_Rational_Leibnitz_Quick(System.Int32)">
      <summary>
            Returns the rational approximation of transcend PI constant
            using the Leibnitz series.
            </summary>
      <param name="members" />
      <returns />
    </member>
    <member name="T:whiteMath.ArithmeticLong.BaseConversion">
      <summary>
            This class provides methods for converting from one numeric base to another.
            </summary>
    </member>
    <member name="M:whiteMath.ArithmeticLong.BaseConversion.getDigitEquivalent(System.Int32,System.Int32,System.Int32)">
      <summary>
            Returns the value specifying how many digits with base <paramref name="baseTo" /> will be enough
            to handle <paramref name="digitCount" /> digits with base <paramref name="baseFrom" />.
            </summary>
      <param name="baseFrom">The base to be converted.</param>
      <param name="baseTo">The base to be converted to.</param>
      <param name="digitCount">Amount of digits in <paramref name="baseFrom" /></param>
      <returns>The value specifying how many digits in <paramref name="baseTo" /> will be enough
            to handle the <paramref name="digitCount" /> digits in <paramref name="baseFrom" /></returns>
    </member>
    <member name="M:whiteMath.ArithmeticLong.BaseConversion.getBasePowers(System.Int32,System.Int32)">
      <summary>
            Возвращает массив различных степеней основания.
            </summary>
    </member>
    <member name="M:whiteMath.ArithmeticLong.BaseConversion.baseConvert(System.Collections.Generic.IList{System.Int32},System.Int32,System.Int32)">
      <summary>
            Converts the long integer digit list from one numeric base to another.
            </summary>
      <param name="from">The integer list containing the digits of base <paramref name="fromBase" /></param>
      <param name="fromBase">The numeric base of incoming list.</param>
      <param name="newBase">The numeric base for the incoming list to be converted to.</param>
      <returns>The list containing digits of numeric base <paramref name="newBase" />, whilst equal to the incoming list.</returns>
    </member>
    <member name="M:whiteMath.ArithmeticLong.BaseConversion.convertPowered(System.Collections.Generic.IList{System.Int32},System.Collections.Generic.IList{System.Int32},System.Int32,System.Int32,System.Int32)">
      <summary>
            Производит конвертацию из одной системы счисления в другую
            в том случае, если основания кратны.
            </summary>
    </member>
    <member name="T:whiteMath.ArithmeticLong.IBase">
      <summary>
            Provides the needed information on long integers numeric base
            and serves as the type argument for the LongInt class.
            
            No two numbers with different IBase could be used in the same
            arithmetic operation unless the user explicitly calls the
            baseConvert() method or the appropriate LongInt constructor.
            </summary>
    </member>
    <member name="M:whiteMath.ArithmeticLong.IBase.getBase">
      <summary>
            Returns the value of the digits numeric base.
            </summary>
      <returns />
      <ensures description="The base of number digits should be positive and more than 1." csharp="result &gt; 1" vb="result &gt; 1">result &gt; 1</ensures>
    </member>
    <member name="T:whiteMath.ArithmeticLong.IPrecision">
      <summary>
            Provides the needed information on numeric precision and serves as the 
            type argument for the LongExp class.
            
            No two numbers with different IPrecision could be used in the same
            arithmetic operation unless the user explicitly calls the 
            precisionConvert() method for the number (precision may be extended or lost depending
            on the calculator to convert to).
            </summary>
    </member>
    <member name="M:whiteMath.ArithmeticLong.IPrecision.getPrecision">
      <summary>
            Returns the precision, in decimal signs, for the LongExp mantiss.
            </summary>
      <returns />
      <ensures description="The precision of numbers specified by an IPrecision interface implementation should be positive." csharp="result &gt; 0" vb="result &gt; 0">result &gt; 0</ensures>
    </member>
    <member name="T:whiteMath.ArithmeticLong.LongIntegerMethods">
      <summary>
            This class provides static methods
            for different long integer calculation purposes.
            </summary>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongIntegerMethods.IsEven(System.Int32,System.Collections.Generic.IList{System.Int32})">
      <summary>
            Checks whether the specified long integer number is even.
            </summary>
      <param name="BASE">The base of digits of the <paramref name="operand" />. If even, the checking takes O(1) time. If odd, the time is O(n).</param>
      <param name="operand">A list which contains the digits of the long integer modulo <paramref name="BASE" />, starting with the least significant digit.</param>
      <returns>True if the long integer number defined by <paramref name="operand" /> is even, false otherwise.</returns>
      <requires description="The digit base should be a positive number bigger than 1." exception="T:System.ArgumentOutOfRangeException" csharp="BASE &gt; 1" vb="BASE &gt; 1">BASE &gt; 1</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">BASE &lt;= 1</exception>
      <requires description="operand" exception="T:System.ArgumentNullException" csharp="operand != null" vb="operand &lt;&gt; Nothing">operand != null</requires>
      <exception cref="T:System.ArgumentNullException">operand == null</exception>
      <requires description="The digits array should contain at least one digit." exception="T:System.ArgumentException" csharp="operand.Count &gt; 0" vb="operand.Count &gt; 0">operand.Count &gt; 0</requires>
      <exception cref="T:System.ArgumentException">operand.Count &lt;= 0</exception>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongIntegerMethods.IsDivisibleByFive(System.Int32,System.Collections.Generic.IList{System.Int32})">
      <summary>
            Checks whether the specified long integer number is divisible by five.
            </summary>
      <param name="BASE">The base of digits of the <paramref name="operand" />. If divisible by five, the checking takes O(1) time. If not, the time is O(n).</param>
      <param name="operand">A list which contains the digits of the long integer modulo <paramref name="BASE" />, starting with the least significant digit.</param>
      <returns>True if the long integer number defined by <paramref name="operand" /> is divisible by five, false otherwise.</returns>
      <requires description="The digit base should be a positive number bigger than 1." exception="T:System.ArgumentOutOfRangeException" csharp="BASE &gt; 1" vb="BASE &gt; 1">BASE &gt; 1</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">BASE &lt;= 1</exception>
      <requires description="operand" exception="T:System.ArgumentNullException" csharp="operand != null" vb="operand &lt;&gt; Nothing">operand != null</requires>
      <exception cref="T:System.ArgumentNullException">operand == null</exception>
      <requires description="The digits array should contain at least one digit." exception="T:System.ArgumentException" csharp="operand.Count &gt; 0" vb="operand.Count &gt; 0">operand.Count &gt; 0</requires>
      <exception cref="T:System.ArgumentException">operand.Count &lt;= 0</exception>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongIntegerMethods.More(System.Collections.Generic.IList{System.Int32},System.Collections.Generic.IList{System.Int32},System.Boolean@)">
      <summary>
            Checks whether one natural long integer number is bigger than another.
            Digit arrays can contain leading zeroes, digits should be of the same base for both parameters.
            Need not specify BASE.
            </summary>
      <param name="one">The first long integer digits array.</param>
      <param name="two">The second long integer digits array.</param>
      <param name="equals">The out argument showing if the second number is actually equal to the first one.</param>
      <returns />
      <requires description="one" exception="T:System.ArgumentNullException" csharp="one != null" vb="one &lt;&gt; Nothing">one != null</requires>
      <exception cref="T:System.ArgumentNullException">one == null</exception>
      <requires description="two" exception="T:System.ArgumentNullException" csharp="two != null" vb="two &lt;&gt; Nothing">two != null</requires>
      <exception cref="T:System.ArgumentNullException">two == null</exception>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongIntegerMethods.Equals(System.Collections.Generic.IList{System.Int32},System.Collections.Generic.IList{System.Int32})">
      <summary>
            Checks whether the two natural long integers store the same value.
            Digits array can contain leading zeroes, digits should be of the same BASE. (need not specify)
            </summary>
      <param name="one" />
      <param name="two" />
      <returns />
      <requires description="one" exception="T:System.ArgumentNullException" csharp="one != null" vb="one &lt;&gt; Nothing">one != null</requires>
      <exception cref="T:System.ArgumentNullException">one == null</exception>
      <requires description="two" exception="T:System.ArgumentNullException" csharp="two != null" vb="two &lt;&gt; Nothing">two != null</requires>
      <exception cref="T:System.ArgumentNullException">two == null</exception>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongIntegerMethods.Sum(System.Int32,System.Collections.Generic.IList{System.Int32}[])">
      <summary>
            Returns the sum of several long integer numbers.
            </summary>
      <param name="BASE">The base of digits in numbers (ex.: 10, 100, 1000)</param>
      <param name="sumOperands">The list of sum operands.</param>
      <returns>The digit array containing the sum and NO trailing zeroes.</returns>
      <requires description="The digit base should be a positive number bigger than 1." exception="T:System.ArgumentOutOfRangeException" csharp="BASE &gt; 1" vb="BASE &gt; 1">BASE &gt; 1</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">BASE &lt;= 1</exception>
      <requires description="sumOperands" exception="T:System.ArgumentNullException" csharp="sumOperands != null" vb="sumOperands &lt;&gt; Nothing">sumOperands != null</requires>
      <exception cref="T:System.ArgumentNullException">sumOperands == null</exception>
      <requires description="The number of the operands should be more than 1." exception="T:System.ArgumentException" csharp="sumOperands.Length &gt; 1" vb="sumOperands.Length &gt; 1">sumOperands.Length &gt; 1</requires>
      <exception cref="T:System.ArgumentException">sumOperands.Length &lt;= 1</exception>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongIntegerMethods.Sum(System.Int32,System.Collections.Generic.IList{System.Int32},System.Collections.Generic.IList{System.Int32}[])">
      <summary>
            Calculates the sum of several long integer numbers.
            </summary>
      <remarks>
            WARNING: if the length of the largest operand is N, and there are M operands, 
            the result should be safe to store at least N + ceil(log(M, BASE)) digits. Note that no checking 
            is performed, thus the operation may result in a loss.
            </remarks>
      <param name="result">The result digits array. Should be safe to store at least N + ceil(log(M, BASE)) digits.</param>
      <param name="BASE">The base of digits in numbers (ex.: 10, 100, 1000)</param>
      <requires description="The digit base should be a positive number bigger than 1." exception="T:System.ArgumentOutOfRangeException" csharp="BASE &gt; 1" vb="BASE &gt; 1">BASE &gt; 1</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">BASE &lt;= 1</exception>
      <requires description="result" exception="T:System.ArgumentNullException" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</requires>
      <exception cref="T:System.ArgumentNullException">result == null</exception>
      <requires description="sumOperands" exception="T:System.ArgumentNullException" csharp="sumOperands != null" vb="sumOperands &lt;&gt; Nothing">sumOperands != null</requires>
      <exception cref="T:System.ArgumentNullException">sumOperands == null</exception>
      <requires description="The number of the operands should be more than 1." exception="T:System.ArgumentException" csharp="sumOperands.Length &gt; 1" vb="sumOperands.Length &gt; 1">sumOperands.Length &gt; 1</requires>
      <exception cref="T:System.ArgumentException">sumOperands.Length &lt;= 1</exception>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongIntegerMethods.SumShifted(System.Int32,System.Collections.Generic.IList{System.Int32},System.Int32,System.Collections.Generic.IList{System.Int32},System.Int32)">
      <summary>
            Returns the sum of two long integer numbers, each shifted
            left by certain amounts of BASE-based digits.
            </summary>
      <param name="BASE">The base of digits in the numbers.</param>
      <param name="operand1">The digits list of the first number.</param>
      <param name="shift1">A positive amount of digits for the first number to shift left by.</param>
      <param name="operand2">The digits list of the second number.</param>
      <param name="shift2">A positive amount of digits for the second number to shift left by.</param>
      <returns>The digits array of the result containing only significant digits.</returns>
      <requires description="The left shift should have a positive amount of bits." exception="T:System.ArgumentOutOfRangeException" csharp="shift1 &gt;= 0" vb="shift1 &gt;= 0">shift1 &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">shift1 &lt; 0</exception>
      <requires description="The left shift should have a positive amount of bits." exception="T:System.ArgumentOutOfRangeException" csharp="shift2 &gt;= 0" vb="shift2 &gt;= 0">shift2 &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">shift2 &lt; 0</exception>
      <requires description="operand1" exception="T:System.ArgumentNullException" csharp="operand1 != null" vb="operand1 &lt;&gt; Nothing">operand1 != null</requires>
      <exception cref="T:System.ArgumentNullException">operand1 == null</exception>
      <requires description="operand2" exception="T:System.ArgumentNullException" csharp="operand2 != null" vb="operand2 &lt;&gt; Nothing">operand2 != null</requires>
      <exception cref="T:System.ArgumentNullException">operand2 == null</exception>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongIntegerMethods.SumShifted(System.Int32,System.Collections.Generic.IList{System.Int32},System.Collections.Generic.IList{System.Int32},System.Int32,System.Collections.Generic.IList{System.Int32},System.Int32)">
      <summary>
            Calculates the sum of two long integer numbers, each shifted
            left by certain amounts of BASE-based digits.
            </summary>
      <param name="BASE">The base of digits in the numbers.</param>
      <param name="result">The digits list to store the result. If N = max(operand1.Count + shift1, operand2.Count + shift2), this list should be able to store at least N+1 digits. Otherwise, the result will be cut.</param>
      <param name="operand1">The digits list of the first number.</param>
      <param name="shift1">A positive amount of digits for the first number to shift left by.</param>
      <param name="operand2">The digits list of the second number.</param>
      <param name="shift2">A positive amount of digits for the second number to shift left by.</param>
      <requires description="The left shift should have a positive amount of bits." exception="T:System.ArgumentOutOfRangeException" csharp="shift1 &gt;= 0" vb="shift1 &gt;= 0">shift1 &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">shift1 &lt; 0</exception>
      <requires description="The left shift should have a positive amount of bits." exception="T:System.ArgumentOutOfRangeException" csharp="shift2 &gt;= 0" vb="shift2 &gt;= 0">shift2 &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">shift2 &lt; 0</exception>
      <requires description="operand1" exception="T:System.ArgumentNullException" csharp="operand1 != null" vb="operand1 &lt;&gt; Nothing">operand1 != null</requires>
      <exception cref="T:System.ArgumentNullException">operand1 == null</exception>
      <requires description="operand2" exception="T:System.ArgumentNullException" csharp="operand2 != null" vb="operand2 &lt;&gt; Nothing">operand2 != null</requires>
      <exception cref="T:System.ArgumentNullException">operand2 == null</exception>
      <requires description="result" exception="T:System.ArgumentNullException" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</requires>
      <exception cref="T:System.ArgumentNullException">result == null</exception>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongIntegerMethods.Dif(System.Int32,System.Collections.Generic.IList{System.Int32},System.Collections.Generic.IList{System.Int32},System.Collections.Generic.IList{System.Int32})">
      <summary>
            Calculates the difference between two natural long integer numbers.
            WARNING: if the length of the bigger number is N, then the result
            digits array should be able to store N digits as well.
            
            No checking is performed, thus an <c>IndexOutOfBoundsException</c> can be thrown.
            
            We assume that number 'one' is more than number 'two'.
            If, nevertheless, <paramref name="two" /> is bigger than <paramref name="one" />, the function would return <c>true</c>
            and the result would be equal to (<c>BASE^result.Length - trueResultValue</c>);
            </summary>
      <param name="one" />
      <param name="two" />
      <param name="result" />
      <param name="BASE" />
      <requires description="one" exception="T:System.ArgumentNullException" csharp="one != null" vb="one &lt;&gt; Nothing">one != null</requires>
      <exception cref="T:System.ArgumentNullException">one == null</exception>
      <requires description="two" exception="T:System.ArgumentNullException" csharp="two != null" vb="two &lt;&gt; Nothing">two != null</requires>
      <exception cref="T:System.ArgumentNullException">two == null</exception>
      <requires description="result" exception="T:System.ArgumentNullException" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</requires>
      <exception cref="T:System.ArgumentNullException">result == null</exception>
      <ensures csharp="for all x in result x &gt;= 0" vb="for all x in result x &gt;= 0">for all x in result x &gt;= 0</ensures>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongIntegerMethods.Div(System.Int32,System.Collections.Generic.IList{System.Int32},System.Collections.Generic.IList{System.Int32},System.Collections.Generic.IList{System.Int32}@)">
      <summary>
            Performs the division (with remainder) of two long integer numbers.
            Returns the quotient containing only significant digits.
            
            The remainder containing only significant digits is passed as an 'out' parameter.
            </summary>
      <param name="BASE">The digit base integers to divide one by another.</param>
      <param name="one">The dividend.</param>
      <param name="two">The divisor.</param>
      <param name="remainder">The reference to store the remainder.</param>
      <returns>The quotient containing only significant digits (no trailing zeroes).</returns>
      <requires description="one" exception="T:System.ArgumentNullException" csharp="one != null" vb="one &lt;&gt; Nothing">one != null</requires>
      <exception cref="T:System.ArgumentNullException">one == null</exception>
      <requires description="two" exception="T:System.ArgumentNullException" csharp="two != null" vb="two &lt;&gt; Nothing">two != null</requires>
      <exception cref="T:System.ArgumentNullException">two == null</exception>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures csharp="remainder != null" vb="remainder &lt;&gt; Nothing">remainder != null</ensures>
      <ensures csharp="for all x in result x &gt;= 0" vb="for all x in result x &gt;= 0">for all x in result x &gt;= 0</ensures>
      <ensures csharp="for all x in remainder x &gt;= 0" vb="for all x in remainder x &gt;= 0">for all x in remainder x &gt;= 0</ensures>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongIntegerMethods.Div(System.Int32,System.Collections.Generic.IList{System.Int32},System.Collections.Generic.IList{System.Int32},System.Collections.Generic.IList{System.Int32})">
      <summary>
            Performs the division (with remainder) of two long integer numbers.
            The method would return the list containing the remainder digits.
            </summary>
      <returns>The list containing the remainder digits.</returns>
      <param name="BASE">The numberic base of the digits, ex. 10 000</param>
      <param name="result">The digits array to store the result. WARNING! Should be able to store AT LEAST one.Count - two.Count + 1 digits.</param>
      <param name="one">The digits array containing the first operand.</param>
      <param name="two">The digits array containing the second operand.</param>
      <requires description="result" exception="T:System.ArgumentNullException" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</requires>
      <exception cref="T:System.ArgumentNullException">result == null</exception>
      <requires description="one" exception="T:System.ArgumentNullException" csharp="one != null" vb="one &lt;&gt; Nothing">one != null</requires>
      <exception cref="T:System.ArgumentNullException">one == null</exception>
      <requires description="two" exception="T:System.ArgumentNullException" csharp="two != null" vb="two &lt;&gt; Nothing">two != null</requires>
      <exception cref="T:System.ArgumentNullException">two == null</exception>
      <requires csharp="for all x in one x &gt;= 0" vb="for all x in one x &gt;= 0">for all x in one x &gt;= 0</requires>
      <requires csharp="for all x in two x &gt;= 0" vb="for all x in two x &gt;= 0">for all x in two x &gt;= 0</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures csharp="for all x in result x &gt;= 0" vb="for all x in result x &gt;= 0">for all x in result x &gt;= 0</ensures>
      <ensures csharp="for all x in result x &gt;= 0" vb="for all x in result x &gt;= 0">for all x in result x &gt;= 0</ensures>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongIntegerMethods.DivideByInteger(System.Int32,System.Collections.Generic.IList{System.Int32},System.Int32,System.Int32@)">
      <summary>
            Divides the natural long integer number by a natural integer value.
            The method would return an array containing only significant digits of the quotient.
            The integer remainder is passed as an out parameter.
            </summary>
      <param name="BASE">The base of dividend's digits.</param>
      <param name="one">The natural long integer dividend.</param>
      <param name="two">The natural integer divisor.</param>
      <param name="remainder">The reference to store the remainder.</param>
      <returns>An array containing only significant digits of the quotient.</returns>
      <requires description="one" exception="T:System.ArgumentNullException" csharp="one != null" vb="one &lt;&gt; Nothing">one != null</requires>
      <exception cref="T:System.ArgumentNullException">one == null</exception>
      <requires description="The divisor should be a non-negative integer number." exception="T:System.ArgumentOutOfRangeException" csharp="two &gt;= 0" vb="two &gt;= 0">two &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">two &lt; 0</exception>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongIntegerMethods.DivideByInteger(System.Int32,System.Collections.Generic.IList{System.Int32},System.Collections.Generic.IList{System.Int32},System.Int32)">
      <summary>
            Divides the natural long integer number by a natural integer value.
            The method would return the remainder of the operation.
            </summary>
      <param name="BASE">The base of the digits in operands.</param>
      <param name="result">The digit array to contain the result. WARNING! Should be safe to store all [one.Count] digits</param>
      <param name="one">The first operand. Should be NATURAL (&gt;=0)</param>
      <param name="two">The second operand. Should be NATURAL (&gt;=0)</param>
      <requires description="result" exception="T:System.ArgumentNullException" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</requires>
      <exception cref="T:System.ArgumentNullException">result == null</exception>
      <requires description="one" exception="T:System.ArgumentNullException" csharp="one != null" vb="one &lt;&gt; Nothing">one != null</requires>
      <exception cref="T:System.ArgumentNullException">one == null</exception>
      <requires description="The divisor should be a non-negative integer number." exception="T:System.ArgumentOutOfRangeException" csharp="two &gt;= 0" vb="two &gt;= 0">two &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">two &lt; 0</exception>
      <requires csharp="for all x in one x &gt;= 0" vb="for all x in one x &gt;= 0">for all x in one x &gt;= 0</requires>
      <ensures csharp="result &gt;= 0" vb="result &gt;= 0">result &gt;= 0</ensures>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongIntegerMethods.MultiplySimple(System.Int32,System.Collections.Generic.IList{System.Int32},System.Collections.Generic.IList{System.Int32},System.Collections.Generic.IList{System.Int32})">
      <summary>
            Multiplies one natural long integer by another.
            The result digits array must be safe to contain one.Count + two.Count elements.
            </summary>
      <param name="BASE" />
      <param name="result" />
      <param name="one" />
      <param name="two" />
      <requires description="result" exception="T:System.ArgumentNullException" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</requires>
      <exception cref="T:System.ArgumentNullException">result == null</exception>
      <requires description="one" exception="T:System.ArgumentNullException" csharp="one != null" vb="one &lt;&gt; Nothing">one != null</requires>
      <exception cref="T:System.ArgumentNullException">one == null</exception>
      <requires description="two" exception="T:System.ArgumentNullException" csharp="two != null" vb="two &lt;&gt; Nothing">two != null</requires>
      <exception cref="T:System.ArgumentNullException">two == null</exception>
      <requires csharp="for all x in one x &gt;= 0" vb="for all x in one x &gt;= 0">for all x in one x &gt;= 0</requires>
      <requires csharp="for all x in two x &gt;= 0" vb="for all x in two x &gt;= 0">for all x in two x &gt;= 0</requires>
      <ensures csharp="for all x in result x &gt;= 0" vb="for all x in result x &gt;= 0">for all x in result x &gt;= 0</ensures>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongExp`1.#ctor">
      <summary>
            Parameterless constructor, sets the zero number value.
            </summary>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongExp`1.#ctor(System.Int32,whiteMath.BoundedInterval{System.Int32,whiteMath.CalcInt},System.Random)">
      <summary>
            The constructor designed to create a pseudo-random LongExp
            number, using an integer amount of decimal digits specified by the user.
            </summary>
      <param name="powerInterval">An interval in which the exponent of the number can be presented.</param>
      <param name="generator">A random generator for the digits.</param>
      <param name="digitCount">The digit length of the number. Cannot be more than specified by IPrecision precision class.</param>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongExp`1.precisionConvert``1">
      <summary>
            Creates an independent dependent copy of the number to provide another precision.
            The precision class should be specified as the type argument for the method.
            
            REQUIREMENTS: will NOT convert to another numeric base. Only to another precision.
            </summary>
      <typeparam name="T">The precision class.</typeparam>
      <returns />
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongExp`1.Normalize">
      <summary>
            Normalizes the number so that it does not contain any leading zeroes
            (exponent additions may occur) and its precision is in the range
            specified by used IPrecision class.
            </summary>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongExp`1.getDigitFormatter">
      <summary>
            Gets the digit formatter for ToString() output.
            </summary>
      <returns />
    </member>
    <member name="P:whiteMath.ArithmeticLong.LongExp`1.Exponent">
      <summary>
            Gets the exponent of the number.
            </summary>
    </member>
    <member name="P:whiteMath.ArithmeticLong.LongExp`1.Mantiss">
      <summary>
            Gets the array of mantiss digits for the number.
            </summary>
    </member>
    <member name="P:whiteMath.ArithmeticLong.LongExp`1.Negative">
      <summary>
            Gets the flag determining whether the number is negative.
            </summary>
    </member>
    <member name="T:whiteMath.ArithmeticLong.Bases.B_Var">
      <summary>
            This class presents an IBase interface for arbitrary numeric base.
            It allows you to set the base only once for consistency. 
            </summary>
    </member>
    <member name="P:whiteMath.ArithmeticLong.Bases.B_Var.HasBase">
      <summary>
            Returns true if the class is usable, i.e. the base has been set.
            </summary>
    </member>
    <member name="P:whiteMath.ArithmeticLong.Bases.B_Var.Base">
      <summary>
            Gets or sets the numeric base returned by the variable base class.
            The getter can only be used after the setter, and the setter can
            only be used once.
            </summary>
    </member>
    <member name="T:whiteMath.ArithmeticLong.Precisions">
      <summary>
            Static class containing the precisions for the LongExp numbers.
            </summary>
    </member>
    <member name="T:whiteMath.ArithmeticLong.Precisions.P_20k_10k">
      <summary>
            The precision for 20 000 decimal signs with digit base 10 000.
            </summary>
    </member>
    <member name="T:whiteMath.ArithmeticLong.Precisions.P_50k_10k">
      <summary>
            The precision for 50 000 decimal signs with digit base 10 000.
            </summary>
    </member>
    <member name="T:whiteMath.ArithmeticLong.Precisions.P_100k_10k">
      <summary>
            The precision for 100 000 decimal signs with digit base 10 000.
            </summary>
    </member>
    <member name="T:whiteMath.ArithmeticLong.Precisions.P_1000k_10k">
      <summary>
            The precision for 1 000 000 decimal signs with digit base 10 000.
            </summary>
    </member>
    <member name="T:whiteMath.ArithmeticLong.LongInt`1">
      <summary>
            Represents a long integer number with theoretically unlimited precision.
            </summary>
      <invariant>this.Digits != null</invariant>
      <invariant>Contract.ForAll(this.Digits, x =&gt; (x &gt;= 0))</invariant>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.#cctor">
      <summary>
            Статическая инициализация. Проверяет, не является ли основание числа целой степенью
            десятки или двойки.
            </summary>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.#ctor">
      <summary>
            Parameterless constructor, sets the zero value.
            </summary>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.#ctor(System.Int32,whiteMath.Randoms.IRandomBounded{System.Int32},System.Boolean)">
      <summary>
            The constructor designed to create a pseudo-random LongInt
            number, using a positive integer amount of BASE-based digits specified by the user.
            </summary>
      <param name="generator">The IRandom generator for the digits.</param>
      <param name="digitCount">The amount of BASE-based digits for the number.</param>
      <param name="allowNegative">An optional parameter which signalizes whether negative numbers should be allowed.</param>
      <requires description="The number of digits should be positive" exception="T:System.ArgumentOutOfRangeException" csharp="digitCount &gt; 0" vb="digitCount &gt; 0">digitCount &gt; 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">digitCount &lt;= 0</exception>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.#ctor(System.Int32,System.Int32,System.Boolean)">
      <summary>
            This constructor is designed to create a LongInt number
            using a positive amount of BASE-based digits, filling the number with a fixed specified digit.
            </summary>
      <param name="digitCount">The amount of BASE-based digits for the number.</param>
      <param name="digit">The digit to fill the number with.</param>
      <param name="negative">If this flag is true, the number will be considered negative.</param>
      <requires description="The number of digits should be positive" exception="T:System.ArgumentOutOfRangeException" csharp="digitCount &gt; 0" vb="digitCount &gt; 0">digitCount &gt; 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">digitCount &lt;= 0</exception>
      <requires description="The digit to fill the number with should be less than BASE." exception="T:System.ArgumentOutOfRangeException" csharp="digit &lt; whiteMath.ArithmeticLong.LongInt&lt;B&gt;.BASE" vb="digit &lt; whiteMath.ArithmeticLong.LongInt(Of B).BASE">digit &lt; whiteMath.ArithmeticLong.LongInt&lt;B&gt;.BASE</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">digit &gt;= BASE</exception>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.CreateRandom_Decimal(System.Int32,whiteMath.Randoms.IRandomBounded{System.Int32},System.Boolean)">
      <summary>
            The constructor designed to create a pseudo-random LongInt
            number, using an integer amount of DECIMAL digits specified by the user.
            
            For example, if the BASE of the current number is 10 000, and
            <paramref name="decimalDigitCount" /> is 5, the number would contain
            two 10000-based digits.
            </summary>
      <remarks>The method works ONLY when the <c>BASE</c> is an exact integer power of ten.</remarks>
      <exception cref="T:System.NotSupportedException">This method will throw if the BASE is not an exact integer power of ten.</exception>
      <param name="generator">The IRandom implementation to generate uniformly distributed integer values.</param>
      <param name="decimalDigitCount">The amount of decimal digits for the number to be generated.</param>
      <param name="allowNegative">The flag which signalizes if negative values are allowed.</param>
      <returns>A pseudo-random LongInt number with the desired amount of decimal digits.</returns>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.CreateRandom_Binary(System.Int32,whiteMath.Randoms.IRandomBounded{System.Int32},System.Boolean)">
      <summary>
            The constructor designed to create a pseudo-random LongInt
            number, using an integer amount of BINARY digits (bits) specified by the user.
            
            For example, if the BASE of the current number is 256, and
            <paramref name="binaryDigitCount" /> is 9, the number would contain
            two 256-based digits.
            </summary>
      <remarks>The method works ONLY for bases which are an exact integer power of two.</remarks>
      <exception cref="T:System.NotSupportedException">This method will throw if the <c>BASE</c> is not an exact integer power of two.</exception>
      <param name="generator">The IRandom implementation to generate uniformly distributed integer values.</param>
      <param name="binaryDigitCount">The amount of decimal digits for the number to be generated.</param>
      <param name="allowNegative">The flag which signalizes if negative values are allowed.</param>
      <returns>A pseudo-random LongInt number with the desired amount of binary digits (bits).</returns>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.CreatePowerOfBase(System.Int32)">
      <summary>
            Creates a <c>LongInt&lt;<typeparamref name="B" />&gt;</c> number which
            is a desired power of <c>BASE</c>.
            </summary>
      <param name="basePower">The desired non-negative power of <c>BASE</c>.</param>
      <returns>
            A <c>LongInt&lt;<typeparamref name="B" />&gt;</c> number which
            is a desired power of <c>BASE</c>.
            </returns>
      <requires description="The power of BASE should not be negative." exception="T:System.ArgumentOutOfRangeException" csharp="basePower &gt;= 0" vb="basePower &gt;= 0">basePower &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">basePower &lt; 0</exception>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.#ctor(System.Int32,System.Collections.Generic.IList{System.Int32},System.Boolean)">
      <summary>
            Initializes the LongInt number with a user-specified digit list.
            If the BASE of digits in <paramref name="digitsArray" /> is other than LongInt.BASE,
            the conversion may take longer time.
            </summary>
      <param name="BASE">The base of digits in the digit list.</param>
      <param name="digitsArray">A list of digits with increasing significance (the leftmost digit corresponds to BASE^0).</param>
      <param name="negative">A parameter which signalizes if the number should be treated as negative.</param>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.#ctor(System.Int32)">
      <summary>
            Private constructor made for quick-trick.
            </summary>
      <param name="initialSize" />
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.#ctor(System.Int64)">
      <summary>
            Makes a LongInt from the standard long.
            </summary>
      <param name="num">The long number to convert into LongInt.</param>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.op_Explicit(whiteMath.ArithmeticLong.LongInt{`0})~System.Int64">
      <summary>
            Performs an unchecked conversion of a LongInt number into a primitive long.
            </summary>
      <exception cref="T:System.OverflowException">May result in an overflow exception.</exception>
      <returns>A long number which is equal to the current number.</returns>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.op_Implicit(System.Int64)~whiteMath.ArithmeticLong.LongInt{`0}">
      <summary>
            Performs an implicit conversion of a long number into LongInt.
            </summary>
      <param name="num">The long number to convert.</param>
      <returns>The LongInt number.</returns>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.op_Multiply(whiteMath.ArithmeticLong.LongInt{`0},whiteMath.ArithmeticLong.LongInt{`0})">
      <summary>
            Multiplies one LongInt number by another.
            </summary>
      <param name="one" />
      <param name="two" />
      <returns />
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.op_UnaryNegation(whiteMath.ArithmeticLong.LongInt{`0})">
      <summary>
            Unary minus operator. Negates the number.
            </summary>
      <param name="num" />
      <returns />
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.op_Increment(whiteMath.ArithmeticLong.LongInt{`0})">
      <summary>
            Increments the current number by one.
            </summary>
      <param name="num" />
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.op_Decrement(whiteMath.ArithmeticLong.LongInt{`0})">
      <summary>
            Decrements the current number by one.
            </summary>
      <param name="num">The number to be decremented.</param>
      <returns>The original number in the decremented state.</returns>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.BaseRootMultiply(System.Int32,System.Int32,System.Int32)">
      <summary>
            If the base of the current number digits is an integer power of some value <paramref name="rootValue" />,
            then this method, provided with information on which power it is exactly (<paramref name="rootDegree" />),
            will return the current number multiplied by <paramref name="rootValue" />^<paramref name="rootPower" />.
            
            Is QUICK for any digit bases. Takes as much as O(n) time to perform.
            
            For example, if the base of number digits is 125, you can easily perform
            a multiplication by 25, because the base is a power of five, and 25 is 5^2.
            
            Thus the result would be [current num] * 5^2 - and calculated quickly.
            
            WARNING: the method will return totally wrong values if the base of the digits for current number
            is not an exact integer power of <paramref name="rootValue" />.
            </summary>
      <param name="rootValue">The number which is, being powered to <paramref name="rootDegree" />, equals to the current number's digits base.</param>
      <param name="rootDegree">The exponent of the <paramref name="rootValue" /> which makes the expression <paramref name="rootValue" />^<paramref name="rootDegree" /> be equal to the current base.</param>
      <param name="rootPower">The value of <paramref name="rootValue" />'s integer power to multiply by. For example, if <paramref name="rootPower" /> is 2 and <paramref name="rootValue" /> is 5, the multiplication by 25 will be performed.</param>
      <returns>The result of current number's multiplication by <paramref name="rootValue" />^<paramref name="rootPower" />.</returns>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.BaseRootDivide(System.Int32,System.Int32,System.Int32)">
      <summary>
            If the base of the current number digits is an integer power of some value <paramref name="rootValue" />,
            then this method, provided with information on which power it is exactly (<paramref name="rootDegree" />),
            will return the current number integrally divided by <paramref name="rootValue" />^<paramref name="rootPower" />.
            
            Is QUICK for any digit bases. Takes as much as O(n) time to perform.
            
            For example, if the base of number digits is 125, you can easily perform
            a division by 25, because the base is a power of five, and 25 is 5^2.
            
            Thus the result would be [current num] / 5^2 - and calculated quickly.
            
            WARNING: the method will return totally wrong values if the base of current number's digits
            is not an exact integer power of <paramref name="rootValue" />.
            </summary>
      <param name="rootValue">The number which is, being powered to <paramref name="rootDegree" />, equals to the current number's digits base.</param>
      <param name="rootDegree">The exponent of the <paramref name="rootValue" /> which makes the expression <paramref name="rootValue" />^<paramref name="rootDegree" /> be equal to the current base.</param>
      <param name="rootPower">The value of <paramref name="rootValue" />'s integer power to divide by. For example, if <paramref name="multiplyByRootPower" /> is 2 and <paramref name="rootValue" /> is 5, the division by 25 will be performed.</param>
      <returns>The result of current number's division by <paramref name="rootValue" />^<paramref name="rootPower" />.</returns>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.BaseMultiply(System.Int32)">
      <summary>
            If the digits base for the current number X is BASE,
            the method would return return 
            X * BASE ^ <paramref name="basePower" />.
            
            Equivalent to adding <paramref name="basePower" /> empty digits to the beginning
            of the number, i.e. shifting left by <paramref name="basePower" /> BASE-based digits.
            
            Is quick for any digit base.
            </summary>
      <param name="basePower">The base power to multiply by.</param>
      <returns>The current number multiplied by X * BASE ^ <paramref name="basePower" /></returns>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.BaseDivide(System.Int32)">
      <summary>
            If the digits base for the current number X is BASE,
            the method would return return 
            X / BASE ^ <paramref name="basePower" />.
            
            Equivalent to removing <paramref name="basePower" /> from the beginning
            of the number, i.e. shifting right by <paramref name="basePower" /> BASE-based digits.
            
            Is quick for any digit base.
            </summary>
      <param name="basePower">The base power to divide by.</param>
      <returns>The current number divided by BASE ^ <paramref name="basePower" /></returns>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.DecimalMultiply(System.Int32)">
      <summary>
            Shifts the current number to the left by the specified amount of decimal digits.
            Equivalent to multiplication by 10^tenPower.
            
            WARNING! IS quick only if the base of this number is a power of ten.
            
            Otherwise, a LongInt(B) of current base will be first created as a result
            of integer powering 10^tenPower, and further multiplication shall be performed.
            
            Implicitly calls the method <see cref="M:whiteMath.ArithmeticLong.LongInt`1.BaseRootMultiply(System.Int32,System.Int32,System.Int32)" /> with parameters
            rootValue = 10, rootDegree = log10(BASE), multiplyByRootPower = <paramref name="tenPower" />.
            </summary>
      <param name="tenPower">The amount of decimal digits to shift by.</param>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.DecimalDivide(System.Int32)">
      <summary>
            Shifts the current number to the right by the specified amount of decimal digits.
            Equivalent to division by 10^tenPower.
            
            IS quick only if the base of current number's digits is a power of ten.
            Otherwise, simple powering and multiplication operations shall be performed.
            
            Implicitly calls the method <see cref="M:whiteMath.ArithmeticLong.LongInt`1.BaseRootDivide(System.Int32,System.Int32,System.Int32)" /> with parameters
            rootValue = 10, rootDegree = log10(BASE), divideByRootPower = <paramref name="tenPower" />.
            </summary>
      <param name="tenPower">The amount of decimal digits to shift by.</param>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.op_LeftShift(whiteMath.ArithmeticLong.LongInt{`0},System.Int32)">
      <summary>
            Shifts the specified LongInt to the left by <paramref name="howMuch" /> binary digits.
            Equivalent to multiplication by 2^<paramref name="howMuch" />.
            
            IS quick only if the digits base for the current number is a power of two, e.g. 256.
            
            Otherwise, simple multiplication will be performed.
            </summary>
      <param name="one">The number to be multiplied.</param>
      <param name="howMuch">The amount of binary digits to shift by.</param>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.op_RightShift(whiteMath.ArithmeticLong.LongInt{`0},System.Int32)">
      <summary>
            Shifts the specified LongInt to the right by <paramref name="howMuch" /> binary digits.
            Equivalent to integral division by 2^<paramref name="howMuch" />.
            
            IS quick only if the digits base for the current number is an exact power of two, e.g. 256.
            
            Otherwise, simple division will be performed.
            </summary>
      <param name="one">The number to be divided.</param>
      <param name="howMuch">The amount of binary digits to shift by.</param>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.getDigitFormatter">
      <summary>
            Gets the digit formatter for ToString() output.
            </summary>
      <returns />
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.DealWithZeroes">
      <summary>
            Cuts the non-significant leading zeroes in the number.
            Also checks whether the result is zero value and makes it positive.
            </summary>
      <returns>
            True if the number is actually zero.
            </returns>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.AbsMore(whiteMath.ArithmeticLong.LongInt{`0},whiteMath.ArithmeticLong.LongInt{`0},whiteMath.ArithmeticLong.LongInt{`0}@,whiteMath.ArithmeticLong.LongInt{`0}@)">
      <summary>
            Chooses the bigger and the smaller absolute number of two.
            </summary>
      <param name="one" />
      <param name="two" />
      <param name="bigger" />
      <param name="smaller" />
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.Clone">
      <summary>
            Creates a copy of current LongInt number.
            </summary>
      <returns>A deep copy of current LongInt number.</returns>
      <ensures inheritedFrom="M:System.ICloneable.Clone" inheritedFromTypeName="ICloneable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.Equals(System.Object)">
      <summary>
            Checks if two LongInt objects store the same numeric value.
            </summary>
      <param name="obj">The object to compare to.</param>
      <returns>True if true, false if false...</returns>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.GetHashCode">
      <summary>
            Gets the hashing code for the current number.
            Works very stupidly at the moment, wait for better life.
            </summary>
      <returns />
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.baseConvert``1">
      <summary>
            Converts the current LongInt number from one base
            to another using the IBase interface.
            
            The resulting LongInt will be numerically equal to the current, but
            have different digits numeric base.
            </summary>
      <typeparam name="B2">The IBase interface specifying the type of outcoming LongInt(<typeparamref name="B2" />)</typeparam>
      <returns>A LongInt(<typeparamref name="B2" />) number with digits of base specified by <typeparamref name="B2" />'s getBase() value.</returns>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.ToString">
      <summary>
            Returns the string representation of the current LongInt number.
            If the base of this number is not a power of ten, the process may become slow
            as the convertation shall be performed.
            </summary>
      <returns>The string representation of the current LongInt number.</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.TryParse(System.String,whiteMath.ArithmeticLong.LongInt{`0}@)">
      <summary>
            Tries to parse the specified string value into a LongInt number.
            If successful, returns true.
            False otherwise. In the latter case, the result is set to NULL.
            </summary>
      <param name="value" />
      <param name="result" />
      <returns />
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.Parse(System.String)">
      <summary>
            Parses the specified string value into a LongInt number.
            If unsuccessful, a FormatException is thrown.
            
            If the numeric base of the IBase class for this long integer
            is not a power of ten, the value will be first parsed to
            LongInt(Bases.B_10k) and then converted to the current base,
            thus the process may become slower.
            </summary>
      <param name="value">A string containing a number to convert</param>
      <returns>The long integer value containing all of the digits specified.</returns>
      <requires description="value" exception="T:System.ArgumentNullException" csharp="value != null" vb="value &lt;&gt; Nothing">value != null</requires>
      <exception cref="T:System.ArgumentNullException">value == null</exception>
    </member>
    <member name="P:whiteMath.ArithmeticLong.LongInt`1.LengthInDecimalPlaces">
      <summary>
            Returns the length of the current number in decimal digits.
            Works ONLY for numbers whose digits base is an integer power of ten.
            </summary>
    </member>
    <member name="P:whiteMath.ArithmeticLong.LongInt`1.LengthInBinaryPlaces">
      <summary>
            Returns the length of the current number in binary digits.
            Works ONLY for numbers whose digits base is an integer power of two.
            </summary>
    </member>
    <member name="P:whiteMath.ArithmeticLong.LongInt`1.PlacesInADigit_Decimal">
      <summary>
            Returns the amount of decimal places contained in a single numeric digit of this number.
            Works only if the base of the number is an integer power of ten, otherwise,
            a NotSupportedException shall be thrown.
            </summary>
    </member>
    <member name="P:whiteMath.ArithmeticLong.LongInt`1.PlacesInADigit_Binary">
      <summary>
            Returns the amount of binary places contained in a single numeric digit of this number.
            Works only if the base of the number is an integer power of two, otherwise,
            a NotSupportedException shall be thrown.
            </summary>
    </member>
    <member name="P:whiteMath.ArithmeticLong.LongInt`1.Length">
      <summary>
            Returns the length of the current number in BASE-based digits.
            <see cref="F:whiteMath.ArithmeticLong.LongInt`1.BASE" /></summary>
    </member>
    <member name="P:whiteMath.ArithmeticLong.LongInt`1.Digits">
      <summary>
            Returns the digits list for the current number.
            </summary>
      <getter>
        <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
        <ensures csharp="for all x in result x &gt;= 0" vb="for all x in result x &gt;= 0">for all x in result x &gt;= 0</ensures>
      </getter>
      <setter>
        <requires csharp="value != null" vb="value &lt;&gt; Nothing">value != null</requires>
        <requires csharp="for all x in value x &gt;= 0" vb="for all x in value x &gt;= 0">for all x in value x &gt;= 0</requires>
      </setter>
    </member>
    <member name="P:whiteMath.ArithmeticLong.LongInt`1.Negative">
      <summary>
            Returns true if the current number is negative
            </summary>
    </member>
    <member name="P:whiteMath.ArithmeticLong.LongInt`1.IsEven">
      <summary>
            Gets a flag signalizing whether the current number
            is even, i.e. has a zero remainder after division by 2.
            </summary>
    </member>
    <member name="P:whiteMath.ArithmeticLong.LongInt`1.Item(System.Int32)">
      <summary>
            Returns the LongInt digit at specified position.
            Lower indexes correspond to less significant digits (i.e. the order is big endian), so
            with <c>i</c>'th digit corresponding to <c>BASE^i</c>.
            </summary>
      <param name="digitIndex">The index of the desired number.</param>
      <returns>The digit on the zero-based position <paramref name="digitIndex" />.</returns>
    </member>
    <member name="T:whiteMath.ArithmeticLong.LongInt`1.NTTTransformInfo">
      <summary>
            This struct contains the info used the information about the transform.
            </summary>
    </member>
    <member name="P:whiteMath.ArithmeticLong.LongInt`1.NTTTransformInfo.numericBase">
      <summary>
            Gets the numeric base of transformed vectors.
            </summary>
    </member>
    <member name="P:whiteMath.ArithmeticLong.LongInt`1.NTTTransformInfo.transformLength">
      <summary>
            Gets the length of vectors transformed.
            </summary>
    </member>
    <member name="T:whiteMath.ArithmeticLong.LongInt`1.NTTFiniteFieldInfo">
      <summary>
            This class contains information associated with the finite field used to
            multiply two numbers using NTT.
            </summary>
    </member>
    <member name="P:whiteMath.ArithmeticLong.LongInt`1.NTTFiniteFieldInfo.primeModulus">
      <summary>
            Represents the prime modulus used in the process of multiplication.
            </summary>
    </member>
    <member name="P:whiteMath.ArithmeticLong.LongInt`1.NTTFiniteFieldInfo.rootOfUnity">
      <summary>
            Represents the primitive root of unity used in the process of multiplication.
            </summary>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.Helper.PrepareNTTMultiplication">
      <summary>
            This method prepares the Helper class for fast NTT multiplication
            by loading finite field information from the resource file.
            
            This can take a few seconds of time, so consider calling this method in advance.
            </summary>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.Helper.getFiniteFieldInfo(System.Int32,System.Int32)">
      <summary>
            Returns the "minimal" finite field info for a given pair of values for BASE and transform length.
            </summary>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.Helper.MultiplyNTT(whiteMath.ArithmeticLong.LongInt{`0},whiteMath.ArithmeticLong.LongInt{`0})">
      <summary>
            Computes the product of two long integer numbers using NTT in finite fields.
            
            The numbers are not necessarily required to be of two's power long;
            this algorithm performs all needed operations automatically.
            </summary>
      <param name="one" />
      <param name="two" />
      <requires description="one" exception="T:System.ArgumentNullException" csharp="one != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null" vb="one &lt;&gt; ((whiteMath.ArithmeticLong.LongInt(Of B))Nothing) ">one != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">one == null</exception>
      <requires description="two" exception="T:System.ArgumentNullException" csharp="two != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null" vb="two &lt;&gt; ((whiteMath.ArithmeticLong.LongInt(Of B))Nothing) ">two != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">two == null</exception>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.Helper.MultiplyNTT(System.Int32,System.Collections.Generic.IList{System.Int64},System.Collections.Generic.IList{System.Int32},System.Collections.Generic.IList{System.Int32})">
      <summary>
            Computes the product of two long integer numbers using NTT in finite fields.
            
            The numbers are not necessarily required to be of two's power long;
            this algorithm performs all needed operations automatically.
            </summary>
      <param name="result" />
      <param name="one" />
      <param name="two" />
      <requires description="result" exception="T:System.ArgumentNullException" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</requires>
      <exception cref="T:System.ArgumentNullException">result == null</exception>
      <requires description="one" exception="T:System.ArgumentNullException" csharp="one != null" vb="one &lt;&gt; Nothing">one != null</requires>
      <exception cref="T:System.ArgumentNullException">one == null</exception>
      <requires description="two" exception="T:System.ArgumentNullException" csharp="two != null" vb="two &lt;&gt; Nothing">two != null</requires>
      <exception cref="T:System.ArgumentNullException">two == null</exception>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.Helper.Recursive_NTT(System.Collections.Generic.IList{System.Numerics.BigInteger},whiteMath.ArithmeticLong.LongInt{`0}.NTTFiniteFieldInfo)">
      <summary>
            FFT
            </summary>
      <param name="coefficients" />
      <returns />
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.Helper.Recursive_NTT_Inverse(System.Collections.Generic.IList{System.Numerics.BigInteger},whiteMath.ArithmeticLong.LongInt{`0}.NTTFiniteFieldInfo)">
      <summary>
            BACK FFT
            </summary>
      <param name="coefficients" />
      <returns />
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.Helper.Recursive_NTT_Skeleton(System.Collections.Generic.IList{System.Numerics.BigInteger},System.Collections.Generic.IList{System.Numerics.BigInteger},whiteMath.ArithmeticLong.LongInt{`0}.NTTFiniteFieldInfo,System.Int32,System.Int32)">
      <summary>
            Calculates the result of the recursive Number Theoretic Transform.
            </summary>
      <param name="coefficients" />
      <returns />
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.Helper.rootsOfUnityHalfGalois(whiteMath.ArithmeticLong.LongInt{`0}.NTTFiniteFieldInfo,System.Int32,System.Boolean)">
      <summary>
            Returns the first half of the [rootDegree]th roots of unity series in the BigInteger field.
            Used in the recursive FFT algorithm in LongInt.Helper class.
            
            Root degree should be an exact power of two.
            </summary>
      <param name="rootDegree" />
      <returns />
      <requires description="The degree of the root should be a positive power of two." exception="T:System.ArgumentOutOfRangeException" csharp="rootDegree &gt; 0" vb="rootDegree &gt; 0">rootDegree &gt; 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">rootDegree &lt;= 0</exception>
      <ensures csharp="for all x in result PowerIntegerModular(x, (ulong)(long)rootDegree, finiteFieldInfo.primeModulus) == (long)1" vb="for all x in result PowerIntegerModular(x, ((ULong )((Long )rootDegree)), finiteFieldInfo.primeModulus) = ((Long )1) ">for all x in result whiteMath.WhiteMath&lt;System.Numerics.BigInteger, whiteMath.CalcBigInteger&gt;.PowerIntegerModular(x, (ulong)(long)rootDegree, finiteFieldInfo.primeModulus) == (long)1</ensures>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.Helper.componentMultiplyGalois(System.Collections.Generic.IList{System.Numerics.BigInteger},System.Collections.Generic.IList{System.Numerics.BigInteger},whiteMath.ArithmeticLong.LongInt{`0}.NTTFiniteFieldInfo)">
      <summary>
            Performs the component-to-component multiplication of two convolution vectors in the finite field.
            </summary>
      <param name="one" />
      <param name="two" />
      <returns />
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.Helper.MultiplyFFTComplex(System.Int32,System.Collections.Generic.IList{System.Int64},System.Collections.Generic.IList{System.Int32},System.Collections.Generic.IList{System.Int32},System.Double@,System.Double@,System.Int64@)">
      <summary>
            Computes the product of two long integer numbers using Complex-field FFT algorithm.
            Precision is not guaranteed on very large numbers.
            
            The numbers are not necessarily required to be of two's power long;
            this algorithm performs all needed operations automatically.
            </summary>
      <param name="result">The result of FFT multiplication.</param>
      <param name="one">The first operand.</param>
      <param name="two">The second operand.</param>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.Helper.Recursive_FFT(System.Collections.Generic.IList{whiteMath.Complex})">
      <summary>
            Computes the Fast Fourier Transform of the <paramref name="coefficients" />
            vector.
            </summary>
      <param name="coefficients">The vector of coefficients of the polynomial, length=2^k.</param>
      <returns>A vector containing the discrete fourier transform.</returns>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.Helper.Recursive_FFT_Back(System.Collections.Generic.IList{whiteMath.Complex})">
      <summary>
            Computes the inverse Fast Fourier Transform of the <paramref name="coefficients" />
            vector.
            </summary>
      <param name="coefficients">The vector of coefficients of the polynomial, length=2^k.</param>
      <returns>A vector containing the inverse discrete fourier transform.</returns>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.Helper.Recursive_FFT_Skeleton(System.Collections.Generic.IList{whiteMath.Complex},System.Collections.Generic.IList{whiteMath.Complex},System.Int32,System.Int32)">
      <summary>
            Calculates the result of recursive Fast Fourier Transform.
            </summary>
      <param name="coefficients" />
      <returns />
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.Helper.rootsOfUnityHalf(System.Int32,System.Boolean)">
      <summary>
            Returns the upper half of the [rootDegree]th roots of unity series in the complex field.
            Used in the recursive FFT algorithm in LongInt.Helper class.
            
            Root degree should be an exact power of two.
            </summary>
      <param name="rootDegree" />
      <returns />
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.Helper.componentMultiply(System.Collections.Generic.IList{whiteMath.Complex},System.Collections.Generic.IList{whiteMath.Complex})">
      <summary>
            Performs the component-to-component multiplication of two convolution vectors.
            </summary>
      <param name="one" />
      <param name="two" />
      <returns />
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.Helper.performCarry(System.Int32,System.Collections.Generic.IList{System.Int64})">
      <summary>
            Performs the carrying after the FFT multiplication.
            </summary>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.Helper.MultiplyKaratsuba(whiteMath.ArithmeticLong.LongInt{`0},whiteMath.ArithmeticLong.LongInt{`0})">
      <summary>
            The Karatsuba multiplying algorithm.
            The lengths of numbers are completed to the nearest bigger power of 2.
            </summary>
      <param name="one" />
      <param name="two" />
      <returns />
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.Helper.SumPrivate(System.Int32,System.Collections.Generic.IList{System.Int32},System.Collections.Generic.IList{System.Int32},System.Int32,System.Collections.Generic.IList{System.Int32},System.Int32)">
      <summary>
            Складывает два числа с заданным смещением.
            </summary>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.Helper.Div(whiteMath.ArithmeticLong.LongInt{`0},whiteMath.ArithmeticLong.LongInt{`0})">
      <summary>
            Performs the integral division of two long integer numbers.
            </summary>
      <param name="one">The first LongInt number.</param>
      <param name="two">The second LongInt number.</param>
      <returns>The result of integral division without the remainder.</returns>
      <requires description="one" exception="T:System.ArgumentNullException" csharp="one != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null" vb="one &lt;&gt; ((whiteMath.ArithmeticLong.LongInt(Of B))Nothing) ">one != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">one == null</exception>
      <requires description="two" exception="T:System.ArgumentNullException" csharp="two != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null" vb="two &lt;&gt; ((whiteMath.ArithmeticLong.LongInt(Of B))Nothing) ">two != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">two == null</exception>
      <ensures csharp="for all x in result.Digits x &gt;= 0" vb="for all x in result.Digits x &gt;= 0">for all x in result.Digits x &gt;= 0</ensures>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.Helper.Div(whiteMath.ArithmeticLong.LongInt{`0},whiteMath.ArithmeticLong.LongInt{`0},whiteMath.ArithmeticLong.LongInt{`0}@)">
      <summary>
            Performs the division (with remainder) of two long integer numbers.
            </summary>
      <param name="one">The first LongInt number.</param>
      <param name="two">The second LongInt number.</param>
      <param name="remainder">The reference to contain the remainder.</param>
      <returns>The result of integral division.</returns>
      <requires description="one" exception="T:System.ArgumentNullException" csharp="one != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null" vb="one &lt;&gt; ((whiteMath.ArithmeticLong.LongInt(Of B))Nothing) ">one != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">one == null</exception>
      <requires description="two" exception="T:System.ArgumentNullException" csharp="two != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null" vb="two &lt;&gt; ((whiteMath.ArithmeticLong.LongInt(Of B))Nothing) ">two != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">two == null</exception>
      <ensures csharp="for all x in result.Digits x &gt;= 0" vb="for all x in result.Digits x &gt;= 0">for all x in result.Digits x &gt;= 0</ensures>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.Helper.MultiplySimple(whiteMath.ArithmeticLong.LongInt{`0},whiteMath.ArithmeticLong.LongInt{`0})">
      <summary>
            Performs a simple, square-complex multiplication of two LongInt numbers.
            </summary>
      <param name="one" />
      <param name="two" />
      <returns />
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.Helper.SquareRootInteger(whiteMath.ArithmeticLong.LongInt{`0})">
      <summary>
            Returns the integer part of the square root
            of the number.
            </summary>
      <remarks>This method works only for integer numeric types.</remarks>
      <param name="number">A strictly positive number for which the integer part of its square root is to be found.</param>
      <returns>The integer part of the square root of the <paramref name="number" />.</returns>
      <requires description="number" exception="T:System.ArgumentNullException" csharp="number != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null" vb="number &lt;&gt; ((whiteMath.ArithmeticLong.LongInt(Of B))Nothing) ">number != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">number == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="number &gt; op_Implicit((long)0)" vb="number &gt; operator ((Long )0) ">number &gt; whiteMath.ArithmeticLong.LongInt&lt;B&gt;.op_Implicit((long)0)</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">number &lt;= 0</exception>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.Helper.PowerIntegerModular``1(whiteMath.ArithmeticLong.LongInt{``0},System.UInt64,whiteMath.ArithmeticLong.LongInt{``0})">
      <summary>
            Performs fast modular exponentiation of a <c>LongInt</c> number modulo another number.
            </summary>
      <typeparam name="B">A type specifying the numeric base of <c>LongInt</c> digits.</typeparam>
      <param name="number">A <c>LongInt</c> number to be exponentiated.</param>
      <param name="power">A non-negative exponent.</param>
      <param name="modulus">The modulus of the operation.</param>
      <returns>The result of raising <paramref name="number" /> to power <paramref name="power" /> modulo <paramref name="modulus" />.</returns>
      <requires description="number" exception="T:System.ArgumentNullException" csharp="number != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null" vb="number &lt;&gt; ((whiteMath.ArithmeticLong.LongInt(Of B))Nothing) ">number != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">number == null</exception>
      <requires description="modulus" exception="T:System.ArgumentNullException" csharp="modulus != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null" vb="modulus &lt;&gt; ((whiteMath.ArithmeticLong.LongInt(Of B))Nothing) ">modulus != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">modulus == null</exception>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.Helper.PowerIntegerModular``2(whiteMath.ArithmeticLong.LongInt{``0},whiteMath.ArithmeticLong.LongInt{``1},whiteMath.ArithmeticLong.LongInt{``0})">
      <summary>
            Performs a fast exponentiation of a <c>LongInt</c> number modulo another number.
            </summary>
      <typeparam name="B">A type specifying the numeric base of exponentiated number.</typeparam>
      <typeparam name="T">A type specifying the numeric base of the exponent. It is very recommended that it be an integer power of two for performance reasons.</typeparam>
      <remarks>If <typeparamref name="T" /><c>IBase</c> type stands for a base that is an integer power of two, the algorithm will speed up significantly.</remarks>
      <param name="number">A <c>LongInt</c> number to be exponentiated.</param>
      <param name="power">A non-negative exponent.</param>
      <param name="modulus">The modulus of the operation.</param>
      <returns>The result of raising <paramref name="number" /> to power <paramref name="power" /> modulo <paramref name="modulus" />.</returns>
      <requires description="number" exception="T:System.ArgumentNullException" csharp="number != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null" vb="number &lt;&gt; ((whiteMath.ArithmeticLong.LongInt(Of B))Nothing) ">number != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">number == null</exception>
      <requires description="power" exception="T:System.ArgumentNullException" csharp="power != (whiteMath.ArithmeticLong.LongInt&lt;T&gt;)null" vb="power &lt;&gt; ((whiteMath.ArithmeticLong.LongInt(Of T))Nothing) ">power != (whiteMath.ArithmeticLong.LongInt&lt;T&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">power == null</exception>
      <requires description="modulus" exception="T:System.ArgumentNullException" csharp="modulus != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null" vb="modulus &lt;&gt; ((whiteMath.ArithmeticLong.LongInt(Of B))Nothing) ">modulus != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">modulus == null</exception>
      <requires description="The modulus should be a positive number." exception="T:System.ArgumentException" csharp="modulus &gt; op_Implicit((long)0)" vb="modulus &gt; operator ((Long )0) ">modulus &gt; whiteMath.ArithmeticLong.LongInt&lt;B&gt;.op_Implicit((long)0)</requires>
      <exception cref="T:System.ArgumentException">modulus &lt;= 0</exception>
      <requires description="The power should be a non-negativen number." exception="T:System.ArgumentException" csharp="!power.Negative" vb="Not power.Negative">!power.Negative</requires>
      <exception cref="T:System.ArgumentException">power.Negative</exception>
    </member>
    <member name="F:whiteMath.ArithmeticLong.LongInt`1.Helper_NTT_OLD.NTT_MAX_ROOT_OF_UNITY_DEGREE_EXPONENT">
      <summary>
            Represents the exponent of two related to the root of unity
            <see cref="F:whiteMath.ArithmeticLong.LongInt`1.Helper_NTT_OLD.NTT_MAX_ROOT_OF_UNITY_2_30" /></summary>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.Helper_NTT_OLD.MultiplyNTT(System.Int32,System.Collections.Generic.IList{System.Int64},System.Collections.Generic.IList{System.Int32},System.Collections.Generic.IList{System.Int32})">
      <summary>
            Computes the product of two long integer numbers using integer NTT in finite fields.
            
            The numbers are not necessarily required to be of two's power long;
            this algorithm performs all needed operations automatically.
            </summary>
      <param name="result" />
      <param name="one" />
      <param name="two" />
      <requires description="result" exception="T:System.ArgumentNullException" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</requires>
      <exception cref="T:System.ArgumentNullException">result == null</exception>
      <requires description="one" exception="T:System.ArgumentNullException" csharp="one != null" vb="one &lt;&gt; Nothing">one != null</requires>
      <exception cref="T:System.ArgumentNullException">one == null</exception>
      <requires description="two" exception="T:System.ArgumentNullException" csharp="two != null" vb="two &lt;&gt; Nothing">two != null</requires>
      <exception cref="T:System.ArgumentNullException">two == null</exception>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.Helper_NTT_OLD.Recursive_NTT(System.Collections.Generic.IList{System.Numerics.BigInteger})">
      <summary>
            FFT
            </summary>
      <param name="coefficients" />
      <returns />
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.Helper_NTT_OLD.Recursive_NTT_Inverse(System.Collections.Generic.IList{System.Numerics.BigInteger})">
      <summary>
            BACK FFT
            </summary>
      <param name="coefficients" />
      <returns />
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.Helper_NTT_OLD.Recursive_NTT_Skeleton(System.Collections.Generic.IList{System.Numerics.BigInteger},System.Collections.Generic.IList{System.Numerics.BigInteger},System.Int32,System.Int32)">
      <summary>
            Calculates the result of the recursive Number Theoretic Transform.
            </summary>
      <param name="coefficients" />
      <returns />
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.Helper_NTT_OLD.rootsOfUnityHalfGalois(System.Int32,System.Boolean)">
      <summary>
            Returns the first half of the [rootDegree]th roots of unity series in the BigInteger field.
            Used in the recursive FFT algorithm in LongInt.Helper class.
            
            Root degree should be an exact power of two.
            </summary>
      <param name="rootDegree" />
      <returns />
      <requires description="The degree of the root should be a positive power of two." exception="T:System.ArgumentOutOfRangeException" csharp="rootDegree &gt; 0" vb="rootDegree &gt; 0">rootDegree &gt; 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">rootDegree &lt;= 0</exception>
      <ensures csharp="for all x in result PowerIntegerModular(x, (ulong)(long)rootDegree, op_Implicit(70383776563201)) == (long)1" vb="for all x in result PowerIntegerModular(x, ((ULong )((Long )rootDegree)), operator 70383776563201) = ((Long )1) ">for all x in result whiteMath.WhiteMath&lt;System.Numerics.BigInteger, whiteMath.CalcBigInteger&gt;.PowerIntegerModular(x, (ulong)(long)rootDegree, System.Numerics.BigInteger.op_Implicit(70383776563201)) == (long)1</ensures>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.Helper_NTT_OLD.componentMultiplyGalois(System.Collections.Generic.IList{System.Numerics.BigInteger},System.Collections.Generic.IList{System.Numerics.BigInteger})">
      <summary>
            Performs the component-to-component multiplication of two convolution vectors in the finite field.
            </summary>
      <param name="one" />
      <param name="two" />
      <returns />
    </member>
    <member name="T:whiteMath.ICalc`1">
      <summary>
            The interface used for different numeric calculating purposes.
            Provides means for <c>Numeric&lt;T,C&gt;</c> generic abstraction layer class to overload
            operators, get default values etc.
            
            If a calculator for a type is made correctly, one can perform "arithmetic" operations
            with <c>Numeric&lt;T,C&gt;</c> objects using operator syntax as if they were primitive number types.
            </summary>
      <see cref="T:whiteMath.Numeric`2" />
    </member>
    <member name="M:whiteMath.ICalc`1.sum(`0,`0)">
      <summary>
            Returns the sum of two T numbers.
            </summary>
      <param name="one">The first operand.</param>
      <param name="two">The second operand.</param>
      <returns>The sum of the operands.</returns>
    </member>
    <member name="M:whiteMath.ICalc`1.dif(`0,`0)">
      <summary>
            Returns the difference of two numbers.
            </summary>
      <param name="one">The first operand.</param>
      <param name="two">The second operand.</param>
      <returns>The difference of the operands.</returns>
    </member>
    <member name="M:whiteMath.ICalc`1.mul(`0,`0)">
      <summary>
            Returns the multiplication product of two numbers.
            </summary>
      <param name="one">The first operand.</param>
      <param name="two">The second operand.</param>
      <returns>The multiplication product of the operands.</returns>
    </member>
    <member name="M:whiteMath.ICalc`1.div(`0,`0)">
      <summary>
            Returns the first number divided by the second number.
            </summary>
      <param name="one">The first operand.</param>
      <param name="two">The second operand.</param>
      <returns>The first operand divided by the second number.</returns>
    </member>
    <member name="M:whiteMath.ICalc`1.rem(`0,`0)">
      <summary>
            Returns the integral remainder of number division.
            </summary>
      <exception cref="T:whiteMath.NonIntegerTypeException">
            Calculators for fractional number types MUST
            throw a <c>NonIntegerTypeException</c> in the implementation of this method.
            </exception>
      <param name="one">The first operand.</param>
      <param name="two">The second operand.</param>
      <returns>The integral remainder of the division.</returns>
    </member>
    <member name="M:whiteMath.ICalc`1.isEven(`0)">
      <summary>
            Returns true if the integral number is even, that is,
            has no remainder of division by two.
            </summary>
      <exception cref="T:whiteMath.NonIntegerTypeException">
            This method MUST throw a <c>NonIntegerTypeException</c> if
            the <typeparamref name="T" /> type is fractional.
            </exception>
      <param name="one">The number to test.</param>
      <returns>True if the number is even,that is, has no remainder of division by two.</returns>
      <pure />
    </member>
    <member name="M:whiteMath.ICalc`1.negate(`0)">
      <summary>
            Negates the number so that:
            <list type="number"><item><c>a := -a</c></item><item><c>a + (-a) = 0.</c></item></list></summary>
      <param name="one">The number to negate.</param>
      <returns>The negated number.</returns>
    </member>
    <member name="M:whiteMath.ICalc`1.increment(`0)">
      <summary>
            Increments a number so that <c>a := a + fromInt(1)</c>.
            This method requires implementation
            because in many cases the increment operation can be implemented
            much more effective than by just adding <c>fromInt(1)</c> to the current value.
            </summary>
      <param name="one">The number to be incremented. Will be modified during the operation.</param>
      <returns>Current number incremented by one. For reference types, must return a reference to the same object!</returns>
    </member>
    <member name="M:whiteMath.ICalc`1.decrement(`0)">
      <summary>
            Decrements a number so that a := a - <c>fromInt(1)</c>.
            This method requires implementation because in many cases 
            the decrement operation can be implemented
            much more effective than by just substracting <c>fromInt(1)</c> from the current value.
            </summary>
      <param name="one">The number to be decremented. Will be modified during the operation.</param>
      <returns>Current number decremented by one. For reference types, must return a reference to the same object!</returns>
    </member>
    <member name="M:whiteMath.ICalc`1.intPart(`0)">
      <summary>
            Returns the integer part for the number.
            Should have the same sign as the number itself.
            </summary>
      <param name="one">The number whose integer part is to be evaluated.</param>
      <returns>The integer part of the number.</returns>
    </member>
    <member name="M:whiteMath.ICalc`1.mor(`0,`0)">
      <summary>
            Tests if the first number is more than the second.
            <para>
            (mor(one, two)) means that - but not equivalent to - : (!mor(two, one))
            </para></summary>
      <param name="one">The number to be tested if it's bigger than the second.</param>
      <param name="two">The number to be tested if it's smaller than the first.</param>
      <returns>True if <paramref name="one" /> is bigger than <paramref name="two" />, false otherwise.</returns>
      <pure />
    </member>
    <member name="M:whiteMath.ICalc`1.eqv(`0,`0)">
      <summary>
            Tests if the first number is equal to the second.
            Should be symmetric: a==b must be equivalent to b==a.
            </summary>
      <param name="one">The first operand.</param>
      <param name="two">THe second operand.</param>
      <returns>The flag indicating whether the two numbers are equal.</returns>
      <pure />
    </member>
    <member name="M:whiteMath.ICalc`1.isNaN(`0)">
      <summary>
            Tests whether the value is not a number (NaN) value.
            If the type does not support NaN's, this method should always return false.
            </summary>
      <param name="one">The value to be tested.</param>
      <returns>True if the value is NaN, false otherwise.</returns>
      <pure />
    </member>
    <member name="M:whiteMath.ICalc`1.isPosInf(`0)">
      <summary>
            Tests whether the value is a positive infinity.
            If the type does not support infinity values, this method should always return false.
            </summary>
      <param name="one">The value to be tested.</param>
      <returns>True if the value passed is a positive infinity, false otherwise.</returns>
    </member>
    <member name="M:whiteMath.ICalc`1.isNegInf(`0)">
      <summary>
            Tests whether the value is a negative infinity.
            If the type does not support infinity values, this method should always return false.
            </summary>
      <param name="one">The value to be tested.</param>
      <returns>True if the value passed is a negative infinity, false otherwise.</returns>
    </member>
    <member name="M:whiteMath.ICalc`1.getCopy(`0)">
      <summary>
            Returns an independent copy of the number.
            </summary>
      <param name="source">The number to be copied.</param>
      <returns>An independent copy of the number.</returns>
    </member>
    <member name="M:whiteMath.ICalc`1.fromInt(System.Int64)">
      <summary>
            Creates a number of <typeparamref name="T" /> type 
            from an integer value.
            </summary>
      <param name="equivalent">A long number whose <typeparamref name="T" /> equivalent is to be created.</param>
      <returns>
            A <typeparamref name="T" /> type equivalent of 
            the passed number.
            </returns>
    </member>
    <member name="M:whiteMath.ICalc`1.fromDouble(System.Double)">
      <summary>
            Creates a number of <typeparamref name="T" /> type
            from a double value.
            </summary>
      <exception cref="T:whiteMath.NonFractionalTypeException">
            This method MUST throw a <c>NonFractionalTypeException</c> 
            for any <typeparamref name="T" /> type that does not support lossless 
            conversions from double values, e.g. integer types.
            </exception>
      <param name="equivalent">A double number whose <typeparamref name="T" /> equivalent is to be created.</param>
      <returns>
            A <typeparamref name="T" /> type equivalent of
            the passed number.
            </returns>
    </member>
    <member name="M:whiteMath.ICalc`1.parse(System.String)">
      <summary>
            Creates a number of <typeparamref name="T" /> type
            from a string representing the resulting value.
            </summary>
      <exception cref="T:System.NotSupportedException">
            This kind of exception will be thrown in case when the calculator
            does not provide means of converting strings to <typeparamref name="T" /> values.
            </exception>
      <param name="str">The string to be parsed into a number.</param>
      <returns>A <typeparamref name="T" /> value represented by the incoming string object.</returns>
    </member>
    <member name="P:whiteMath.ICalc`1.zero">
      <summary>
            Gets the zero value of <typeparamref name="T" /> type.
            </summary>
    </member>
    <member name="P:whiteMath.ICalc`1.isIntegerCalculator">
      <summary>
            Gets the boolean flag which signalizes if the calculator was designed for handling 
            integer type operations. This information will be used by WhiteMath's arithmetic functions 
            to choose an optimal computation method.
            </summary>
    </member>
    <member name="T:whiteMath.CalcBigInteger">
      <summary>
            Standard calculator for integers.
            </summary>
    </member>
    <member name="T:whiteMath.ArithmeticLong.CalcLongInt`1">
      <summary>
            The default calculator for whiteMath long integer numbers.
            </summary>
    </member>
    <member name="T:whiteMath.CalcLong">
      <summary>
            Standard calculator for integers.
            </summary>
    </member>
    <member name="T:whiteMath.CalcULong">
      <summary>
            Standard calculator for integers.
            </summary>
    </member>
    <member name="T:whiteMath.CalcInt">
      <summary>
            Standard calculator for integers.
            </summary>
    </member>
    <member name="T:whiteMath.Combinatorics.Permutator`1">
      <summary>
            Represents a class that provides the capability
            to generate all permutations of elements of
            the specified list.
            </summary>
      <typeparam name="T">The types of elements in the list.</typeparam>
    </member>
    <member name="M:whiteMath.Combinatorics.Permutator`1.CreateNextPermutation">
      <summary>
            Creates the next permutation.
            </summary>
      <returns>True if the next permutation was available to create, false in case when all permutations have been generated.</returns>
    </member>
    <member name="M:whiteMath.Combinatorics.Permutator`1.Reset">
      <summary>
            Resets the <c>Permutator</c>
            so the cycle of generations may be done once again.
            </summary>
    </member>
    <member name="P:whiteMath.Combinatorics.Permutator`1.Item(System.Int32)">
      <summary>
            Returns the value at the specified index according
            to the current permutation.
            </summary>
      <exception cref="T:System.NotSupportedException">The setter will always throw as <c>Permutators</c> are read-only collections.</exception>
      <param name="index">The index of desired element.</param>
      <returns>The value at the specified index according to the current permutation.</returns>
      <getter>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.get_Item(System.Int32)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.get_Item(System.Int32)" inheritedFromTypeName="IList" csharp="index &lt; this.Count" vb="index &lt; Me.Count">index &lt; this.Count</requires>
      </getter>
      <setter>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.set_Item(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.set_Item(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &lt; this.Count" vb="index &lt; Me.Count">index &lt; this.Count</requires>
      </setter>
    </member>
    <member name="P:whiteMath.Combinatorics.Permutator`1.Sign">
      <summary>
            Returns the sign of the permutation.
            </summary>
    </member>
    <member name="T:whiteMath.Cryptography.OneTimePadBreaker">
      <summary>
            This class tries to break the one-time pad cipher using
            several distinct ASCII-encoded messages which were 
            encrypted with the same one-time pad key.
            
            The messages are expected to contain ONLY whitespace 0x20 and letter characters.
            </summary>
    </member>
    <member name="M:whiteMath.Cryptography.OneTimePadBreaker.addCipherText(System.String,System.Boolean)">
      <summary>
            Adds a ciphertext to the breaker and processes it,
            recovering as much information as possible about the current and the 
            previously passed messages, as well as about the key used
            to encrypt them.
            </summary>
      <param name="hexString" />
      <param name="bigEndian" />
      <requires description="hexString" exception="T:System.ArgumentNullException" csharp="hexString != null" vb="hexString &lt;&gt; Nothing">hexString != null</requires>
      <exception cref="T:System.ArgumentNullException">hexString == null</exception>
    </member>
    <member name="M:whiteMath.Cryptography.OneTimePadBreaker._xor(System.Byte[],System.Byte[])">
      <summary>
            Bitwise XORs the messages, perhaps of different length.
            </summary>
      <returns />
    </member>
    <member name="M:whiteMath.Cryptography.OneTimePadBreaker._processLastCipherText">
      <summary>
            Processes the lately added ciphertext.
            </summary>
    </member>
    <member name="T:whiteMath.Cryptography.PrimalityTests">
      <summary>
            This class provides methods for testing whether a number is prime.
            </summary>
    </member>
    <member name="M:whiteMath.Cryptography.PrimalityTests.IsPrime_Miller``1(whiteMath.ArithmeticLong.LongInt{``0})">
      <summary>
            Performs a Miller's deterministic prime test on a number.
            Goes over all numbers under the <c>floor(ln^2(<paramref name="num" />))</c> boundary.
            </summary>
      <typeparam name="B">
            A class specifying the digit base of <c>LongInt&lt;<typeparamref name="B" /></c> type.
            The base should be an integer power of two.
            </typeparam>
      <remarks>This test relies upon Riemann's Generalized Hypothesis, which still remains unproven. Use with caution.</remarks>
      <param name="num">A number, bigger than 1, to test for primality.</param>
      <returns>True if the number is prime according to the test, false otherwise.</returns>
      <requires description="The digit base of the number should be a strict power of two." exception="T:System.ArgumentException" csharp="BASE_is_power_of_two" vb="BASE_is_power_of_two">whiteMath.ArithmeticLong.LongInt&lt;B&gt;.BASE_is_power_of_two</requires>
      <exception cref="T:System.ArgumentException">!(LongInt&lt;B&gt;.BASE_is_power_of_two)</exception>
      <requires description="num" exception="T:System.ArgumentNullException" csharp="num != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null" vb="num &lt;&gt; ((whiteMath.ArithmeticLong.LongInt(Of B))Nothing) ">num != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">num == null</exception>
      <requires description="The tested number should be bigger than 1." exception="T:System.ArgumentOutOfRangeException" csharp="num &gt; op_Implicit((long)1)" vb="num &gt; operator ((Long )1) ">num &gt; whiteMath.ArithmeticLong.LongInt&lt;B&gt;.op_Implicit((long)1)</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">num &lt;= 1</exception>
    </member>
    <member name="M:whiteMath.Cryptography.PrimalityTests.IsPrime_WilsonTheorem``1(whiteMath.ArithmeticLong.LongInt{``0})">
      <summary>
            Performs a Wilson's deterministic prime test on a number
            and returns true if it is prime.
            Usually takes an enormous amount of time and is never used in practice.
            </summary>
      <typeparam name="B">A class specifying the digit base of <c>LongInt&lt;<typeparamref name="B" /></c> type.</typeparam>
      <param name="num">A number, bigger than 1, to test for primality.</param>
      <returns>
            True if the number is prime, false otherwise. Nevertheless, if the <paramref name="num" /> is big enough, you aren't to expect this method to return anything. 
            It will run until the Universe collapses.
            </returns>
      <requires description="num" exception="T:System.ArgumentNullException" csharp="num != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null" vb="num &lt;&gt; ((whiteMath.ArithmeticLong.LongInt(Of B))Nothing) ">num != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">num == null</exception>
      <requires description="The tested number should be bigger than 1." exception="T:System.ArgumentOutOfRangeException" csharp="num &gt; op_Implicit((long)1)" vb="num &gt; operator ((Long )1) ">num &gt; whiteMath.ArithmeticLong.LongInt&lt;B&gt;.op_Implicit((long)1)</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">num &lt;= 1</exception>
    </member>
    <member name="M:whiteMath.Cryptography.PrimalityTests.IsPrime_TrialDivision``1(whiteMath.ArithmeticLong.LongInt{``0})">
      <summary>
            Performs a deterministic primality test on a LongInt number.
            Usually takes an enormous amount of time and is never used in practice.
            </summary>
      <typeparam name="B">A class specifying the digit base of <c>LongInt&lt;<typeparamref name="B" /></c> type.</typeparam>
      <param name="num">A number, bigger than 1, to test for primality.</param>
      <returns>
            True if the number is prime, false otherwise. Nevertheless, if the <paramref name="num" /> is big enough, you aren't to expect this method to return anything. 
            It will run until the Universe collapses.
            </returns>
      <requires description="num" exception="T:System.ArgumentNullException" csharp="num != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null" vb="num &lt;&gt; ((whiteMath.ArithmeticLong.LongInt(Of B))Nothing) ">num != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">num == null</exception>
      <requires description="The tested number should be bigger than 1." exception="T:System.ArgumentOutOfRangeException" csharp="num &gt; op_Implicit((long)1)" vb="num &gt; operator ((Long )1) ">num &gt; whiteMath.ArithmeticLong.LongInt&lt;B&gt;.op_Implicit((long)1)</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">num &lt;= 1</exception>
    </member>
    <member name="M:whiteMath.Cryptography.PrimalityTests.IsPrime_SolovayStrassen``1(whiteMath.ArithmeticLong.LongInt{``0},whiteMath.Randoms.IRandomBounded{whiteMath.ArithmeticLong.LongInt{``0}},System.Int64)">
      <summary>
            Performs a Solovay-Strassen stochastic primality test of a long integer number
            and returns the probability that the number is composite. 
            </summary>
      <typeparam name="B">A class specifying the digit base of <c>LongInt&lt;<typeparamref name="B" /></c> type.</typeparam>
      <param name="num">A number, bigger than 1, to test for primality.</param>
      <param name="gen">
            A bounded <c>LongInt&lt;<typeparamref name="B" /></c> random generator. 
            For probability estimations to be correct, this generator should guarantee uniform distribution 
            for any given interval.
            </param>
      <param name="rounds">
            A positive number of testing rounds. Recommended to be more than <c>log2(<paramref name="num" />)</c>.
            </param>
      <returns>
            The probability that the <paramref name="num" /> is composite. 
            Equals to <c>2^(-<paramref name="rounds" />)</c>, which is
            worse than for <see cref="M:whiteMath.Cryptography.PrimalityTests.IsPrime_MillerRabin``1(whiteMath.ArithmeticLong.LongInt{``0},whiteMath.Randoms.IRandomBounded{whiteMath.ArithmeticLong.LongInt{``0}},System.Int64)" />.
            </returns>
      <requires description="num" exception="T:System.ArgumentNullException" csharp="num != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null" vb="num &lt;&gt; ((whiteMath.ArithmeticLong.LongInt(Of B))Nothing) ">num != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">num == null</exception>
      <requires description="gen" exception="T:System.ArgumentNullException" csharp="gen != null" vb="gen &lt;&gt; Nothing">gen != null</requires>
      <exception cref="T:System.ArgumentNullException">gen == null</exception>
      <requires description="The tested number should be bigger than 2." exception="T:System.ArgumentOutOfRangeException" csharp="num &gt; op_Implicit((long)1)" vb="num &gt; operator ((Long )1) ">num &gt; whiteMath.ArithmeticLong.LongInt&lt;B&gt;.op_Implicit((long)1)</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">num &lt;= 1</exception>
      <requires description="The number of rounds should be positive." exception="T:System.ArgumentOutOfRangeException" csharp="rounds &gt; (long)0" vb="rounds &gt; ((Long )0)">rounds &gt; (long)0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">rounds &lt;= 0</exception>
    </member>
    <member name="M:whiteMath.Cryptography.PrimalityTests.IsPrime_Fermat``1(whiteMath.ArithmeticLong.LongInt{``0},whiteMath.Randoms.IRandomBounded{whiteMath.ArithmeticLong.LongInt{``0}},System.Int64)">
      <summary>
            Performs a Fermat stochastic primality test of a long integer number.
            </summary>
      <typeparam name="B">A class specifying the digit base of <c>LongInt&lt;<typeparamref name="B" /></c> type.</typeparam>
      <param name="num">A number to test for primality. Should be more than 1.</param>
      <param name="gen">
            A bounded <c>LongInt&lt;<typeparamref name="B" /></c> random generator. 
            For probability estimations to be correct, this generator should guarantee uniform distribution 
            for any given interval.
            </param>
      <param name="rounds">A positive number of testing rounds.</param>
      <returns>If this method returns false, the number is guaranteed to be composite. Otherwise the number is probably prime, but it's not always the case.</returns>
      <requires description="num" exception="T:System.ArgumentNullException" csharp="num != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null" vb="num &lt;&gt; ((whiteMath.ArithmeticLong.LongInt(Of B))Nothing) ">num != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">num == null</exception>
      <requires description="gen" exception="T:System.ArgumentNullException" csharp="gen != null" vb="gen &lt;&gt; Nothing">gen != null</requires>
      <exception cref="T:System.ArgumentNullException">gen == null</exception>
      <requires description="The number to test should be bigger than 1." exception="T:System.ArgumentOutOfRangeException" csharp="num &gt; op_Implicit((long)1)" vb="num &gt; operator ((Long )1) ">num &gt; whiteMath.ArithmeticLong.LongInt&lt;B&gt;.op_Implicit((long)1)</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">num &lt;= 1</exception>
      <requires description="The number of rounds should be positive." exception="T:System.ArgumentOutOfRangeException" csharp="rounds &gt; (long)0" vb="rounds &gt; ((Long )0)">rounds &gt; (long)0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">rounds &lt;= 0</exception>
    </member>
    <member name="M:whiteMath.Cryptography.PrimalityTests.IsPrime_MillerRabin``1(whiteMath.ArithmeticLong.LongInt{``0},whiteMath.Randoms.IRandomBounded{whiteMath.ArithmeticLong.LongInt{``0}},System.Int64)">
      <summary>
            Performs a Miller-Rabin stochastic primality test of a long integer number
            and returns the probability that the number is composite. 
            </summary>
      <typeparam name="B">A class specifying the digit base of <c>LongInt&lt;<typeparamref name="B" /></c> type.</typeparam>
      <param name="num">The number to test for primality. Should be more than 1.</param>
      <param name="gen">
            A bounded <c>LongInt&lt;<typeparamref name="B" /></c> random generator. 
            For probability estimations to be correct, this generator should guarantee uniform distribution 
            for any given interval.
            </param>
      <param name="rounds">
            A positive number of testing rounds. Recommended to be more than <c>log2(<paramref name="num" />)</c>.
            </param>
      <returns>The probability that the <paramref name="num" /> is composite.</returns>
      <requires description="num" exception="T:System.ArgumentNullException" csharp="num != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null" vb="num &lt;&gt; ((whiteMath.ArithmeticLong.LongInt(Of B))Nothing) ">num != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">num == null</exception>
      <requires description="gen" exception="T:System.ArgumentNullException" csharp="gen != null" vb="gen &lt;&gt; Nothing">gen != null</requires>
      <exception cref="T:System.ArgumentNullException">gen == null</exception>
      <requires description="The number to test should be bigger than 1." exception="T:System.ArgumentOutOfRangeException" csharp="num &gt; op_Implicit((long)1)" vb="num &gt; operator ((Long )1) ">num &gt; whiteMath.ArithmeticLong.LongInt&lt;B&gt;.op_Implicit((long)1)</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">num &lt;= 1</exception>
      <requires description="The number of rounds should be positive." exception="T:System.ArgumentOutOfRangeException" csharp="rounds &gt; (long)0" vb="rounds &gt; ((Long )0)">rounds &gt; (long)0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">rounds &lt;= 0</exception>
    </member>
    <member name="M:whiteMath.Cryptography.PrimalityTests.___millerRabinFactorize``1(whiteMath.ArithmeticLong.LongInt{``0},whiteMath.ArithmeticLong.LongInt{``0}@,System.Int64@)">
      <summary>
            Раскладывает четное число в произведение 2^s * t.
            </summary>
      <requires csharp="number.IsEven" vb="number.IsEven">number.IsEven</requires>
    </member>
    <member name="M:whiteMath.Cryptography.PrimalityTests.___millerRabinIsPrimeWitness``1(whiteMath.ArithmeticLong.LongInt{``0},whiteMath.ArithmeticLong.LongInt{``0},whiteMath.ArithmeticLong.LongInt{``0},System.Int64)">
      <summary>
            Возвращает true, если число - свидетель простоты.
            Если false, то тестируемое число - составное.
            </summary>
    </member>
    <member name="T:whiteMath.Cryptography.PrimeGeneration">
      <summary>
            This class provides methods for generating prime numbers.
            </summary>
    </member>
    <member name="M:whiteMath.Cryptography.PrimeGeneration.EratospheneSieve(System.Int32)">
      <summary>
            Returns a list of all prime numbers which are less than or equal to the specified integer number.
            </summary>
      <param name="num">An upper bound of prime numbers found. Should be positive.</param>
      <returns>A list of all prime numbers which are less than or equal to <paramref name="num" />.</returns>
      <requires description="The upper bound of generated numbers should be positive." exception="T:System.ArgumentOutOfRangeException" csharp="num &gt; 0" vb="num &gt; 0">num &gt; 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">num &lt;= 0</exception>
    </member>
    <member name="T:whiteMath.Cryptography.RSA">
      <summary>
            This class provides methods for encryption and decryption of arbitrary data using
            RSA algorithm.
            </summary>
    </member>
    <member name="M:whiteMath.Cryptography.RSA.ToLongInt``1(System.Collections.Generic.IEnumerable{System.Byte})">
      <summary>
            Converts a sequence of bytes into a <c>LongInt</c> number, e.g. to encrypt 
            it using RSA algorithm.
            </summary>
      <typeparam name="B">The type specifying the digit base of the desired <c>LongInt</c>. Recommended to be <c>B_256</c> for quicker conversion.</typeparam>
      <param name="sequence">A sequence of bytes to be represented as a <c>LongInt</c>.</param>
      <returns>A <c>LongInt&lt;B&gt;</c> number which, being converted to base 256, would contain the same numeric values and in the same order as <paramref name="sequence" />.</returns>
      <requires description="sequence" exception="T:System.ArgumentNullException" csharp="sequence != null" vb="sequence &lt;&gt; Nothing">sequence != null</requires>
      <exception cref="T:System.ArgumentNullException">sequence == null</exception>
      <requires description="The sequence should contain at least one element." exception="T:System.ArgumentException" csharp="Count&lt;byte&gt;(sequence) &gt; 0" vb="Count(sequence) &gt; 0">System.Linq.Enumerable.Count&lt;byte&gt;(sequence) &gt; 0</requires>
      <exception cref="T:System.ArgumentException">!(sequence.Count() &gt; 0)</exception>
    </member>
    <member name="M:whiteMath.Cryptography.RSA.ToByteArray``1(whiteMath.ArithmeticLong.LongInt{``0})">
      <summary>
            Converts a <c>LongInt</c> number into a sequence of bytes.
            </summary>
      <typeparam name="B">The type specifying the digit base of the incoming <c>LongInt&lt;B&gt;</c>. Recommended to be <c>B_256</c> for quicker conversion.</typeparam>
      <param name="number">The incoming number.</param>
      <returns>The byte array containing the same numeric values and in the same order as <paramref name="number" /> converted to base 256.</returns>
      <requires description="number" exception="T:System.ArgumentNullException" csharp="number != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null" vb="number &lt;&gt; ((whiteMath.ArithmeticLong.LongInt(Of B))Nothing) ">number != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">number == null</exception>
      <requires description="The number should not be negative." exception="T:System.ArgumentException" csharp="!number.Negative" vb="Not number.Negative">!number.Negative</requires>
      <exception cref="T:System.ArgumentException">number.Negative</exception>
    </member>
    <member name="M:whiteMath.Cryptography.RSA.__isPrimeOptimized``1(whiteMath.ArithmeticLong.LongInt{``0})">
      <summary>
            Hidden method - tries the first 100 primes to test divisibility.
            If not divisible - proceeds with Miller-Rabin.
            </summary>
    </member>
    <member name="M:whiteMath.Cryptography.RSA.GetKey``1(System.Int32,whiteMath.Randoms.IRandomBounded{whiteMath.ArithmeticLong.LongInt{``0}},System.Func{whiteMath.ArithmeticLong.LongInt{``0},System.Boolean})">
      <summary>
            Creates a pair of two primes which, being multiplied one by another,
            produce a public key of desired length for the RSA algorithm.
            </summary>
      <typeparam name="B">An implementation of <c>IBase</c> interface which specifies the digit base of <c>LongInt&lt;<typeparamref name="B" />&gt;</c> numbers.</typeparam>
      <param name="digits">The desired number of digits in the public key.</param>
      <param name="randomGenerator">A random generator for long integer numbers.</param>
      <param name="primalityTest" />
      <returns />
      <requires description="The amount of digits in the key should be more than 1." exception="T:System.ArgumentOutOfRangeException" csharp="digits &gt; 1" vb="digits &gt; 1">digits &gt; 1</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">digits &lt;= 1</exception>
    </member>
    <member name="M:whiteMath.Cryptography.RSA.GetSecretExponent``1(whiteMath.General.Point{whiteMath.ArithmeticLong.LongInt{``0}},whiteMath.ArithmeticLong.LongInt{``0})">
      <summary>
            Calculates a public exponent on the basis of
            a pair of primes which form the RSA secret key and
            the number chosen as public exponent.
            </summary>
      <typeparam name="B">An implementation of <c>IBase</c> interface which specifies the digit base of <c>LongInt&lt;<typeparamref name="B" />&gt;</c> numbers.</typeparam>
      <param name="secretKey">A pair of primes which form the RSA secret key.</param>
      <returns>The secret exponent of the RSA algorithm.</returns>
      <requires description="publicExponent" exception="T:System.ArgumentNullException" csharp="publicExponent != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null" vb="publicExponent &lt;&gt; ((whiteMath.ArithmeticLong.LongInt(Of B))Nothing) ">publicExponent != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">publicExponent == null</exception>
      <requires description="secretKey.X" exception="T:System.ArgumentNullException" csharp="secretKey.X != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null" vb="secretKey.X &lt;&gt; ((whiteMath.ArithmeticLong.LongInt(Of B))Nothing) ">secretKey.X != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">secretKey.X == null</exception>
      <requires description="secretKey.Y" exception="T:System.ArgumentNullException" csharp="secretKey.Y != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null" vb="secretKey.Y &lt;&gt; ((whiteMath.ArithmeticLong.LongInt(Of B))Nothing) ">secretKey.Y != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">secretKey.Y == null</exception>
    </member>
    <member name="M:whiteMath.Cryptography.RSA.Decrypt``2(whiteMath.ArithmeticLong.LongInt{``0},whiteMath.ArithmeticLong.LongInt{``0},whiteMath.ArithmeticLong.LongInt{``1})">
      <summary>
            Decrypts a long integer number using the RSA algorithm.
            </summary>
      <typeparam name="B">An implementation of <c>IBase</c> interface which specifies the digit base of <c>LongInt&lt;<typeparamref name="B" />&gt;</c> numbers.</typeparam>
      <typeparam name="E">An implementation of <see cref="T:whiteMath.ArithmeticLong.IBase" /> interface which specifies the digit base of the public exponent. Should be a power of 2 for faster encryption.</typeparam>
      <param name="number">The number to encrypt.</param>
      <param name="publicKey">The public key of the RSA algorithm. Should be a product of two prime numbers.</param>
      <param name="secretExponent">The secret exponent of the RSA algorithm.</param>
      <remarks>If <paramref name="secretExponent" /> has digit base which is a power of 2, the decryption process will go faster.</remarks>
      <returns>The result of RSA decryption.</returns>
      <requires description="number" exception="T:System.ArgumentNullException" csharp="number != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null" vb="number &lt;&gt; ((whiteMath.ArithmeticLong.LongInt(Of B))Nothing) ">number != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">number == null</exception>
      <requires description="publicKey" exception="T:System.ArgumentNullException" csharp="publicKey != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null" vb="publicKey &lt;&gt; ((whiteMath.ArithmeticLong.LongInt(Of B))Nothing) ">publicKey != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">publicKey == null</exception>
      <requires description="The decrypted number should not be negative." exception="T:System.ArgumentException" csharp="!number.Negative" vb="Not number.Negative">!number.Negative</requires>
      <exception cref="T:System.ArgumentException">number.Negative</exception>
      <requires description="The public key should not be negative." exception="T:System.ArgumentException" csharp="!publicKey.Negative" vb="Not publicKey.Negative">!publicKey.Negative</requires>
      <exception cref="T:System.ArgumentException">publicKey.Negative</exception>
      <requires description="The secret exponent should be positive." exception="T:System.ArgumentException" csharp="secretExponent &gt; op_Implicit((long)0)" vb="secretExponent &gt; operator ((Long )0) ">secretExponent &gt; whiteMath.ArithmeticLong.LongInt&lt;E&gt;.op_Implicit((long)0)</requires>
      <exception cref="T:System.ArgumentException">secretExponent &lt;= 0</exception>
    </member>
    <member name="M:whiteMath.Cryptography.RSA.DecryptAsSingle``2(System.Collections.Generic.IEnumerable{whiteMath.ArithmeticLong.LongInt{``0}},whiteMath.ArithmeticLong.LongInt{``0},whiteMath.ArithmeticLong.LongInt{``1},whiteMath.Cryptography.RSA.BigNumberEncryptionMethod)">
      <summary>
            Treats a sequence of <c>LongInt&lt;<typeparamref name="B" />&gt;</c> numbers as
            a single big number which has been encrypted modulo <paramref name="publicKey" /> and
            returns the result of decryption.
            </summary>
      <typeparam name="B">An implementation of <c>IBase</c> interface which specifies the digit base of <c>LongInt&lt;<typeparamref name="B" />&gt;</c> numbers.</typeparam>
      <typeparam name="E">An implementation of <see cref="T:whiteMath.ArithmeticLong.IBase" /> interface which specifies the digit base of the public exponent. Should be a power of 2 for faster encryption.</typeparam>
      <param name="numberSequence">A sequence of encrypted numbers which are treated as a single number which was bigger than the <paramref name="publicKey" /> during the encryption process.</param>
      <param name="publicKey">The public key which was used during the encryption process. Should be a product of two primes.</param>
      <param name="secretExponent">The secret exponent of the RSA algorithm.</param>
      <param name="bnem">Options which were used during the encryption process. Wrong options will result in a wrong decryption.</param>
      <remarks>If <paramref name="secretExponent" /> has digit base which is a power of 2, the decryption process will go faster.</remarks>
      <returns>With all conditions of the RSA met and correct options specified, the method returns the decrypted number.</returns>
      <requires description="numberSequence" exception="T:System.ArgumentNullException" csharp="numberSequence != null" vb="numberSequence &lt;&gt; Nothing">numberSequence != null</requires>
      <exception cref="T:System.ArgumentNullException">numberSequence == null</exception>
      <requires description="The sequence should contain at least one encrypted number." exception="T:System.ArgumentException" csharp="Count&lt;whiteMath.ArithmeticLong.LongInt&lt;B&gt;&gt;(numberSequence) &gt; 0" vb="Count(numberSequence) &gt; 0">System.Linq.Enumerable.Count&lt;whiteMath.ArithmeticLong.LongInt&lt;B&gt;&gt;(numberSequence) &gt; 0</requires>
      <exception cref="T:System.ArgumentException">!(numberSequence.Count() &gt; 0)</exception>
      <requires description="The secret exponent should be positive." exception="T:System.ArgumentException" csharp="secretExponent &gt; op_Implicit((long)0)" vb="secretExponent &gt; operator ((Long )0) ">secretExponent &gt; whiteMath.ArithmeticLong.LongInt&lt;E&gt;.op_Implicit((long)0)</requires>
      <exception cref="T:System.ArgumentException">secretExponent &lt;= 0</exception>
      <requires description="At least one number in the sequence is null." csharp="for all x in numberSequence x != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null" vb="for all x in numberSequence x &lt;&gt; ((whiteMath.ArithmeticLong.LongInt(Of B))Nothing) ">for all x in numberSequence x != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null</requires>
      <requires description="At least one number in the sequence is negative." csharp="for all x in numberSequence !x.Negative" vb="for all x in numberSequence Not x.Negative">for all x in numberSequence !x.Negative</requires>
    </member>
    <member name="M:whiteMath.Cryptography.RSA.Encrypt``2(whiteMath.ArithmeticLong.LongInt{``0},whiteMath.ArithmeticLong.LongInt{``0},whiteMath.ArithmeticLong.LongInt{``1},whiteMath.Cryptography.RSA.BigNumberEncryptionMethod)">
      <summary>
            Encrypts a long integer number using the RSA algorithm.
            In case when the number to encrypt is bigger than the public key,
            its copy is continously divided by the key until it becomes zero, and remainders are encrypted.
            </summary>
      <typeparam name="B">An implementation of <see cref="T:whiteMath.ArithmeticLong.IBase" /> interface which specifies the digit base of the encrypted number.</typeparam>
      <typeparam name="E">An implementation of <see cref="T:whiteMath.ArithmeticLong.IBase" /> interface which specifies the digit base of the public exponent. Should be a power of 2 for faster encryption.</typeparam>
      <param name="number">The number to encrypt.</param>
      <param name="publicKey">The public key of the RSA algorithm. Should be a product of two big prime numbers.</param>
      <param name="publicExponent">The public exponent of the RSA algorithm. Should be relatively prime to Euler's totient function value for <paramref name="publicKey" />.</param>
      <param name="bnem"> Option specifying how numbers bigger than the <paramref name="publicKey" /> are handled when encrypted using the RSA algorithm.</param>
      <remarks>If <paramref name="publicExponent" /> has digit base which is a power of 2, the decryption process will go faster.</remarks>
      <returns>A sequence of encrypted values, which, along with <paramref name="bnem" /> parameter, allows decryption using <c>Decrypt()</c> method.</returns>
      <requires description="number" exception="T:System.ArgumentNullException" csharp="number != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null" vb="number &lt;&gt; ((whiteMath.ArithmeticLong.LongInt(Of B))Nothing) ">number != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">number == null</exception>
      <requires description="publicKey" exception="T:System.ArgumentNullException" csharp="publicKey != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null" vb="publicKey &lt;&gt; ((whiteMath.ArithmeticLong.LongInt(Of B))Nothing) ">publicKey != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">publicKey == null</exception>
      <requires description="The encrypted number should not be negative." exception="T:System.ArgumentException" csharp="number &gt; op_Implicit((long)0)" vb="number &gt; operator ((Long )0) ">number &gt; whiteMath.ArithmeticLong.LongInt&lt;B&gt;.op_Implicit((long)0)</requires>
      <exception cref="T:System.ArgumentException">number &lt;= 0</exception>
      <requires description="The public exponent should not be zero." exception="T:System.ArgumentException" csharp="publicExponent &gt; op_Implicit((long)0)" vb="publicExponent &gt; operator ((Long )0) ">publicExponent &gt; whiteMath.ArithmeticLong.LongInt&lt;E&gt;.op_Implicit((long)0)</requires>
      <exception cref="T:System.ArgumentException">publicExponent &lt;= 0</exception>
      <requires description="When using the 'splitting' big number encryption option, the number of digits in the public key should be more than 1." exception="T:System.ArgumentException" csharp="publicKey.Length &gt; 1 || bnem != (whiteMath.Cryptography.RSA.BigNumberEncryptionMethod)1" vb="publicKey.Length &gt; 1 OrElse bnem &lt;&gt; ((whiteMath.Cryptography.RSA.BigNumberEncryptionMethod)1)">publicKey.Length &gt; 1 || bnem != (whiteMath.Cryptography.RSA.BigNumberEncryptionMethod)1</requires>
      <exception cref="T:System.ArgumentException">publicKey.Length &lt;= 1 &amp;&amp; bnem == BigNumberEncryptionMethod.Splitting</exception>
    </member>
    <member name="P:whiteMath.Cryptography.RSA.PublicExponents">
      <summary>
            This property provides preset Fermat prime public exponents
            which are guaranteed to be coprime with Euler's totient function
            of any RSA module and may be safely used for RSA encryption.
            </summary>
    </member>
    <member name="T:whiteMath.Cryptography.RSA.PublicExponentCollection">
      <summary>
            This property provides preset Fermat prime public exponents
            which are guaranteed to be coprime with Euler's totient function
            of any RSA module and may be safely used for RSA encryption.
            </summary>
    </member>
    <member name="P:whiteMath.Cryptography.RSA.PublicExponentCollection.Item(System.Int32)">
      <summary>
            Gets a preset Fermat prime public exponent
            which is guaranteed to be coprime with Euler's totient function
            of any RSA module and may be safely used for RSA encryption
            </summary>
      <param name="i">An index of the preset public exponent. Should be non-negative and less than <see cref="P:whiteMath.Cryptography.RSA.PublicExponentCollection.Length" />.</param>
      <returns>The i'th preset Fermat prime public exponent from the list.</returns>
    </member>
    <member name="P:whiteMath.Cryptography.RSA.PublicExponentCollection.Length">
      <summary>
            Gets the length of the preset public exponent list.
            </summary>
    </member>
    <member name="T:whiteMath.Cryptography.RSA.BigNumberEncryptionMethod">
      <summary>
            The enum which members specify how numbers
            bigger than the module are handled when encrypted
            or decrypted using the RSA algorithm.
            </summary>
    </member>
    <member name="F:whiteMath.Cryptography.RSA.BigNumberEncryptionMethod.Division">
      <summary>
        <para>
            During the encryption process, if the number to be encrypted is bigger than the public key,
            this option makes its copy to be continously divided by the key until it becomes zero. 
            Remainders to be encrypted.
            </para>
        <para>
            During the decryption process, this option signalizes that decrypted numbers are
            actually the remainders of a former division, so they will be sequentially multiplied 
            by the public key and summarized to form the original message.
            </para>
        <para>
            In general, this option will make the encrypted sequence more compact, but may slow down 
            the process of both encryption and decryption. When the number is less than the module, this option
            doesn't matter.
            </para>
      </summary>
    </member>
    <member name="F:whiteMath.Cryptography.RSA.BigNumberEncryptionMethod.Splitting">
      <summary>
        <para>
            During the encryption process, if the number to be encrypted is bigger than the public key,
            the former is split down into parts which for sure contain less digits than the key contains (thus, they are
            definitely numerically smaller when treated as separate numbers), and these parts are encrypted
            to form the sequence.
            </para>
        <para>
            During the decryption process, this option signalizes that decrypted numbers are
            actually parts which should be merged to form the original message.
            </para>
        <para>
            In general, this option will make the encrypted sequence longer, but may speed up
            the process of both encryption and decryption. When the number is less than the module, this option 
            doesn't matter.
            </para>
      </summary>
    </member>
    <member name="T:whiteMath.Assertions">
      <summary>
            Static class used for runtime assertions.
            </summary>
    </member>
    <member name="M:whiteMath.Assertions.Assert(System.Boolean,System.Exception)">
      <summary>
            Performs an assertion of boolean value.
            Of it is false, throws the exception specified.
            </summary>
      <param name="value">The statement to be asserted.</param>
      <param name="ex">The exception to be thrown if the statement is false.</param>
    </member>
    <member name="M:whiteMath.Assertions.Assert_NotNull(System.Object,System.String)">
      <summary>
            Performs an assertion that the value passed
            is not null. If it is, throws an ArgumentNullException 
            with the message passed.
            </summary>
      <param name="obj">The object to be tested for null.</param>
      <param name="exceptionMessage">The message for the ArgumentNullException.</param>
    </member>
    <member name="T:whiteMath.Functions.LagrangePolynom`2">
      <summary>
            Represents a polynom in the Lagrange interpolation form.
            Used to create a polynom of degree N basing on its equivalent form
            of argument/value pairs in (N+1) points.
            
            Although the simple Polynom(T,C) can be used if the appropriate SLAE
            is solved to explicitly find all the coefficients, the system's matrix
            is very ill-conditioned and thus there is a big probability 
            of badly calculated result.
            
            On the other side, LagrangePolynom's calculation method 
            would take much more time than of the simple Polynom using Horner's scheme.
            </summary>
      <see cref="T:whiteMath.Functions.Polynom`2" />
      <typeparam name="T">The type of polynom coefficients/value.</typeparam>
      <typeparam name="C">The calculator for the coefficient type.</typeparam>
    </member>
    <member name="T:whiteMath.Functions.IFunction`2">
      <summary>
            The generic function interface.
            </summary>
      <typeparam name="TypeArg">The type of the function argument.</typeparam>
      <typeparam name="TypeValue">The type of the function value.</typeparam>
    </member>
    <member name="M:whiteMath.Functions.LagrangePolynom`2.BasisPolynom(System.Int32)">
      <summary>
            Gets the basis polynom of zero-based index i for
            the current Lagrange interpolation polynom.
            </summary>
      <param name="i">The index of the basis polynom to get. Lies in interval [0; n-1].</param>
      <returns>The i-th basis polynom for the current Lagrange interpolation polynom.</returns>
    </member>
    <member name="M:whiteMath.Functions.LagrangePolynom`2.#ctor(System.Collections.Generic.IList{whiteMath.General.Point{`0}})">
      <summary>
            Creates a new instance of Lagrange polynom object using the points list.
            </summary>
      <param name="points">The points list.</param>
    </member>
    <member name="M:whiteMath.Functions.LagrangePolynom`2.#ctor(whiteMath.General.Point{`0}[])">
      <summary>
            Creates a new instance of Lagrange polynom object using the points parameters.
            </summary>
      <param name="points">The points parameter array.</param>
    </member>
    <member name="P:whiteMath.Functions.LagrangePolynom`2.FormalDegree">
      <summary>
            Returns the formal degree of the polynom.
            Meanwhile, if the lagrange polynom is a line built on
            three points, it will return degree 2 even though
            the coefficient of x^2 will be zero.
            </summary>
    </member>
    <member name="T:whiteMath.General.JaggedArrayExtensions">
      <summary>
            This class provides extension methods 
            for multi-dimensional jagged arrays.
            </summary>
    </member>
    <member name="M:whiteMath.General.JaggedArrayExtensions.To2DArray``1(``0[][])">
      <summary>
            Converts a rectangular two-dimensional jagged array
            to a two-dimensional array with the same dimensionality
            and data.
            
            The source jagged array must contain no <c>null</c> rows
            and all the rows must have the same column count.
            </summary>
      <typeparam name="T">The type of elements in the array.</typeparam>
      <param name="jagged">The source array to be transformed. Remains untouched.</param>
      <exception cref="T:System.ArgumentException">
            Throws an <see cref="T:System.ArgumentException" /> if the source
            array is not rectangular (i.e. not all rows of the source
            array have the same column count).
            </exception>
      <exception cref="T:System.ArgumentException">
            Throws an <see cref="T:System.ArgumentException" /> if the source
            array contains null values.
            </exception>
      <returns>
            A two-dimensional array with the same dimensionality and data
            as the source jagged array.
            </returns>
      <requires description="jagged" exception="T:System.ArgumentNullException" csharp="jagged != null" vb="jagged &lt;&gt; Nothing">jagged != null</requires>
      <exception cref="T:System.ArgumentNullException">jagged == null</exception>
      <requires description="The source array must contain no null rows." exception="T:System.ArgumentException" csharp="for all x in jagged x != null" vb="for all x in jagged x &lt;&gt; Nothing">for all x in jagged x != null</requires>
      <exception cref="T:System.ArgumentException">!(Contract.ForAll&lt;T[]&gt;(jagged, (x =&gt; x != null)))</exception>
      <requires description="The source array must be rectangular." exception="T:System.ArgumentException" csharp="for all x in jagged x.Length == jagged[0].Length" vb="for all x in jagged x.Length = jagged(0).Length">for all x in jagged x.Length == jagged[0].Length</requires>
      <exception cref="T:System.ArgumentException">!(Contract.ForAll&lt;T[]&gt;(jagged, (x =&gt; x.Length == jagged[0].Length)))</exception>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:whiteMath.General.JaggedArrayExtensions.RemoveNullRows``1(``0[][])">
      <summary>
            Removes all null rows from the source
            jagged array and returns the jagged array
            of possibly reduced row dimensionality. 
            
            The resulting object contains the same data 
            as the source array, excluding the null rows.
            </summary>
      <typeparam name="T">The type of elements in the array.</typeparam>
      <param name="jagged">The source array which possibly contains null rows.</param>
      <returns>
            A jagged array containing the same data 
            as the source array, excluding the null rows.
            </returns>
      <requires description="jagged" exception="T:System.ArgumentNullException" csharp="jagged != null" vb="jagged &lt;&gt; Nothing">jagged != null</requires>
      <exception cref="T:System.ArgumentNullException">jagged == null</exception>
      <ensures csharp="for all x in result x != null" vb="for all x in result x &lt;&gt; Nothing">for all x in result x != null</ensures>
    </member>
    <member name="T:whiteMath.General.ZeroBasedMatrixWrapper`1">
      <summary>
            Creates a zero-based matrix wrapper for 
            matrices with arbitrary index base.
            </summary>
    </member>
    <member name="M:whiteMath.General.ZeroBasedMatrixWrapper`1.#ctor(`0[0:,0:])">
      <summary>
            Creates a new <see cref="!:ZeroBasedMatrixWrapper" />
            object from an arbitrarily-indexed parent matrix. 
            </summary>
      <param name="parentMatrix">The parent matrix object.</param>
      <requires description="parentMatrix" exception="T:System.ArgumentNullException" csharp="parentMatrix != null" vb="parentMatrix &lt;&gt; Nothing">parentMatrix != null</requires>
      <exception cref="T:System.ArgumentNullException">parentMatrix == null</exception>
    </member>
    <member name="M:whiteMath.General.ZeroBasedMatrixWrapper`1.ToTwoDimensionalArray">
      <summary>
            Creates a new zero-based two-dimensional array
            from the current zero-based wrapper.
            </summary>
      <returns>
            A new zero-based two dimensional array populated
            with the same shallow-copied data.
            </returns>
    </member>
    <member name="P:whiteMath.General.ZeroBasedMatrixWrapper`1.ParentMinRowIndex">
      <summary>
            Gets the row minimum index boundary in the 
            parent matrix.
            </summary>
    </member>
    <member name="P:whiteMath.General.ZeroBasedMatrixWrapper`1.ParentMinColumnIndex">
      <summary>
            Gets the column minimum index boundary in the 
            parent matrix.
            </summary>
    </member>
    <member name="P:whiteMath.General.ZeroBasedMatrixWrapper`1.RowCount">
      <summary>
            Gets the number of rows in the matrix.
            </summary>
    </member>
    <member name="P:whiteMath.General.ZeroBasedMatrixWrapper`1.ColumnCount">
      <summary>
            Gets the number of columns in the matrix.
            </summary>
    </member>
    <member name="P:whiteMath.General.ZeroBasedMatrixWrapper`1.ParentMatrix">
      <summary>
            Gets the parent arbitrarily-indexed matrix object.
            </summary>
    </member>
    <member name="P:whiteMath.General.ZeroBasedMatrixWrapper`1.Item(System.Int32,System.Int32)">
      <summary>
            Gets or sets the element at the 
            specified row/column coordinate pair.
            </summary>
      <param name="indexRow">A zero-based row index of the element to be got or set.</param>
      <param name="indexColumn">A zero-based column index of the element to be got or set.</param>
      <returns>The element located in the specified row and column.</returns>
    </member>
    <member name="T:whiteMath.General.ByteSequenceToString">
      <summary>
            This class allows to convert byte sequences to hexadecimal string
            representations and to restore sequences from such strings.
            </summary>
    </member>
    <member name="M:whiteMath.General.ByteSequenceToString.___toHexSymbol(System.Int32,System.Boolean)">
      <summary>
            Цифирку - в гекс =0)
            </summary>
    </member>
    <member name="M:whiteMath.General.ByteSequenceToString.ToHexString(System.Collections.Generic.IEnumerable{System.Byte},System.Boolean,System.Boolean)">
      <summary>
            Converts a sequence of bytes into a hexadecimal string.
            </summary>
      <param name="bigEndian">
            If this parameter is set to true, than in two consecutive hex string symbols, 
            the first is treated as the least significant part of the byte, 
            and the second one as the most significant, e.g. <c>A1</c>
            would mean <c>26</c> and not <c>161</c>.
            </param>
      <param name="sequence">A sequence of bytes to be represented as a hex string.</param>
      <param name="upperCase">A flag specifying whether the 
            A, B, C, D, E, F digits, if any appear, should be uppercase.</param>
      <returns>A hexadecimal string </returns>
      <requires description="sequence" exception="T:System.ArgumentNullException" csharp="sequence != null" vb="sequence &lt;&gt; Nothing">sequence != null</requires>
      <exception cref="T:System.ArgumentNullException">sequence == null</exception>
    </member>
    <member name="M:whiteMath.General.ByteSequenceToString.RestoreFromHexString(System.String,System.Boolean)">
      <summary>
            Restores the byte array from its string representation created by
            <see cref="M:whiteMath.General.ByteSequenceToString.ToHexString(System.Collections.Generic.IEnumerable{System.Byte},System.Boolean,System.Boolean)" />.
            </summary>
      <param name="hexString">
            A string consiting of hexadecimal digits in upper or lower case.
            </param>
      <param name="bigEndian">
            If this parameter is set to true, than in two consecutive hex string symbols, 
            the first is treated as the least significant part of the byte, 
            and the second one as the most significant, e.g. <c>A1</c>
            would mean <c>26</c> and not <c>161</c>.
            </param>
      <returns>A byte array made from <paramref name="hexString" />.</returns>
      <requires description="hexString" exception="T:System.ArgumentNullException" csharp="hexString != null" vb="hexString &lt;&gt; Nothing">hexString != null</requires>
      <exception cref="T:System.ArgumentNullException">hexString == null</exception>
    </member>
    <member name="T:whiteMath.General.CollectionFillingExtensions">
      <summary>
            This static class provides extension methods
            for filling collections with new elements.
            </summary>
    </member>
    <member name="M:whiteMath.General.CollectionFillingExtensions.FillByAppending``1(System.Collections.Generic.ICollection{``0},System.Int32,``0)">
      <summary>
            Adds the same value to a collection the specified amount of times.
            </summary>
      <remarks>
            The filling is made by <c>Add()</c> operation, which means, no existing 
            elements of the collection will be modified by this method.
            </remarks>
      <typeparam name="T">The type of elements in the collection.</typeparam>
      <param name="collection">The collection reference.</param>
      <param name="elementCount">A number specifying how many elements should be added to the collection.</param>
      <param name="value">The value to fill the collection with.</param>
      <requires description="collection" exception="T:System.ArgumentNullException" csharp="collection != null" vb="collection &lt;&gt; Nothing">collection != null</requires>
      <exception cref="T:System.ArgumentNullException">collection == null</exception>
      <requires description="The element count should be a non-negative value." exception="T:System.ArgumentOutOfRangeException" csharp="elementCount &gt;= 0" vb="elementCount &gt;= 0">elementCount &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">elementCount &lt; 0</exception>
    </member>
    <member name="M:whiteMath.General.CollectionFillingExtensions.FillByAppending``1(System.Collections.Generic.ICollection{``0},System.Int32,whiteMath.Randoms.IRandomBounded{``0},``0,``0)">
      <summary>
            Adds elements to a collection by using a random number generator
            to create random numbers in the interval <c>[<paramref name="min" />; <paramref name="max" />)</c>.
            </summary>
      <remarks>
            The filling is made by <c>Add()</c> operation, which means, no existing 
            elements of the collection will be modified by this method.
            </remarks>
      <typeparam name="T">The type of elements in the collection.</typeparam>
      <param name="collection">The collection reference.</param>
      <param name="elementCount">A number specifying how many elements should be added to the collection.</param>
      <param name="randomGenerator">A random generator.</param>
      <param name="min">The lower inclusive bound of numbers to be generated.</param>
      <param name="max">The upper exclusive bound of numbers to be generated.</param>
      <requires description="collection" exception="T:System.ArgumentNullException" csharp="collection != null" vb="collection &lt;&gt; Nothing">collection != null</requires>
      <exception cref="T:System.ArgumentNullException">collection == null</exception>
      <requires description="randomGenerator" exception="T:System.ArgumentNullException" csharp="randomGenerator != null" vb="randomGenerator &lt;&gt; Nothing">randomGenerator != null</requires>
      <exception cref="T:System.ArgumentNullException">randomGenerator == null</exception>
      <requires description="The element count should be a non-negative value." exception="T:System.ArgumentOutOfRangeException" csharp="elementCount &gt;= 0" vb="elementCount &gt;= 0">elementCount &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">elementCount &lt; 0</exception>
    </member>
    <member name="M:whiteMath.General.CollectionFillingExtensions.FillByAppending``1(System.Collections.Generic.ICollection{``0},System.Int32,System.Func{System.Int32,``0})">
      <summary>
            Adds elements to a collection by incorporating current element's zero-based order number.
            </summary>
      <remarks>
            The filling is made by <c>Add()</c> operation, which means, no existing 
            elements of the collection will be modified by this method.
            </remarks>
      <typeparam name="T">The type of elements in the collection.</typeparam>
      <param name="collection">The collection reference.</param>
      <param name="elementCount">A number specifying how many elements should be added to the collection.</param>
      <param name="function">A function that maps integer indices to <typeparamref name="T" /> values.</param>
      <requires description="collection" exception="T:System.ArgumentNullException" csharp="collection != null" vb="collection &lt;&gt; Nothing">collection != null</requires>
      <exception cref="T:System.ArgumentNullException">collection == null</exception>
      <requires description="function" exception="T:System.ArgumentNullException" csharp="function != null" vb="function &lt;&gt; Nothing">function != null</requires>
      <exception cref="T:System.ArgumentNullException">function == null</exception>
      <requires description="The element count should be a non-negative value." exception="T:System.ArgumentOutOfRangeException" csharp="elementCount &gt;= 0" vb="elementCount &gt;= 0">elementCount &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">elementCount &lt; 0</exception>
    </member>
    <member name="M:whiteMath.General.CollectionFillingExtensions.FillByAppending``1(System.Collections.Generic.ICollection{``0},System.Int32,System.Func{``0,``0},``0)">
      <summary>
            Adds elements to a collection by incorporating previously added element's value.
            The first element to add should be explicitly provided.
            </summary>
      <remarks>
            The filling is made by <c>Add()</c> operation, which means, no existing 
            elements of the collection will be modified by this method.
            </remarks>
      <typeparam name="T">The type of elements in the collection.</typeparam>
      <param name="collection">The collection reference.</param>
      <param name="elementCount">A number specifying how many elements should be added to the collection.</param>
      <param name="function">The function that maps <typeparamref name="T" />--&gt;<typeparamref name="T" /></param>
      <param name="firstElement">
            The first element to be added. The next element would be 
            created using <c><paramref name="function" /></c> 
            with this element as an argument.
            </param>
      <requires description="collection" exception="T:System.ArgumentNullException" csharp="collection != null" vb="collection &lt;&gt; Nothing">collection != null</requires>
      <exception cref="T:System.ArgumentNullException">collection == null</exception>
      <requires description="function" exception="T:System.ArgumentNullException" csharp="function != null" vb="function &lt;&gt; Nothing">function != null</requires>
      <exception cref="T:System.ArgumentNullException">function == null</exception>
      <requires description="The element count should be a non-negative value." exception="T:System.ArgumentOutOfRangeException" csharp="elementCount &gt;= 0" vb="elementCount &gt;= 0">elementCount &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">elementCount &lt; 0</exception>
    </member>
    <member name="M:whiteMath.General.CollectionFillingExtensions.FillByAppending``1(System.Collections.Generic.ICollection{``0},System.Int32,System.Func{``0,System.Int32,``0},``0)">
      <summary>
            Adds elements to a collection incorporating both current element's zero-based order number 
            and the value of previously added element. 
            The first element to add should be explicitly provided.
            </summary>
      <remarks>
            The filling is made by <c>Add()</c> operation, which means, no existing 
            elements of the collection will be modified by this method.
            </remarks>
      <typeparam name="T">The type of elements in the collection.</typeparam>
      <param name="collection">The collection reference.</param>
      <param name="elementCount">A number specifying how many elements should be added to the collection.</param>
      <param name="function">The function mapping (int, T) --&gt; T.</param>
      <param name="firstElement">
            The first element to be added to the collection. 
            The next element would be created using the function passed with this element as an argument.</param>
      <requires description="collection" exception="T:System.ArgumentNullException" csharp="collection != null" vb="collection &lt;&gt; Nothing">collection != null</requires>
      <exception cref="T:System.ArgumentNullException">collection == null</exception>
      <requires description="function" exception="T:System.ArgumentNullException" csharp="function != null" vb="function &lt;&gt; Nothing">function != null</requires>
      <exception cref="T:System.ArgumentNullException">function == null</exception>
      <requires description="The element count should be a non-negative value." exception="T:System.ArgumentOutOfRangeException" csharp="elementCount &gt;= 0" vb="elementCount &gt;= 0">elementCount &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">elementCount &lt; 0</exception>
    </member>
    <member name="T:whiteMath.General.TwoDimensionalArrayExtensions">
      <summary>
            Provides extension methods for two-dimensional arrays.
            </summary>
    </member>
    <member name="M:whiteMath.General.TwoDimensionalArrayExtensions.ToZeroBasedTwoDimensionalArray``1(``0[0:,0:])">
      <summary>
            Creates a two-dimensional array with the same data as in the source array,
            but with zero-based indices for both rows and columns. 
            </summary>
      <typeparam name="T">The type of elements in the array.</typeparam>
      <param name="matrix">An arbitrarily-indexed source two-dimensional array.</param>
      <returns>
            A two-dimensional array with the same data as in the source array,
            but with zero-based indices for both rows and columns.
            </returns>
      <requires description="matrix" exception="T:System.ArgumentNullException" csharp="matrix != null" vb="matrix &lt;&gt; Nothing">matrix != null</requires>
      <exception cref="T:System.ArgumentNullException">matrix == null</exception>
    </member>
    <member name="M:whiteMath.General.TwoDimensionalArrayExtensions.ToDataTable``1(``0[0:,0:],System.Collections.Generic.IList{System.String})">
      <summary>
            Creates a <see cref="T:System.Data.DataTable" /> populated with 
            data from a two-dimensional array with
            optionally specified column headers list.
            </summary>
      <typeparam name="T">The type of elements in the array.</typeparam>
      <param name="matrix">The source array to be converted to a <see cref="T:System.Data.DataTable" />.</param>
      <param name="columnHeaders">
            An optional list containing the column headers.
            If not <c>null</c>, the size of the list
            MUST match the amount of columns in the <paramref name="matrix" />.
            </param>
      <returns>
            A <see cref="T:System.Data.DataTable" /> populated with the data from the source
            two-dimensional array.
            </returns>
      <requires description="matrix" exception="T:System.ArgumentNullException" csharp="matrix != null" vb="matrix &lt;&gt; Nothing">matrix != null</requires>
      <exception cref="T:System.ArgumentNullException">matrix == null</exception>
      <requires description="The column headers list length must match the matrix' column count." exception="T:System.ArgumentException" csharp="columnHeaders == default(System.Collections.Generic.IList&lt;string&gt;) || matrix.GetLength(1) == columnHeaders.Count" vb="columnHeaders = Nothing OrElse matrix.GetLength(1) = columnHeaders.Count">columnHeaders == default(System.Collections.Generic.IList&lt;string&gt;) || matrix.GetLength(1) == columnHeaders.Count</requires>
      <exception cref="T:System.ArgumentException">
                columnHeaders != null &amp;&amp; !(matrix.GetLength(1) == columnHeaders.Count)</exception>
    </member>
    <member name="M:whiteMath.General.TwoDimensionalArrayExtensions.ToJaggedArray``1(``0[0:,0:])">
      <summary>
            Converts a two-dimensional matrix into 
            a two-dimensional jagged array with the same
            dimensionality and data.
            </summary>
      <typeparam name="T">The types of element in the matrix.</typeparam>
      <param name="matrix">The source object to be converted to a jagged array. Remains untouched.</param>
      <returns>
            A two-dimensional jagged array with the same
            dimensionality and data as the source object.
            </returns>
      <requires description="matrix" exception="T:System.ArgumentNullException" csharp="matrix != null" vb="matrix &lt;&gt; Nothing">matrix != null</requires>
      <exception cref="T:System.ArgumentNullException">matrix == null</exception>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:whiteMath.General.TwoDimensionalArrayExtensions.GetRowWrapper``1(``0[0:,0:],System.Int32)">
      <summary>
            Gets a one-dimensional wrapper for the specified 
            row of a two-dimensional array.
            </summary>
      <param name="matrix">The source two-dimensional array to be wrapped.</param>
      <param name="rowIndex">The row index of the source array to be fixed.</param>
      <returns>A one-dimensional wrapper for the row at the specified row index.</returns>
      <requires description="matrix" exception="T:System.ArgumentNullException" csharp="matrix != null" vb="matrix &lt;&gt; Nothing">matrix != null</requires>
      <exception cref="T:System.ArgumentNullException">matrix == null</exception>
      <requires description="The row index is out of range." exception="T:System.ArgumentOutOfRangeException" csharp="rowIndex &gt;= 0 &amp;&amp; rowIndex &lt; matrix.GetLength(0)" vb="rowIndex &gt;= 0 AndAlso rowIndex &lt; matrix.GetLength(0)">rowIndex &gt;= 0 &amp;&amp; rowIndex &lt; matrix.GetLength(0)</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">rowIndex &lt; 0 || !(rowIndex &lt; matrix.GetLength(0))</exception>
    </member>
    <member name="M:whiteMath.General.TwoDimensionalArrayExtensions.SetRowAt``1(``0[0:,0:],System.Int32,System.Collections.Generic.IList{``0})">
      <summary>
            Replaces the values in the two-dimensional arary row at the specified
            row index by the values in the specified list.
            </summary>
      <typeparam name="T">The type of the elements in the collections.</typeparam>
      <param name="matrix">The two-dimensional array to be modified.</param>
      <param name="rowIndex">The row index of the two-dimensional array.</param>
      <param name="list">The list containing the values to be placed in the specified row.</param>
      <requires description="matrix" exception="T:System.ArgumentNullException" csharp="matrix != null" vb="matrix &lt;&gt; Nothing">matrix != null</requires>
      <exception cref="T:System.ArgumentNullException">matrix == null</exception>
      <requires description="list" exception="T:System.ArgumentNullException" csharp="list != null" vb="list &lt;&gt; Nothing">list != null</requires>
      <exception cref="T:System.ArgumentNullException">list == null</exception>
      <requires description="The row index is out of range." exception="T:System.ArgumentOutOfRangeException" csharp="rowIndex &gt;= 0 &amp;&amp; rowIndex &lt; matrix.GetLength(0)" vb="rowIndex &gt;= 0 AndAlso rowIndex &lt; matrix.GetLength(0)">rowIndex &gt;= 0 &amp;&amp; rowIndex &lt; matrix.GetLength(0)</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">rowIndex &lt; 0 || !(rowIndex &lt; matrix.GetLength(0))</exception>
    </member>
    <member name="M:whiteMath.General.TwoDimensionalArrayExtensions.GetSubArray``1(``0[0:,0:],System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Computes a subarray of a specified 2D array,
            starting at the specified position (row and column index)
            and spanning the specified number of rows and columns.
            The result 2D array does not depend on the original array in 
            terms of getting / setting its elements (the elements themselves
            are shallow copies though).
            </summary>
      <typeparam name="T">The type of elements in the source array.</typeparam>
      <param name="matrix">A 2D array whose submatrix is to be calculated.</param>
      <param name="atRowIndex">The row index in the <paramref name="matrix" /> where the subarray should begin.</param>
      <param name="atColumnIndex">The column index in the <paramref name="matrix" /> where the subarray should begin.</param>
      <param name="rowCount">Total number of rows in the resulting array.</param>
      <param name="columnCount">Total number of columns in the resulting array.</param>
      <returns>
            A 2D array containing elements of <paramref name="matrix" /> 
            starting from row <paramref name="atRowIndex" /> and column <paramref name="atColumnIndex" />
            and spanning <paramref name="rowCount" /> rows and <paramref name="columnCount" /> columns.
            </returns>
      <pure />
      <requires description="matrix" exception="T:System.ArgumentNullException" csharp="matrix != null" vb="matrix &lt;&gt; Nothing">matrix != null</requires>
      <exception cref="T:System.ArgumentNullException">matrix == null</exception>
      <requires description="The row index of the source 2D array is out of range." exception="T:System.IndexOutOfRangeException" csharp="atRowIndex &gt;= 0 &amp;&amp; atRowIndex &lt; matrix.GetLength(0)" vb="atRowIndex &gt;= 0 AndAlso atRowIndex &lt; matrix.GetLength(0)">atRowIndex &gt;= 0 &amp;&amp; atRowIndex &lt; matrix.GetLength(0)</requires>
      <exception cref="T:System.IndexOutOfRangeException">
                atRowIndex &lt; 0 || !(atRowIndex &lt; matrix.GetLength(0))</exception>
      <requires description="The column index of the source 2D array is out of range." exception="T:System.IndexOutOfRangeException" csharp="atColumnIndex &gt;= 0 &amp;&amp; atColumnIndex &lt; matrix.GetLength(1)" vb="atColumnIndex &gt;= 0 AndAlso atColumnIndex &lt; matrix.GetLength(1)">atColumnIndex &gt;= 0 &amp;&amp; atColumnIndex &lt; matrix.GetLength(1)</requires>
      <exception cref="T:System.IndexOutOfRangeException">
                atColumnIndex &lt; 0 || !(atColumnIndex &lt; matrix.GetLength(1))</exception>
      <requires description="The row count of the result subarray should not be negative." exception="T:System.ArgumentOutOfRangeException" csharp="rowCount &gt;= 0" vb="rowCount &gt;= 0">rowCount &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">
                rowCount &lt; 0</exception>
      <requires description="The column count of the result subarray should not be negative." exception="T:System.ArgumentOutOfRangeException" csharp="columnCount &gt;= 0" vb="columnCount &gt;= 0">columnCount &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">columnCount &lt; 0</exception>
      <requires description="The resulting subarray would exceed the row range of the source 2D array." exception="T:System.ArgumentOutOfRangeException" csharp="atRowIndex + rowCount &lt;= matrix.GetLength(0)" vb="atRowIndex + rowCount &lt;= matrix.GetLength(0)">atRowIndex + rowCount &lt;= matrix.GetLength(0)</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(
                atRowIndex + rowCount &lt;= matrix.GetLength(0))</exception>
      <requires description="The resulting subarray would exceed the column range of the source 2D array." exception="T:System.ArgumentOutOfRangeException" csharp="atColumnIndex + columnCount &lt;= matrix.GetLength(1)" vb="atColumnIndex + columnCount &lt;= matrix.GetLength(1)">atColumnIndex + columnCount &lt;= matrix.GetLength(1)</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(
                atColumnIndex + columnCount &lt;= matrix.GetLength(1))</exception>
    </member>
    <member name="M:whiteMath.General.TwoDimensionalArrayExtensions.PlaceMatrixAt``1(``0[0:,0:],System.Int32,System.Int32,``0[0:,0:])">
      <summary>
            Replaces the element in the source 2D array
            with elements from the second 2D array,
            starting at the specified row and column in the source array.
            </summary>
      <typeparam name="T">The type of elements in the array.</typeparam>
      <param name="matrix">The source matrix to be modified.</param>
      <param name="patch">A second matrix whose elements will replace part of the original matrix.</param>
      <param name="atRowIndex">
            The row index in the <paramref name="matrix" /> where the 
            elements of <paramref name="patch" /> will be placed.
            </param>
      <param name="atColumnIndex">
            The column index in the <paramref name="matrix" /> where the elements 
            of <paramref name="patch" /> will be placed.
            </param>
      <exception cref="T:System.ArgumentException">
            Thrown if <paramref name="patch" /> cannot be completely placed 
            within <paramref name="matrix" /> considering the specified indices of placement.
            </exception>
      <requires description="matrix" exception="T:System.ArgumentNullException" csharp="matrix != null" vb="matrix &lt;&gt; Nothing">matrix != null</requires>
      <exception cref="T:System.ArgumentNullException">matrix == null</exception>
      <requires description="another" exception="T:System.ArgumentNullException" csharp="patch != null" vb="patch &lt;&gt; Nothing">patch != null</requires>
      <exception cref="T:System.ArgumentNullException">patch == null</exception>
      <requires description="The row index in the source array is out of range." exception="T:System.IndexOutOfRangeException" csharp="atRowIndex &gt;= 0 &amp;&amp; atRowIndex &lt; matrix.GetLength(0)" vb="atRowIndex &gt;= 0 AndAlso atRowIndex &lt; matrix.GetLength(0)">atRowIndex &gt;= 0 &amp;&amp; atRowIndex &lt; matrix.GetLength(0)</requires>
      <exception cref="T:System.IndexOutOfRangeException">
                atRowIndex &lt; 0 || !(atRowIndex &lt; matrix.GetLength(0))</exception>
      <requires description="The column index in the source array is out of range." exception="T:System.IndexOutOfRangeException" csharp="atColumnIndex &gt;= 0 &amp;&amp; atColumnIndex &lt; matrix.GetLength(1)" vb="atColumnIndex &gt;= 0 AndAlso atColumnIndex &lt; matrix.GetLength(1)">atColumnIndex &gt;= 0 &amp;&amp; atColumnIndex &lt; matrix.GetLength(1)</requires>
      <exception cref="T:System.IndexOutOfRangeException">
                atColumnIndex &lt; 0 || !(atColumnIndex &lt; matrix.GetLength(1))</exception>
      <requires description="'patch' does not fit within the rows of the 'matrix'." exception="T:System.ArgumentException" csharp="atRowIndex + patch.GetLength(0) &lt;= matrix.GetLength(0)" vb="atRowIndex + patch.GetLength(0) &lt;= matrix.GetLength(0)">atRowIndex + patch.GetLength(0) &lt;= matrix.GetLength(0)</requires>
      <exception cref="T:System.ArgumentException">!(
                atRowIndex + patch.GetLength(0) &lt;= matrix.GetLength(0))</exception>
    </member>
    <member name="M:whiteMath.General.TwoDimensionalArrayExtensions.GetTransposedArray``1(``0[0:,0:])">
      <summary>
            Returns the transposed array from a two-dimensional array
            i.e. such that <c>result[i, j] = source[j, i]</c>. If the source
            array was of size M x N, then the resulting array will have the 
            size N x M.
            </summary>
      <typeparam name="T">The type of elements in the arrays.</typeparam>
      <param name="matrix">The two-dimensional array to be transposed.</param>
      <returns>The transposed two-dimensional array.</returns>
      <requires description="matrix" exception="T:System.ArgumentNullException" csharp="matrix != null" vb="matrix &lt;&gt; Nothing">matrix != null</requires>
      <exception cref="T:System.ArgumentNullException">matrix == null</exception>
    </member>
    <member name="M:whiteMath.General.TwoDimensionalArrayExtensions.WithAttachedToTheLeft``1(``0[0:,0:],``0[0:,0:])">
      <summary>
            Attaches a two-dimensional "patch" array with the same row
            count to the left of the source 2D array. In the result
            2D array, the columns of the original matrix will
            be shifted to the right depending on the column count of the patch. 
            </summary>
      <typeparam name="T">The type of elements in the array.</typeparam>
      <param name="matrix">
            A two-dimensional array to which the <paramref name="leftPatch" /> will be attached.
            Remains unmodified.
            </param>
      <param name="leftPatch">
            A matrix that will be attached to the left of the original 2D array.
            </param>
      <returns>
            A new two-dimensional array of combined column count and the same row count,
            where the beginning columns contain elements of <paramref name="leftPatch" />,
            and the ending columns contain elements of <paramref name="matrix" />.
            </returns>
      <requires description="matrix" exception="T:System.ArgumentNullException" csharp="matrix != null" vb="matrix &lt;&gt; Nothing">matrix != null</requires>
      <exception cref="T:System.ArgumentNullException">matrix == null</exception>
      <requires description="leftPatch" exception="T:System.ArgumentNullException" csharp="leftPatch != null" vb="leftPatch &lt;&gt; Nothing">leftPatch != null</requires>
      <exception cref="T:System.ArgumentNullException">leftPatch == null</exception>
      <requires description="The 2D arrays should have the same row count in order to be attached to each other." exception="T:System.ArgumentException" csharp="matrix.GetLength(0) == leftPatch.GetLength(0)" vb="matrix.GetLength(0) = leftPatch.GetLength(0)">matrix.GetLength(0) == leftPatch.GetLength(0)</requires>
      <exception cref="T:System.ArgumentException">!(
                matrix.GetLength(0) == leftPatch.GetLength(0))</exception>
      <ensures csharp="result.GetLength(0) == matrix.GetLength(0)" vb="result.GetLength(0) = matrix.GetLength(0)">result.GetLength(0) == matrix.GetLength(0)</ensures>
      <ensures csharp="result.GetLength(1) == matrix.GetLength(1) + leftPatch.GetLength(1)" vb="result.GetLength(1) = matrix.GetLength(1) + leftPatch.GetLength(1)">result.GetLength(1) == matrix.GetLength(1) + leftPatch.GetLength(1)</ensures>
    </member>
    <member name="M:whiteMath.General.TwoDimensionalArrayExtensions.WithAttachedToTheRight``1(``0[0:,0:],``0[0:,0:])">
      <summary>
            Attaches a two-dimensional "patch" array with the same row
            count to the right of the source 2D array. In the result
            2D array, the original 2D array will be located in the leftmost part,
            and the "patch" in the rightmost. 
            </summary>
      <typeparam name="T">The type of elements in the array.</typeparam>
      <param name="matrix">
            A two-dimensional array to which the <paramref name="rightPatch" /> will be attached.
            Remains unmodified.
            </param>
      <param name="rightPatch">
            A matrix that will be attached to the right of the original 2D array.
            </param>
      <returns>
            A new two-dimensional array of combined column count and the same row count,
            where the beginning columns contain elements of <paramref name="matrix" />,
            and the ending columns contain elements of <paramref name="rightPatch" />.
            </returns>
      <requires description="matrix" exception="T:System.ArgumentNullException" csharp="matrix != null" vb="matrix &lt;&gt; Nothing">matrix != null</requires>
      <exception cref="T:System.ArgumentNullException">matrix == null</exception>
      <requires description="leftPatch" exception="T:System.ArgumentNullException" csharp="rightPatch != null" vb="rightPatch &lt;&gt; Nothing">rightPatch != null</requires>
      <exception cref="T:System.ArgumentNullException">rightPatch == null</exception>
      <requires description="The 2D arrays should have the same row count in order to be attached to each other." exception="T:System.ArgumentException" csharp="matrix.GetLength(0) == rightPatch.GetLength(0)" vb="matrix.GetLength(0) = rightPatch.GetLength(0)">matrix.GetLength(0) == rightPatch.GetLength(0)</requires>
      <exception cref="T:System.ArgumentException">!(
                matrix.GetLength(0) == rightPatch.GetLength(0))</exception>
      <ensures csharp="result.GetLength(0) == matrix.GetLength(0)" vb="result.GetLength(0) = matrix.GetLength(0)">result.GetLength(0) == matrix.GetLength(0)</ensures>
      <ensures csharp="result.GetLength(1) == matrix.GetLength(1) + rightPatch.GetLength(1)" vb="result.GetLength(1) = matrix.GetLength(1) + rightPatch.GetLength(1)">result.GetLength(1) == matrix.GetLength(1) + rightPatch.GetLength(1)</ensures>
    </member>
    <member name="T:whiteMath.General.TwoDimensionalArrayRow`1">
      <summary>
            Represents a row of a two-dimensional array.
            </summary>
    </member>
    <member name="M:whiteMath.General.TwoDimensionalArrayRow`1.Contains(`0)">
      <summary>
            Gets the flag indicating whether the current row
            contains a particular element.
            </summary>
      <param name="element">The element to be found in the row.</param>
      <returns>
            True if there is an element in the row equal 
            to the element passed, false otherwise.
            </returns>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Contains(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt; 0" vb="result Implies Me.Count &gt; 0">!result || this.Count &gt; 0</ensures>
    </member>
    <member name="M:whiteMath.General.TwoDimensionalArrayRow`1.CopyTo(`0[],System.Int32)">
      <summary>
            Copies the entire row to a compatible one-dimensional array, starting 
            at the specified index of the target array.
            </summary>
      <param name="array">A compatible one-dimensional array.</param>
      <param name="startIndex">The starting index in the target array.</param>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="array != null" vb="array &lt;&gt; Nothing">array != null</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &gt;= 0" vb="arrayIndex &gt;= 0">arrayIndex &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &lt;= array.Length - this.Count" vb="arrayIndex &lt;= array.Length - Me.Count">arrayIndex &lt;= array.Length - this.Count</requires>
    </member>
    <member name="M:whiteMath.General.TwoDimensionalArrayRow`1.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
      <returns>An enumerator that iterates through the collection.</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
    </member>
    <member name="M:whiteMath.General.TwoDimensionalArrayRow`1.System#Collections#IEnumerable#GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
      <returns>An enumerator that iterates through the collection.</returns>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_CurrentIndex == -1" vb="result.get_CurrentIndex = -1">result.get_CurrentIndex == -1</ensures>
    </member>
    <member name="M:whiteMath.General.TwoDimensionalArrayRow`1.IndexOf(`0)">
      <summary>
            Returns the index of a particular element in the 
            collection, or a negative value if the element is absent.
            </summary>
      <param name="element">The element to search for.</param>
      <returns>
            A zero-based index of the element in the collection, 
            or a negative value if the element is not found.
            </returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.IndexOf(`0)" inheritedFromTypeName="IList" csharp="result &gt;= -1" vb="result &gt;= -1">result &gt;= -1</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.IndexOf(`0)" inheritedFromTypeName="IList" csharp="result &lt; this.Count" vb="result &lt; Me.Count">result &lt; this.Count</ensures>
    </member>
    <member name="M:whiteMath.General.TwoDimensionalArrayRow`1.#ctor(`0[0:,0:],System.Int32)">
      <summary>
            Constructs the wrapper collection using a parent
            two-dimensional array object and the row index 
            specified.
            </summary>
      <param name="matrix">
            The source two-dimensional array object
            to be wrapped.
            </param>
      <param name="rowIndex">
            The row index of the source object to be fixed.
            </param>
      <requires description="matrix" exception="T:System.ArgumentNullException" csharp="matrix != null" vb="matrix &lt;&gt; Nothing">matrix != null</requires>
      <exception cref="T:System.ArgumentNullException">matrix == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="rowIndex &gt;= 0 &amp;&amp; rowIndex &lt; matrix.GetLength(0)" vb="rowIndex &gt;= 0 AndAlso rowIndex &lt; matrix.GetLength(0)">rowIndex &gt;= 0 &amp;&amp; rowIndex &lt; matrix.GetLength(0)</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">rowIndex &lt; 0 || !(rowIndex &lt; matrix.GetLength(0))</exception>
    </member>
    <member name="P:whiteMath.General.TwoDimensionalArrayRow`1.IsReadOnly">
      <summary>
            Gets the flag indicating whether the row is read-only.
            </summary>
    </member>
    <member name="P:whiteMath.General.TwoDimensionalArrayRow`1.Parent">
      <summary>
            Gets the original two-dimensional array
            upon which the current object was created. 
            </summary>
    </member>
    <member name="P:whiteMath.General.TwoDimensionalArrayRow`1.ParentRow">
      <summary>
            Gets the index of the row in the parent
            two-dimensional which the current object
            wraps around. 
            </summary>
    </member>
    <member name="P:whiteMath.General.TwoDimensionalArrayRow`1.Count">
      <summary>
            Returns the number of elements in the row.
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.get_Count" inheritedFromTypeName="ICollection" csharp="result &gt;= 0" vb="result &gt;= 0">result &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:whiteMath.General.TwoDimensionalArrayRow`1.Item(System.Int32)">
      <summary>
            Gets or sets the value at the specified index of the collection.
            </summary>
      <param name="index">The index of the element to be got or set.</param>
      <returns>The value at the specified index of the collection.</returns>
      <getter>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.get_Item(System.Int32)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.get_Item(System.Int32)" inheritedFromTypeName="IList" csharp="index &lt; this.Count" vb="index &lt; Me.Count">index &lt; this.Count</requires>
      </getter>
      <setter>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.set_Item(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.set_Item(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &lt; this.Count" vb="index &lt; Me.Count">index &lt; this.Count</requires>
      </setter>
    </member>
    <member name="T:whiteMath.General.MultiDimensionalArrayExtensions">
      <summary>
            This class provides extension methods for multidimensional arrays.
            </summary>
    </member>
    <member name="M:whiteMath.General.MultiDimensionalArrayExtensions.IsSizeEqualTo(System.Array,System.Array)">
      <summary>
            Returns whether two arrays are
            equal in size within each dimension.
            </summary>
      <param name="matrix">The first array.</param>
      <param name="another">The second array.</param>
      <returns>
        <c>true</c> if the sizes are equal, <c>false</c> otherwise.</returns>
      <requires description="first" exception="T:System.ArgumentNullException" csharp="(() =&gt; {
    {
        whiteMath.General.MultiDimensionalArrayExtensions.&lt;&gt;c__DisplayClass1 local_0 = new whiteMath.General.MultiDimensionalArrayExtensions.&lt;&gt;c__DisplayClass1();
        local_0.first = first;
        local_0.second = second;
    }
    return local_0.first != null; })()" vb="(() =&gt; {
    whiteMath.General.MultiDimensionalArrayExtensions.&lt;&gt;c__DisplayClass1 local_0 = New whiteMath.General.MultiDimensionalArrayExtensions.&lt;&gt;c__DisplayClass1();
    local_0.first = first
    local_0.second = second
    return local_0.first &lt;&gt; Nothing; })()">(() =&gt; {
    {
        whiteMath.General.MultiDimensionalArrayExtensions.&lt;&gt;c__DisplayClass1 local_0 = new whiteMath.General.MultiDimensionalArrayExtensions.&lt;&gt;c__DisplayClass1();
        local_0.first = first;
        local_0.second = second;
    }
    return local_0.first != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">first == null</exception>
      <requires description="second" exception="T:System.ArgumentNullException" csharp="local_0.second != null" vb="local_0.second &lt;&gt; Nothing">local_0.second != null</requires>
      <exception cref="T:System.ArgumentNullException">second == null</exception>
    </member>
    <member name="M:whiteMath.General.MultiDimensionalArrayExtensions.IsElementwiseEqualTo``1(System.Array,System.Array,System.Collections.Generic.IEqualityComparer{``0},System.Boolean)">
      <summary>
            Returns whether the two arrays are
            of the same size and contain equal elements
            for every combination of indices. 
            </summary>
      <typeparam name="T">The type of elements in the array.</typeparam>
      <param name="first">The first array.</param>
      <param name="second">The second array.</param>
      <param name="equalityComparer">
            An equality comparer for the type <typeparamref name="T" />.
            If <c>null</c>, a default comparer will be used.
            </param>
      <param name="NaNEqualsNaN">
            If this flag is set to <c>true</c>, then any two <c>NaN</c> values
            (i.e. values not equal to themselves in terms of <see cref="!:equalityComparer" />)
            WILL be considered equal even though it is against the IEEE standard. 
            </param>
      <returns>
        <c>true</c> if two arrays are of the same size and contain equal
            elements for every combination of indices, <c>false</c> otherwise.
            </returns>
      <pure />
      <requires description="first" exception="T:System.ArgumentNullException" csharp="first != null" vb="first &lt;&gt; Nothing">first != null</requires>
      <exception cref="T:System.ArgumentNullException">first == null</exception>
      <requires description="second" exception="T:System.ArgumentNullException" csharp="second != null" vb="second &lt;&gt; Nothing">second != null</requires>
      <exception cref="T:System.ArgumentNullException">second == null</exception>
    </member>
    <member name="M:whiteMath.General.EnumerableExtensions.ToElementString``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Func{``0,System.String})">
      <summary>
            Constructs a string out of a sequence, enumerating its values through the separator.
            </summary>
      <typeparam name="T">The type of elements in the sequence.</typeparam>
      <param name="sequence">The calling sequence object.</param>
      <param name="separator">A string used to separate adjacent elements.</param>
      <param name="toString">
            A function that converts <typeparamref name="T" /> values to their string representations. 
            If <c>null</c>, standard <c>ToString()</c> function will be used.
            </param>
      <returns>A string which enumerates the values of the sequence through the separator string specified.</returns>
      <requires description="sequence" exception="T:System.ArgumentNullException" csharp="sequence != null" vb="sequence &lt;&gt; Nothing">sequence != null</requires>
      <exception cref="T:System.ArgumentNullException">sequence == null</exception>
    </member>
    <member name="M:whiteMath.General.EnumerableExtensions.IsEmpty``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Tests whether a sequence is empty, i.e. contains not a single element.
            </summary>
      <typeparam name="T">The type of elements in the sequence.</typeparam>
      <param name="sequence">The calling sequence object.</param>
      <returns>True if the sequence is empty, false otherwise.</returns>
    </member>
    <member name="M:whiteMath.General.EnumerableExtensions.Max``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})">
      <summary>
            Finds the maximum element in a generic sequence using the comparer object specified.
            </summary>
      <typeparam name="T">The type of elements in the sequence.</typeparam>
      <param name="sequence">The calling sequence object.</param>
      <param name="comparer">A comparer for the T type. Its Compare() method should return a positive value in case when the first compared element is bigger than the second.</param>
      <returns>The maximum element in the sequence.</returns>
    </member>
    <member name="M:whiteMath.General.EnumerableExtensions.Min``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})">
      <summary>
            Finds the minimum element in a generic sequence using the comparer object specified.
            The comparer is expected to return a positive number if the first element is bigger than the second.
            </summary>
      <typeparam name="T">The type of elements in the sequence.</typeparam>
      <param name="sequence">The calling sequence object.</param>
      <param name="comparer">A comparer for the T type. Its Compare() method should return a positive value in case when the first compared element is bigger than the second.</param>
      <returns>The minimum element in the sequence.</returns>
    </member>
    <member name="M:whiteMath.General.EnumerableExtensions.MinMax``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})">
      <summary>
            Finds the minimum and the maximum element in a sequence using the comparer specified.
            </summary>
      <typeparam name="T">The type of elements in the sequence.</typeparam>
      <param name="sequence">The calling sequence object.</param>
      <param name="comparer">A comparer for the T type. Its Compare() method should return a positive value in case when the first compared element is bigger than the second.</param>
      <returns>A logical point whose X value is equal to the minimum element, and Y value is equal to the maximum element of the sequence.</returns>
    </member>
    <member name="M:whiteMath.General.EnumerableExtensions.To2DArrayColumn``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Creates a single-column two-dimensional array from an enumerable.
            </summary>
      <typeparam name="T">The type of elements in the enumerable.</typeparam>
      <param name="enumerable">A sequence to be converted to 2D single-column array.</param>
      <returns>
            A single-column two dimensional array containing the elements of 
            <paramref name="enumerable" /> in increasing row order.
            </returns>
      <requires description="enumerable" exception="T:System.ArgumentNullException" csharp="enumerable != null" vb="enumerable &lt;&gt; Nothing">enumerable != null</requires>
      <exception cref="T:System.ArgumentNullException">enumerable == null</exception>
    </member>
    <member name="M:whiteMath.General.EnumerableExtensions.To2DArrayRow``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Creates a single-row two-dimensional array from an enumerable.
            </summary>
      <typeparam name="T">The type of elements in the enumerable.</typeparam>
      <param name="enumerable">A sequence to be converted to 2D single-row array.</param>
      <returns>
            A single-row two dimensional array containing the elements of 
            <paramref name="enumerable" /> in increasing column order.
            </returns>
      <requires description="enumerable" exception="T:System.ArgumentNullException" csharp="enumerable != null" vb="enumerable &lt;&gt; Nothing">enumerable != null</requires>
      <exception cref="T:System.ArgumentNullException">enumerable == null</exception>
    </member>
    <member name="M:whiteMath.General.HitTester`2.#ctor(System.Collections.Generic.IEnumerable{whiteMath.BoundedInterval{`0,`1}})">
      <summary>
            Initializes the <c>HitTester</c> with a sequence
            of non-intersecting intervals.
            </summary>
      <remarks>
            If the incoming <paramref name="intervalSequence" /> contains
            intersecting intervals, the behaviour of the <c>HitTester</c> is undefined.
            </remarks>
      <param name="intervalSequence">A sequence of non-intersecting intervals.</param>
      <requires description="intervalSequence" exception="T:System.ArgumentNullException" csharp="intervalSequence != null" vb="intervalSequence &lt;&gt; Nothing">intervalSequence != null</requires>
      <exception cref="T:System.ArgumentNullException">intervalSequence == null</exception>
      <requires description="The interval sequence should contain at least 1 interval for reasonable hit testing." exception="T:System.ArgumentException" csharp="Count&lt;whiteMath.BoundedInterval&lt;T, C&gt;&gt;(intervalSequence) &gt; 0" vb="Count(intervalSequence) &gt; 0">System.Linq.Enumerable.Count&lt;whiteMath.BoundedInterval&lt;T, C&gt;&gt;(intervalSequence) &gt; 0</requires>
      <exception cref="T:System.ArgumentException">!(intervalSequence.Count() &gt; 0)</exception>
    </member>
    <member name="M:whiteMath.General.HitTester`2.HitTest(`0)">
      <summary>
            Performs a hit test of a particular point,
            increasing the number of hits for the interval that contains it
            (if one has been found).
            </summary>
      <param name="point">The point to test.</param>
      <returns>True if the interval containing the point has been found, false otherwise.</returns>
    </member>
    <member name="M:whiteMath.General.HitTester`2.HitCount(whiteMath.BoundedInterval{`0,`1})">
      <summary>
            Returns the amount of hits registered for
            the specified interval.
            </summary>
      <param name="interval">The interval to test for amount of hits.</param>
      <returns>
            A non-negative amount of hits if the <c>Equals()</c>-equivalent interval 
            is registered in the tester; a negative value otherwise.</returns>
    </member>
    <member name="P:whiteMath.General.HitTester`2.LastFoundInterval">
      <summary>
            Returns a <c>Nullable</c> object with
            either the interval containing the last point passed to
            the <c>HitTest()</c> method, or <c>null</c>
            if the last hit test was unsuccessful.
            </summary>
    </member>
    <member name="P:whiteMath.General.HitTester`2.TotalHits">
      <summary>
            Returns the amount of total hits registered.
            </summary>
    </member>
    <member name="P:whiteMath.General.HitTester`2.Intervals">
      <summary>
            Returns the list of intervals associated with
            the current <c>HitTester&lt;<typeparamref name="T" />,<typeparamref name="C" />&gt;</c>,
            ordered by left bounds of the intervals.
            </summary>
    </member>
    <member name="P:whiteMath.General.HitTester`2.IntervalHitPairs">
      <summary>
            Returns the list of interval-hit pairs, ordered by 
            left bounds of the intervals.
            </summary>
    </member>
    <member name="T:whiteMath.General.EnumFattenedException">
      <summary>
            If an instance of this exception occurs somewhere,
            it seems to be a result of code refactoring, often an unforeseen addition to enums, so 
            feel free to immediately write to author's e-mail address and kick his butt.
            </summary>
    </member>
    <member name="T:whiteMath.General.LinkedListSorting">
      <summary>
            This class provides extension methods for sorting linked lists.
            </summary>
    </member>
    <member name="M:whiteMath.General.LinkedListSorting.IsSorted``1(System.Collections.Generic.LinkedList{``0},System.Collections.Generic.IComparer{``0})">
      <summary>
            Returns a boolean flag determining whether the linked list object passed
            is sorted according to the comparer passed.
            
            If the comparer is null, then the default comparer will be used (if exists).
            </summary>
      <typeparam name="T">The type of values stored in the list.</typeparam>
      <param name="list">The calling list object.</param>
      <param name="comparer">The comparer for the <typeparamref name="T" /> type. If null value is passed, then the default comparer will be used (if exists).</param>
      <returns>A boolean flag determining whether the linked list object passed
            is sorted according to the comparer passed.</returns>
    </member>
    <member name="M:whiteMath.General.LinkedListSorting.InsertionSort``1(System.Collections.Generic.LinkedList{``0},System.Collections.Generic.IComparer{``0})">
      <summary>
            Performs the in-place linked list sorting using an insertion sort algorithm.
            The time is O(n^2).
            </summary>
      <typeparam name="T">The values stored in the list.</typeparam>
      <param name="list">The calling linked list to be sorted.</param>
      <param name="comparer">The comparer for the <typeparamref name="T" /> type. If null is passed, the default comparer will be used (if exists).</param>
    </member>
    <member name="M:whiteMath.General.ListFillingExtensions.FillByAssign``1(System.Collections.Generic.IList{``0},``0)">
      <summary>
            Overwrites the entire list with the value specified.
            </summary>
      <remarks>
            The filling is made by assign operation, which means, no new elements
            will be added to the collection using <c>Add()</c> method.
            </remarks>
      <typeparam name="T">The type of elements in the list.</typeparam>
      <param name="list">The list reference.</param>
      <param name="value">The value to fill the list with.</param>
    </member>
    <member name="M:whiteMath.General.ListFillingExtensions.FillByAssign``1(System.Collections.Generic.IList{``0},whiteMath.Randoms.IRandomBounded{``0},``0,``0)">
      <summary>
            Overwrites the entire list using a random number generator
            which would be used to generate random numbers in the interval
            [<paramref name="min" />; <paramref name="max" />).
            </summary>
      <remarks>
            The filling is made by assign operation, which means, no new elements
            will be added to the collection using <c>Add()</c> method.
            </remarks>
      <typeparam name="T">The type of elements in the list.</typeparam>
      <param name="list">The list reference.</param>
      <param name="randomGenerator">The random generator to generate random numbers for the list.</param>
      <param name="min">The minimum inclusive value to generate.</param>
      <param name="max">The maximum exclusive value to generate.</param>
    </member>
    <member name="M:whiteMath.General.ListFillingExtensions.FillByAssign``1(System.Collections.Generic.IList{``0},System.Func{System.Int32,``0})">
      <summary>
            Overwrites the entire list by incorporating current element's index.
            </summary>
      <remarks>
            The filling is made by assign operation, which means, no new elements
            will be added to the collection using <c>Add()</c> method.
            </remarks>
      <typeparam name="T">The type of elements in the list.</typeparam>
      <param name="list">The list reference.</param>
      <param name="function">The function mapping integer indices to <typeparamref name="T" /> values.</param>
    </member>
    <member name="M:whiteMath.General.ListFillingExtensions.FillByAssign``1(System.Collections.Generic.IList{``0},System.Func{``0,``0},``0)">
      <summary>
            Overwrites the entire list by incorporating the previous element's value.
            The first element of the list should be thus explicitly provided.
            </summary>
      <remarks>
            The filling is made by assign operation, which means, no new elements
            will be added to the collection using <c>Add()</c> method.
            </remarks>
      <typeparam name="T">The type of elements in the list.</typeparam>
      <param name="list">The list reference.</param>
      <param name="function">The function mapping <typeparamref name="T" />--&gt;<typeparamref name="T" /></param>
      <param name="firstElement">
            The first element of the list. The next element would be 
            created using <c><paramref name="function" /></c> 
            and this element as an argument.
            </param>
    </member>
    <member name="M:whiteMath.General.ListFillingExtensions.FillByAssign``1(System.Collections.Generic.IList{``0},System.Func{``0,System.Int32,``0},``0)">
      <summary>
            Overwrites the entire list by incorporating both current element's index and the value of
            the previous element. The first element of the list should be explicitly provided.
            </summary>
      <remarks>
            The filling is made by assign operation, which means, no new elements
            will be added to the collection using <c>Add()</c> method.
            </remarks>
      <typeparam name="T">The type of elements in the list.</typeparam>
      <param name="list">The list reference.</param>
      <param name="function">The function mapping the current index AND the previous list element --&gt; to the CURRENT list element.</param>
      <param name="firstElement">The first element of the list. The next element would be created using the function passed with this element as an argument.</param>
    </member>
    <member name="M:whiteMath.General.ListSorting.IsSorted``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})">
      <summary>
            Checks whether the sequence of objects is ascending sorted, uses the comparer passed
            for sequence elements, or, if a null value is specified, the standard system
            comparer (if exists).
            
            Takes O(n) operations to check if a sequence implements IList(T).
            </summary>
      <typeparam name="T">The type of elements in the sequence.</typeparam>
      <param name="sequence">The calling IEnumerable(T) object.</param>
      <param name="comparer">Optional comparer for sequence elements. If null value is specified, the standard system comparer would be used (if exists).</param>
      <returns>True if the sequence is ascending sorted according to the comparer specified, false otherwise.</returns>
    </member>
    <member name="M:whiteMath.General.ListSorting.getPrattSequence(System.Int32)">
      <summary>
            Возвращает последовательность Пратта для сортировки Шелла.
            </summary>
    </member>
    <member name="M:whiteMath.General.ListSorting.SortShell``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0},System.Collections.Generic.IList{System.Int32})">
      <summary>
            Invokes a quick shellsort algorithm on a list.
            Has O(n^2) asympthotics, but usually works much faster than insertion sort.
            </summary>
      <typeparam name="T">The type of elements in the list.</typeparam>
      <param name="list">The invoking list object.</param>
      <param name="comparer">The comparer for list elements.</param>
      <param name="shellSequence">The Shell sequence used to determine the sorting step. Its first element should always be '1', and the sequence should grow monotonously. If 'null' parameter is passed, a certain quick sequence would be used automatically.</param>
    </member>
    <member name="M:whiteMath.General.ListSorting.SortMerge``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
      <summary>
            Invokes a quick mergesort algorithm on a list.
            Works with O(n*log(n)) speed.
            </summary>
      <typeparam name="T">The type of elements in the list.</typeparam>
      <param name="list">A list to be sorted.</param>
      <param name="comparer">The comparer for list elements.</param>
    </member>
    <member name="M:whiteMath.General.SequenceExtensions.toListOfIndexValuePairs``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            For ordered sequences, returns a list of pairs with first element being the index,
            and second being one of the sequence elements. The order of elements is preserved.
            </summary>
      <typeparam name="T">The type of elements in the ordered sequence.</typeparam>
      <param name="sequence">The calling ordered sequence.</param>
      <returns>returns a list of pairs with first element being the index, and second being one of the sequence elements. The order of elements is preserved.</returns>
    </member>
    <member name="M:whiteMath.General.SequenceExtensions.toListOfIndexValuePairs``2(System.Collections.Generic.IEnumerable{``0},System.Func{System.Int32,``0,``1})">
      <summary>
            For ordered sequences, returns a list of pairs with first element being the index,
            and second being the result of selector function applied to the value and current index. The order of elements is preserved.
            </summary>
      <typeparam name="TSource">The type of elements in the source sequence.</typeparam>
      <typeparam name="TResult">The type of values in the key-value pairs in the result sequence.</typeparam>
      <param name="sequence">The calling ordered sequence.</param>
      <param name="selector">The selector function transforming elements from <typeparamref name="TSource" /> to <typeparamref name="TResult" />.</param>
      <returns>
            A list of pairs with first element being the index and second being the result of selector function applied to the value and current index. 
            The order of elements is preserved.
            </returns>
    </member>
    <member name="M:whiteMath.General.SequenceExtensions.toListOfIndexValuePoints``2(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Converts a numeric sequence into a list of index-value points, where index has the same numeric type
            as the elements of the sequence.
            </summary>
      <typeparam name="T">The type of elements in the sequence.</typeparam>
      <typeparam name="C">A calculator for the <typeparamref name="T" /> type.</typeparam>
      <param name="sequence">The calling sequence object.</param>
      <returns>a list of index-value points, where index has the same numeric type as the elements of the sequence.</returns>
    </member>
    <member name="T:whiteMath.General.NaNForceEqualityComparer`1">
      <summary>
            Represents a wrapper around an arbitrary equality comparer,
            modifying it for the <c>NaN</c> case: the wrapping comparer will
            return whatever the underlying comparer returns, except for the
            case when both compared objects are <c>NaN</c>s (by definition, not equal to 
            anything, even themselves). In this case, the wraping equality comparer
            will return <c>true</c>.
            </summary>
      <typeparam name="T">The type of elements to be compared for equality.</typeparam>
    </member>
    <member name="M:whiteMath.General.NaNForceEqualityComparer`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Constructs a <see cref="T:whiteMath.General.NaNForceEqualityComparer`1" /> using
            an <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> comparer object.
            </summary>
      <param name="parent">
            An <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> comparer object
            which will be used for equality comparison in every case except
            when both compared values are <c>NaN</c>'s (not equal to themselves - in
            terms of the parent comparer).
            In that case, the constructed comparer will return <c>true</c>.
            </param>
    </member>
    <member name="M:whiteMath.General.NaNForceEqualityComparer`1.Equals(`0,`0)">
      <summary>
            Compares two <typeparamref name="T" /> objects and returns whatever 
            the <see cref="P:whiteMath.General.NaNForceEqualityComparer`1.ParentEqualityComparer" /> returns, except for the case when
            <see cref="P:whiteMath.General.NaNForceEqualityComparer`1.ParentEqualityComparer" /> returns <c>false</c> for 
            self-comparison of both <paramref name="first" /> and <paramref name="second" />.
            Since that means that both values are <c>NaN</c> (by definition), the 
            comparer will intentionally return <c>true</c> (because that's what it does by design).
            </summary>
      <param name="first">The first object to be compared for equality.</param>
      <param name="second">The second object to be compared for equality.</param>
      <returns>
            The result of comparison by <see cref="P:whiteMath.General.NaNForceEqualityComparer`1.ParentEqualityComparer" /> if at least one of the 
            objects is not <c>NaN</c>, or <c>true</c> otherwise.
            </returns>
    </member>
    <member name="M:whiteMath.General.NaNForceEqualityComparer`1.GetHashCode(`0)">
      <summary>
            Returns whatever <see cref="P:whiteMath.General.NaNForceEqualityComparer`1.ParentEqualityComparer" />
            returns in the <see cref="M:whiteMath.General.NaNForceEqualityComparer`1.GetHashCode(`0)" /> for this value.
            </summary>
      <param name="value">The value whose hash code is to be calculated.</param>
      <returns>
            Whatever <see cref="P:whiteMath.General.NaNForceEqualityComparer`1.ParentEqualityComparer" /> returns in the <see cref="M:whiteMath.General.NaNForceEqualityComparer`1.GetHashCode(`0)" /> 
            for this value.
            </returns>
    </member>
    <member name="P:whiteMath.General.NaNForceEqualityComparer`1.ParentEqualityComparer">
      <summary>
            Gets the parent equality comparer associated with
            the current object.
            </summary>
    </member>
    <member name="T:whiteMath.General.DoubleInfo">
      <summary>
            This structure provides information about
            a double number, i.e. its sign, exponent and mantissa.
            </summary>
    </member>
    <member name="P:whiteMath.General.DoubleInfo.Sign">
      <summary>
            Returns the sign of the number in integer form.
            </summary>
    </member>
    <member name="T:whiteMath.General.BinaryHeap`1">
      <summary>
            Represents a simple, dynamic-size binary heap which can be used
            as a priority queue for different purposes.
            
            Element removal is O(log(n)), element insertion is
            O(N) if the current queue capacity is insufficient for the insertion,
            O(log(n)) otherwise.
            </summary>
      <typeparam name="T">The type of elements stored in the heap.</typeparam>
    </member>
    <member name="T:whiteMath.General.IPriorityQueue`1">
      <summary>
            The generic interface for priority queues
            which supports the operations for element inserting
            and removing the maximum element.
            </summary>
      <typeparam name="T">The type of elements in the priority queue.</typeparam>
    </member>
    <member name="M:whiteMath.General.IPriorityQueue`1.Clear">
      <summary>
            Removes all elements from the queue.
            </summary>
    </member>
    <member name="M:whiteMath.General.IPriorityQueue`1.Insert(`0)">
      <summary>
            Inserts an element into the queue. 
            </summary>
      <param name="value">The value to be inserted.</param>
    </member>
    <member name="M:whiteMath.General.IPriorityQueue`1.Pop">
      <summary>
            Removes the maximum element from the queue and returns its value.
            If the sequence is empty, should throw an InvalidOperationException.
            </summary>
      <returns>The maximum element in the queue.</returns>
    </member>
    <member name="M:whiteMath.General.IPriorityQueue`1.PeekMax">
      <summary>
            Returns the value of the maximum element without removing it.
            If the sequence is empty, should throw an InvalidOperationException.
            </summary>
      <returns>The maximum element in the queue.</returns>
    </member>
    <member name="P:whiteMath.General.IPriorityQueue`1.Count">
      <summary>
            Gets the total element count in the queue.
            </summary>
    </member>
    <member name="P:whiteMath.General.IPriorityQueue`1.Comparer">
      <summary>
            Returns the instance of the comparer
            used to compare elements of type <typeparamref name="T" />.
            </summary>
    </member>
    <member name="P:whiteMath.General.IPriorityQueue`1.IsEmpty">
      <summary>
            Returns the flag determining whether the queue is empty.
            </summary>
    </member>
    <member name="M:whiteMath.General.BinaryHeap`1.#ctor">
      <summary>
            Creates an instance of a new empty binary heap
            using the default comparer for <typeparamref name="T" /> type.
            </summary>
    </member>
    <member name="M:whiteMath.General.BinaryHeap`1.#ctor(System.Collections.Generic.IComparer{`0})">
      <summary>
            Creates an instance of a new empty binary heap
            using the IComparer object passed to compare the values of type <typeparamref name="T" />.
            </summary>
      <param name="comparer">The comparer for the <typeparamref name="T" /> type.</param>
    </member>
    <member name="M:whiteMath.General.BinaryHeap`1.#ctor(System.Collections.Generic.IList{`0})">
      <summary>
            Creates an instance of a new binary heap
            from the list containing <typeparamref name="T" /> values and using
            (if available) the default comparer for <typeparamref name="T" /> type.
            
            If there are N elements in the list, the time of initializing is O(N).
            </summary>
      <param name="list">The list containing the values to insert into the heap.</param>
    </member>
    <member name="M:whiteMath.General.BinaryHeap`1.#ctor(System.Collections.Generic.IList{`0},System.Collections.Generic.IComparer{`0})">
      <summary>
            Creates an instance of a new binary heap
            from the list containing <typeparamref name="T" /> values and using
            the IComparer object to compare the values of type <typeparamref name="T" />.
            
            If there are N elements in the list, the time of initializing is O(N).
            </summary>
      <param name="list">The list containing the values to insert into the heap.</param>
      <param name="comparer">The comparer for the <typeparamref name="T" /> type.</param>
    </member>
    <member name="M:whiteMath.General.BinaryHeap`1.Clear">
      <summary>
            Clears the heap so that it does not contain any elements anymore.
            </summary>
    </member>
    <member name="M:whiteMath.General.BinaryHeap`1.PeekMax">
      <summary>
            Returns the value of the maximal (according to the comparer used)
            element in the heap without actually removing it.
            </summary>
      <returns>The value of the maximal element in the heap without removing it.</returns>
    </member>
    <member name="M:whiteMath.General.BinaryHeap`1.Pop">
      <summary>
            Removes the maximal (according to the comparer used)
            element in the heap and returns its value.
            </summary>
      <returns>The value of the removed maximal element.</returns>
    </member>
    <member name="M:whiteMath.General.BinaryHeap`1.Insert(`0)">
      <summary>
            Inserts an element into the queue.
            </summary>
      <param name="value">The value to be inserted.</param>
    </member>
    <member name="M:whiteMath.General.BinaryHeap`1.heapify">
      <summary>
            Кучифицирует все дерево за логарифмическое время.
            </summary>
    </member>
    <member name="M:whiteMath.General.BinaryHeap`1.heapifyUp(System.Int32)">
      <summary>
            Кучифицирует элемент с определенным индексом вверх.
            Сравнивает с родителем - и, если дендрить, так дендрить.
            </summary>
    </member>
    <member name="M:whiteMath.General.BinaryHeap`1.heapifyDown(System.Int32)">
      <summary>
            Кучифицирует элемент с определенным индексом вниз.
            Сравнивает с детьми - и меняет местами c большим из детей.
            Дальше рекуррентно.
            </summary>
    </member>
    <member name="M:whiteMath.General.BinaryHeap`1.isInHeap(System.Int32)">
      <summary>
            Есть ли в куче элемент с таким индексом.
            </summary>
    </member>
    <member name="M:whiteMath.General.BinaryHeap`1.parent(System.Int32)">
      <summary>
            Индекс родителя i-го элемента.
            </summary>
    </member>
    <member name="M:whiteMath.General.BinaryHeap`1.leftChild(System.Int32)">
      <summary>
            Индекс левого ребенка i-го элемента. 
            </summary>
    </member>
    <member name="M:whiteMath.General.BinaryHeap`1.rightChild(System.Int32)">
      <summary>
            Индекс правого ребенка i-го элемента.
            </summary>
    </member>
    <member name="P:whiteMath.General.BinaryHeap`1.Count">
      <summary>
            Returns the total element count in the heap.
            </summary>
    </member>
    <member name="P:whiteMath.General.BinaryHeap`1.IsEmpty">
      <summary>
            Returns the value determining whether the heap is empty.
            </summary>
    </member>
    <member name="T:whiteMath.General.ITreeNode`1">
      <summary>
            The generic interface for tree structure nodes.
            </summary>
      <typeparam name="T">The type of node values.</typeparam>
    </member>
    <member name="M:whiteMath.General.ITreeNode`1.GetChildAt(System.Int32)">
      <summary>
            Gets the child node with index i.
            </summary>
      <param name="i">The index of the child node.</param>
      <returns>The child node with index i.</returns>
    </member>
    <member name="P:whiteMath.General.ITreeNode`1.HasChildren">
      <summary>
            Returns the value determining whether the node has any children.
            </summary>
    </member>
    <member name="P:whiteMath.General.ITreeNode`1.HasParent">
      <summary>
            Returns the value determining whether the node has a parent.
            </summary>
    </member>
    <member name="P:whiteMath.General.ITreeNode`1.ChildrenCount">
      <summary>
            Returns the value determining how many children the node has.
            </summary>
    </member>
    <member name="P:whiteMath.General.ITreeNode`1.Parent">
      <summary>
            Gets the parent node of the current node.
            If the node is the root node (i.e. has no parent),
            should return null.
            </summary>
    </member>
    <member name="P:whiteMath.General.ITreeNode`1.Value">
      <summary>
            Gest the value stored in the node.
            </summary>
    </member>
    <member name="M:whiteMath.General.BinomialHeap`1.mergeSubtrees(whiteMath.General.TreeNode{`0},whiteMath.General.TreeNode{`0})">
      <summary>
            Сливает два биномиальных дерева и возвращает ссылку на нового родителя.
            </summary>
    </member>
    <member name="P:whiteMath.General.BinomialHeap`1.Comparer">
      <summary>
            Returns the comparer for elements in the heap.
            </summary>
    </member>
    <member name="P:whiteMath.General.BinomialHeap`1.Count">
      <summary>
            Returns the overall element count in the heap.
            Takes O(N) time to perform.
            </summary>
    </member>
    <member name="M:whiteMath.General.TreeNodeSmart`1.descendantAdded">
      <summary>
            Событие, вызываемое для родителя при добавлении потомка.
            </summary>
    </member>
    <member name="M:whiteMath.General.TreeNodeSmart`1.descendantRemoved">
      <summary>
            Событие, вызываемое для родителя при удалении потомка.
            </summary>
    </member>
    <member name="M:whiteMath.General.TreeNodeSmart`1.childOrderChanged(System.Int32,System.Int32)">
      <summary>
            Событие, вызываемое для родителя при изменении высоты ребенка.
            </summary>
      <param name="oldOrder">Старая высота ребенка</param>
      <param name="newOrder">Новая высота ребенка</param>
    </member>
    <member name="M:whiteMath.General.TreeNodeSmart`1.SwapWithChild(System.Int32)">
      <summary>
            Swaps the node with its child of index <paramref name="i" />.
            </summary>
      <param name="i">The number of child index to swap with.</param>
    </member>
    <member name="P:whiteMath.General.TreeNodeSmart`1.DescendantsCount">
      <summary>
            Gets the amount of total descendants of the current root, excluding the current.
            The time of getting is O(1).
            </summary>
    </member>
    <member name="P:whiteMath.General.TreeNodeSmart`1.Parent">
      <summary>
            Gets the parent node for the current node.
            If no parent node is present, null value is returned.
            </summary>
    </member>
    <member name="P:whiteMath.General.TreeNodeSmart`1.Value">
      <summary>
            Gets the value stored in the node.
            </summary>
    </member>
    <member name="P:whiteMath.General.TreeNodeSmart`1.IsRoot">
      <summary>
            Returns the value determining if the current node is a root node for 
            some tree. It is true if the node does not have a parent.
            </summary>
    </member>
    <member name="P:whiteMath.General.TreeNodeSmart`1.TreeRoot">
      <summary>
            Gets the tree root which could be either this node - if it has no parents -
            or the the highest grandparent who has no parent node.
            </summary>
    </member>
    <member name="T:whiteMath.General.PriorityQueueExtensions">
      <summary>
            Class providing different extension methods for priority queues.
            </summary>
    </member>
    <member name="M:whiteMath.General.PriorityQueueExtensions.ToSortedArray``1(whiteMath.General.IPriorityQueue{``0},System.Boolean)">
      <summary>
            Removes all of the elements from the priority queue
            and forms the sorted (according to the queue IComparer) array.
            
            The flag is received determining whether the array should be sorted
            in the reverse order.
            
            The time is O(N*logN).
            </summary>
      <param name="queue">The calling priority queue object.</param>
      <param name="reverseSorted">The boolean flag determining whether the array should be sorted in the reverse order.</param>
      <returns>An array containing all of the queue elements in sorted order.</returns>
    </member>
    <member name="T:whiteMath.General.TreeNodeExtensions">
      <summary>
            Provides methods which work for any kind of tree nodes implementing the ITreeNode(T) interface.
            Specialized versions provided inside the classes are expected to be more effective.
            </summary>
    </member>
    <member name="M:whiteMath.General.TreeNodeExtensions.DescendantsCount``1(whiteMath.General.ITreeNode{``0})">
      <summary>
            Gets the total amount of node's descendants excluding himself.
            The time of calculation is O(n).
            </summary>
      <typeparam name="T">The type of value stored in the node.</typeparam>
      <param name="node">The calling node object.</param>
      <returns>The total amount of node's descendants excluding himself.</returns>
    </member>
    <member name="M:whiteMath.General.TreeNodeExtensions.GetTreeRoot``1(whiteMath.General.ITreeNode{``0})">
      <summary>
            Follows the chain of parent references to return the root.
            The latter may be equal to the calling node object if the are no parents.
            </summary>
      <typeparam name="T">The type of node values.</typeparam>
      <param name="node">The calling node object.</param>
      <returns>The root node of the tree.</returns>
    </member>
    <member name="M:whiteMath.General.TreeNodeExtensions.TreeHeight``1(whiteMath.General.ITreeNode{``0})">
      <summary>
            Returns the overall tree height in which
            the node is located.
            
            The time is O(N).
            </summary>
      <typeparam name="T">The type of node values.</typeparam>
      <param name="node">The calling node object.</param>
      <returns>The overall tree height in which the node is located.</returns>
    </member>
    <member name="M:whiteMath.General.TreeNodeExtensions.ChainLength``1(whiteMath.General.ITreeNode{``0})">
      <summary>
            Returns the length of the longest chain from the root to a leaf which
            passes through the current node.
            </summary>
      <typeparam name="T">The type of node values.</typeparam>
      <param name="node">The calling node object.</param>
      <returns>The length of the longest chain from the root to a leaf which
            passes through the current node.</returns>
    </member>
    <member name="M:whiteMath.General.TreeNodeExtensions.LengthToTheRoot``1(whiteMath.General.ITreeNode{``0})">
      <summary>
            Returns the length of the path from a tree node to the root.
            If the node is a root itself, the path length is zero.
            </summary>
      <typeparam name="T">The type of node value.</typeparam>
      <param name="node">The calling node object.</param>
      <returns>The length of the path from the node to the tree root. If the node is a root, the path length is zero.</returns>
    </member>
    <member name="M:whiteMath.General.TreeNodeExtensions.Height``1(whiteMath.General.ITreeNode{``0})">
      <summary>
            Gets the height of the node, that is, the length of the path to its
            farthermost descendant.
            
            The time of operation is O(N).
            </summary>
      <typeparam name="T">The type of value stored in the node.</typeparam>
      <param name="node">The calling node object.</param>
      <returns>The total amount of node's descendants excluding himself.</returns>
    </member>
    <member name="M:whiteMath.General.TreeNodeExtensions.traverseInfix``1(whiteMath.General.ITreeNode{``0},System.Int32)">
      <summary>
            Performs the infix traversing of the tree node and returns
            the list filled up with nodes in the traversion order.
            
            The <paramref name="prevIndex" /> parameted is the index of child node
            after which the currently processed node should be traversed.
            
            If <paramref name="prevIndex" /> is negative, the current node will be traverse first.
            Else, if it is more than or equals to the current node's children amount,
            the current node will be traversed last.
            
            Works only for any kind of trees.
            </summary>
      <param name="prevIndex" />
      <returns>List that would be filled up with nodes during the traversing.</returns>
    </member>
    <member name="M:whiteMath.General.TreeNodeExtensions.traversePrefix``1(whiteMath.General.ITreeNode{``0})">
      <summary>
            Performs the prefix traversing of the tree node and fills up
            the list passed with nodes in the traversion order.
            
            The node is traversed first, then all of its children, beginning with the leftmost,
            are recursively traversed.
            
            Works for any kind of trees.
            </summary>
      <returns>List that would be filled up with nodes during the traversing.</returns>
    </member>
    <member name="M:whiteMath.General.TreeNodeExtensions.traversePostfix``1(whiteMath.General.ITreeNode{``0})">
      <summary>
            Performs the postfix traversing of the tree node and returns the list 
            filled up with nodes in the traversion order.
            
            The node is traversed last, first all of its children, beginning with the leftmost,
            are recursively traversed.
            
            Works for any kind of trees.
            </summary>
      <returns>List that would be filled up with nodes during the traversing.</returns>
    </member>
    <member name="M:whiteMath.General.PointExtensions.convertToPairOfLists``1(System.Collections.Generic.IList{whiteMath.General.Point{``0}})">
      <summary>
            Converts a list of points to a point which contains two single-dimensional arrays - an array of X's and an array of Y's.
            </summary>
      <typeparam name="T">The type of point coordinates.</typeparam>
      <param name="list">The list object containing points of type <typeparamref name="T" />.</param>
      <returns>The point object whose X coordinate is a list of X's and Y coordinate is a list of Y's.</returns>
    </member>
    <member name="M:whiteMath.General.PointExtensions.convertToListOfPairs``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0})">
      <summary>
            Makes an array of point objects from two arrays containing X coordinates and Y coordinates respectively.
            Make sure that no array is null and that they have the same length. Otherwise,
            a NullReferenceException or an ArgumentException will be thrown.
            </summary>
      <typeparam name="T">The type of point elements.</typeparam>
      <param name="xValues">The array containing X coordinates.</param>
      <param name="yValues">The array containing Y coordinates.</param>
      <returns>An array of points with X coordinate storing the respective value of <paramref name="xValues" /> and Y coordinate storing the respective value of <paramref name="yValues" />.</returns>
    </member>
    <member name="M:whiteMath.General.PointExtensions.convertToMatrixRows``2(System.Collections.Generic.IList{whiteMath.General.Point{``0}})">
      <summary>
            Converts a list of points to a matrix of size (Nx2) which rows are exactly the point coordinates.
            </summary>
      <typeparam name="T">The type of elements in the matrix.</typeparam>
      <typeparam name="C">The calculator for the matrix elements type.</typeparam>
      <param name="list">The list object containing points of type <typeparamref name="T" />.</param>
      <returns>The matrix of size (Nx2) which rows are exactly the point coordinates.</returns>
    </member>
    <member name="T:whiteMath.General.PotentialResult`1">
      <summary>
            Represents a structure which is returned from the functions
            which can succeed in calculating some value or fail to do that.
            </summary>
      <typeparam name="T">The type of result which can be potentially calculated by a function.</typeparam>
    </member>
    <member name="M:whiteMath.General.PotentialResult`1.CreateSuccess(`0)">
      <summary>
            Creates a <see cref="T:whiteMath.General.PotentialResult`1" /> object
            from a successfully calculated value.
            </summary>
      <param name="value">The value to store in the <see cref="T:whiteMath.General.PotentialResult`1" />.</param>
      <returns>A <see cref="T:whiteMath.General.PotentialResult`1" /> object with a usable value and <c>Success</c> field set to <c>true</c>.</returns>
    </member>
    <member name="M:whiteMath.General.PotentialResult`1.CreateFailure">
      <summary>
            Creates a <see cref="T:whiteMath.General.PotentialResult`1" /> object
            which signalizes a failure.
            </summary>
      <returns>A <see cref="T:whiteMath.General.PotentialResult`1" /> object with a non-usable value and <c>Success</c> field set to <c>false</c>.</returns>
    </member>
    <member name="P:whiteMath.General.PotentialResult`1.Success">
      <summary>
            Gets a flag which signalizes whether the <see cref="P:whiteMath.General.PotentialResult`1.Value" /> of the 
            current object was calculated successfully and can be used.
            </summary>
    </member>
    <member name="P:whiteMath.General.PotentialResult`1.Value">
      <summary>
            Gets the value calculated by the function.
            If <see cref="P:whiteMath.General.PotentialResult`1.Success" /> field is <c>false</c>, this
            property will throw an <see cref="T:System.InvalidOperationException" />.
            </summary>
      <getter>
        <requires exception="T:System.InvalidOperationException" csharp="this.Success" vb="Me.Success">this.Success</requires>
      </getter>
      <exception cref="T:System.InvalidOperationException">!(this.Success)</exception>
    </member>
    <member name="M:whiteMath.General.TreeNode`1.SwapWithChild(System.Int32)">
      <summary>
            Swaps the node with its child of index <paramref name="i" />.
            </summary>
      <param name="i">The number of child index to swap with.</param>
    </member>
    <member name="P:whiteMath.General.TreeNode`1.Value">
      <summary>
            Gets the value stored in the node.
            </summary>
    </member>
    <member name="P:whiteMath.General.TreeNode`1.Parent">
      <summary>
            Gets the parent of the node if it exists.
            </summary>
    </member>
    <member name="M:whiteMath.Geometry.AffineTransform.GetAffineTransformMatrix(whiteMath.Geometry.VectorD,whiteMath.Geometry.VectorD,System.Double,System.Double,System.Func{whiteMath.Matrices.Matrix{System.Double,whiteMath.CalcDouble},whiteMath.Vector{System.Double,whiteMath.CalcDouble},whiteMath.Vector{System.Double,whiteMath.CalcDouble}})">
      <summary>
            Returns the Matrix for the Affine transformation that 
            transforms one vector to another taking their starting points into account.
            </summary>
      <param name="firstVector">The first vector.</param>
      <param name="secondVector">The second vector.</param>
      <param name="equationSystemSolverFunction">The function that, being provided with matrix 
            square matrix of size N (containing the unknown parameters' coefficients) and a vector of 
            free terms having length N, will return the vector of unknown parameters.
            May be null, an internal function will be used in this case.
            </param>
      <param name="c">The first free term of transformation matrix. Can be set to any value, affects the inverse matrix calculation precision.</param>
      <param name="d">THe second free term of transformation matrix. Can be set to any value, affects the inverse matrix calculation precision.</param>
      <returns>An affine transform matrix that would convert the <paramref name="firstVector" /> to the <paramref name="secondVector" />.</returns>
    </member>
    <member name="M:whiteMath.Geometry.Figures.RegularPolygonInscribedIntoCircle(System.Int32,whiteMath.Geometry.PointD,System.Double,System.Double)">
      <summary>
            Returns a list of regular polygon's vertices, which has a 
            specified amount of sides and is inscribed into
            a circle of certain radius and center point.
            
            The first vertice will be located at specified angle (counting counterclockwise)
            from the circle's rightmost point.
            </summary>
      <param name="sideCount">The total amount of polygon's sides. May be equal to 2 (then the resulting vertices will make up a line).</param>
      <param name="circleCenter">The center of the surrounding circle.</param>
      <param name="circleRadius">The radius of the surrounding circle.</param>
      <param name="initialAngle">The angle (in radians, counting counterclockwise from the circle's rightmost point) at which the first vertice will be located.</param>
      <returns>The list of regular polygon's vertices.</returns>
    </member>
    <member name="T:whiteMath.Geometry.PointD">
      <summary>
            Structure that represents a point whose coordinates
            are double-precision values.
            </summary>
    </member>
    <member name="P:whiteMath.Geometry.PointD.X">
      <summary>
            Gets the X coordinate of the point.
            </summary>
    </member>
    <member name="P:whiteMath.Geometry.PointD.Y">
      <summary>
            Gets the Y coordinate of the point.
            </summary>
    </member>
    <member name="P:whiteMath.Geometry.PointD.ComparerOnX">
      <summary>
            Returns the comparer that compares PointD objects on their X values.
            </summary>
    </member>
    <member name="P:whiteMath.Geometry.PointD.ComparerOnY">
      <summary>
            Returns the comparer that compares PointD objects on their Y values.
            </summary>
    </member>
    <member name="T:whiteMath.Geometry.VectorD">
      <summary>
            Represents a vector which is built on top of two
            points (PointD objects).
            </summary>
    </member>
    <member name="M:whiteMath.Geometry.VectorD.VectorScaledNewStartPoint(System.Double,whiteMath.Geometry.PointD)">
      <summary>
            Vector with new start point
            with the length scaled by specified double factor.
            </summary>
      <param name="coefficient">Should be from 0 to 1.</param>
      <param name="newStartPoint">New start point.</param>
    </member>
    <member name="M:whiteMath.Geometry.VectorD.VectorScaledNewEndPoint(System.Double,whiteMath.Geometry.PointD)">
      <summary>
            Vector with new end point
            with the length scaled by specified double factor.
            </summary>
      <param name="coefficient">Should be from 0 to 1.</param>
      <param name="newEndPoint">New end point.</param>
    </member>
    <member name="M:whiteMath.Geometry.VectorD.VectorNewStartPoint(whiteMath.Geometry.PointD)">
      <summary>
            Returns a vector of same length
            with a new start point.
            </summary>
      <param name="newStartPoint">The new starting point for the vector.</param>
      <returns>A vector with a new starting point.</returns>
    </member>
    <member name="M:whiteMath.Geometry.VectorD.VectorNewEndPoint(whiteMath.Geometry.PointD)">
      <summary>
            Returns a vector of same length
            with a new end point.
            </summary>
      <param name="newEndPoint">The new ending point for the vector.</param>
      <returns>A vector with the new ending point.</returns>
    </member>
    <member name="M:whiteMath.Geometry.VectorD.VectorRotatedNewStartPoint(System.Double,whiteMath.Geometry.PointD)">
      <summary>
            Returns a vector rotated on the specified angle
            with new start point.
            </summary>
    </member>
    <member name="M:whiteMath.Geometry.VectorD.VectorRotatedNewEndPoint(System.Double,whiteMath.Geometry.PointD)">
      <summary>
            Returns a vector rotated on the specified angle
            with new end point.
            </summary>
    </member>
    <member name="M:whiteMath.Geometry.VectorD.multiplyScalar(whiteMath.Geometry.VectorD)">
      <summary>
            Returns the scalar product of two vectors.
            
            The scalar product of vectors A and B is equal to the value |A|*|B|*sin(phi),
            where phi is the angle between A to B.
            </summary>
      <param name="another">Another vector to find the scalar product to find the scalar product between the current vector and the specified.</param>
      <returns>The scalar product of two vectors.</returns>
    </member>
    <member name="M:whiteMath.Geometry.VectorD.multiplyWedge(whiteMath.Geometry.VectorD)">
      <summary>
            Returns the wedge product of
            two vectors.
            
            The wedge product of vectors A and B is equal to the value |A|*|B|*sin(phi),
            where phi is the angle of rotating A to B counterclockwise to become collinear.
            </summary>
      <param name="another">Another vector to find the wedge product between the current vector and the specified.</param>
      <returns>The wedge product of two vectors.</returns>
    </member>
    <member name="M:whiteMath.Geometry.VectorD.angleCosBetweenVectors(whiteMath.Geometry.VectorD,whiteMath.Geometry.VectorD)">
      <summary>
            Returns the cosine of the angle between two vectors.
            </summary>
      <param name="first">The first vector.</param>
      <param name="second">The second vector.</param>
      <returns>The cosine of the angle between vectors.</returns>
    </member>
    <member name="M:whiteMath.Geometry.VectorD.angleSinBetweenVectors(whiteMath.Geometry.VectorD,whiteMath.Geometry.VectorD)">
      <summary>
            Returns the sine of the angle between two vectors.
            </summary>
      <param name="first">The first vector.</param>
      <param name="second">The second vector.</param>
      <returns>
            The sine of the angle that is required by the first vector to be 
            rotated counterclockwise to become collinear with the second.
            </returns>
    </member>
    <member name="M:whiteMath.Geometry.VectorD.angleBetweenVectors(whiteMath.Geometry.VectorD,whiteMath.Geometry.VectorD)">
      <summary>
            Returns the angle, in radians, that is required by the first vector
            to be rotated counterclockwise to become collinear with the second.
            </summary>
      <param name="first">The first vector.</param>
      <param name="second">The second vector.</param>
      <returns>
            The angle, in radians, that is required by the first vector
            to be rotated counterclockwise to become collinear with the second.
            </returns>
    </member>
    <member name="P:whiteMath.Geometry.VectorD.StartPoint">
      <summary>
            Gets the starting point of the vector.
            </summary>
    </member>
    <member name="P:whiteMath.Geometry.VectorD.EndPoint">
      <summary>
            Gets the ending point of the vector.
            </summary>
    </member>
    <member name="P:whiteMath.Geometry.VectorD.MiddlePoint">
      <summary>
            Gets the middle point of the vector.
            </summary>
    </member>
    <member name="P:whiteMath.Geometry.VectorD.Reverse">
      <summary>
            Returns the vector that has current vector's end point as his start point
            and the same coordinates.
            </summary>
    </member>
    <member name="P:whiteMath.Geometry.VectorD.X">
      <summary>
            Gets the X coordinate of the vector.
            </summary>
    </member>
    <member name="P:whiteMath.Geometry.VectorD.Y">
      <summary>
            Gets the Y coordinate of the vector.
            </summary>
    </member>
    <member name="P:whiteMath.Geometry.VectorD.Length">
      <summary>
            Gets the length of the vector.
            </summary>
    </member>
    <member name="T:whiteMath.Graphers.CoordinateTransformer`2">
      <summary>
            A generic class whose purpose is to transform between
            image coordinates and 2D function plane coordinates.
            <see cref="T:whiteMath.Numeric`2" /><see cref="T:whiteMath.ICalc`1" /><typeparam name="T">
            The numeric type which specifies the coordinates of the function.
            Should support fractional numbers and conversion to <c>double</c> type at least
            for small absolute numbers.
            </typeparam><typeparam name="C">The calculator for the <typeparamref name="T" /> type.</typeparam></summary>
      <invariant>this.toDouble != null</invariant>
    </member>
    <member name="M:whiteMath.Graphers.CoordinateTransformer`2.calculateCoordinateSystemPoints">
      <summary>
            Вычисляет положение главных точек координатной оси.
            </summary>
    </member>
    <member name="M:whiteMath.Graphers.CoordinateTransformer`2.transformFunctionToPixel(`0,`0)">
      <summary>
            Transforms the pair of function coordinates (x; y) to the image pixel coordinates.
            </summary>
      <param name="x">The X function coordinate</param>
      <param name="y">The Y function coordinate</param>
      <returns>The coordinates on the image.</returns>
    </member>
    <member name="M:whiteMath.Graphers.CoordinateTransformer`2.transformFunctionXToPixelX(`0)">
      <summary>
            Transforms the X coordinate from the functional coordinate system to the image coordinate system.
            </summary>
      <param name="x">The X coordinate from the functional coordinate system</param>
      <returns />
    </member>
    <member name="M:whiteMath.Graphers.CoordinateTransformer`2.transformFunctionYToPixelY(`0)">
      <summary>
            Transforms the Y coordinate from the functional coordinate system to the relative image coordinate system.
            </summary>
      <param name="y">The Y coordinate from the functional coordinate system</param>
      <returns />
    </member>
    <member name="M:whiteMath.Graphers.CoordinateTransformer`2.getInBoundPoint(System.Drawing.Point)">
      <summary>
            Method is used due to the existence of the milk area caused by 'indentFromImageBorder' parameter
            in the graphing argumens.
            
            If the point 'position' is out of the graphing area (in the "milk")
            this method would return the boundary point.
            
            Otherwise, the point returned is equivalent to the point passed.
            For example, the method is used by GraphicDrawer to determine if user has clicked an in-graph pixel, not the outer boundary of the image.
            </summary>
      <param name="position" />
    </member>
    <member name="M:whiteMath.Graphers.CoordinateTransformer`2.pointInBound(System.Drawing.Point)">
      <summary>
            Checks whether the specified image point is inside the graphing range,
            not in the "milk" caused by 'indentFromImageBorder' parameter.
            </summary>
      <param name="point" />
      <returns />
    </member>
    <member name="P:whiteMath.Graphers.CoordinateTransformer`2.TransformerAxisX">
      <summary>
            Gets the <c>DimensionTransformer</c> which performs the
            transformation of X coordinates between the drawing rectangle
            and the function plane rectangle.
            </summary>
    </member>
    <member name="P:whiteMath.Graphers.CoordinateTransformer`2.TransformerAxisY">
      <summary>
            Gets the <c>DimensionTransformer</c> which performs the
            transformation of Y coordinates between the drawing rectangle
            and the function plane rectangle.
            </summary>
    </member>
    <member name="P:whiteMath.Graphers.CoordinateTransformer`2.DrawingArea">
      <summary>
            Gets the image drawing rectangle
            associated with the current <c>CoordinateTransformer</c>.
            </summary>
    </member>
    <member name="T:whiteMath.Graphers.DimensionTransformer`2">
      <summary>
            A generic class dedicated to perform bidirectional mapping
            between an image axis interval and a function plane axis interval.
            <see cref="T:whiteMath.Numeric`2" /><see cref="T:whiteMath.ICalc`1" /><typeparam name="T">
            The numeric type which specifies the coordinate of the function.
            Should support fractional numbers and conversion to <c>double</c> type at least
            for small absolute numbers.
            </typeparam><typeparam name="C">The calculator for the <typeparamref name="T" /> type.</typeparam></summary>
      <invariant>this.toDouble != null</invariant>
    </member>
    <member name="M:whiteMath.Graphers.DimensionTransformer`2.#ctor(System.Double,System.Double,`0,`0,System.Func{`0,System.Double},System.Boolean)">
      <summary>
            Initializes the <c>DimensionTransformer</c> with
            an image axis interval and a function plane axis interval.
            </summary>
      <param name="imageAxisMin">The leftmost boundary of image axis transformation interval.</param>
      <param name="imageAxisMax">The rightmost boundary of image axis transformation interval.</param>
      <param name="functionAxisMin">The leftmost boundary of function plane axis transformation interval.</param>
      <param name="functionAxisMax">The rightmost boundary of function plane axis transformation interval.</param>
      <param name="toDouble">A function which provides conversion of function plane axis coordinates to <c>double</c> numbers - at least for small absolute values.</param>
      <param name="reverseImageAxis">A flag indicating if lower values on image axis scale should correspond to higher values on function plane axis scale.</param>
      <requires description="toDouble" exception="T:System.ArgumentNullException" csharp="toDouble != null" vb="toDouble &lt;&gt; Nothing">toDouble != null</requires>
      <exception cref="T:System.ArgumentNullException">toDouble == null</exception>
      <requires description="Invalid image axis interval, the specified minimal value exceeds the specified maximal value." exception="T:System.ArgumentOutOfRangeException" csharp="imageAxisMin &lt; imageAxisMax" vb="imageAxisMin &lt; imageAxisMax">imageAxisMin &lt; imageAxisMax</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">imageAxisMin &gt;= imageAxisMax</exception>
      <requires description="Invalid function axis interval, the specified minimal value exceeds the specified maximal value." exception="T:System.ArgumentOutOfRangeException" csharp="op_Implicit(functionAxisMin) &lt;= op_Implicit(functionAxisMax)" vb="operator functionAxisMin &lt;= operator functionAxisMax ">whiteMath.Numeric&lt;T, C&gt;.op_Implicit(functionAxisMin) &lt;= whiteMath.Numeric&lt;T, C&gt;.op_Implicit(functionAxisMax)</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!((Numeric&lt;T,C&gt;)functionAxisMin &lt;= functionAxisMax)</exception>
    </member>
    <member name="M:whiteMath.Graphers.DimensionTransformer`2.transformImagePointToFunctionPoint(System.Double)">
      <summary>
            Transforms the coordinate on the image axis
            to its  coordinate on the function plane axis.
            </summary>
      <param name="pixelCoordinate">The coordinate of a point on the image axis.</param>
      <returns>The coordinate of the point on the function plane axis.</returns>
    </member>
    <member name="M:whiteMath.Graphers.DimensionTransformer`2.transformFunctionPointToImagePoint(`0)">
      <summary>
            Transforms the coordinate of a point on the function plane axis
            to its coordinate on the image axis.
            </summary>
      <param name="functionCoordinate">The coordinate of a point on the function plane axis.</param>
      <returns>The coordinate of the point on the function plane axis.</returns>
    </member>
    <member name="M:whiteMath.Graphers.DimensionTransformer`2.transformRangeLengthImageToFunction(System.Double)">
      <summary>
            Transforms the length of pixel axis range to the equivalent length of function axis range.
            </summary>
      <param name="imageAxisRangeLength">The length of pixel axis range.</param>
      <returns>The length of function axis range.</returns>
    </member>
    <member name="M:whiteMath.Graphers.DimensionTransformer`2.transformRangeLengthFunctionToImage(`0)">
      <summary>
            Transforms the length of function plane axis range to the equivalent length
            of image axis rangel.
            </summary>
      <param name="functionAxisRangeLength">The length of function plane axis range.</param>
      <returns>The length of image axis range.</returns>
    </member>
    <member name="P:whiteMath.Graphers.DimensionTransformer`2.ReverseImageAxis">
      <summary>
            Gets the flag indicating if lower values on the
            image axis scale correspond to higher values
            on the function plane axis scale.
            </summary>
    </member>
    <member name="P:whiteMath.Graphers.DimensionTransformer`2.MinFunctionAxis">
      <summary>
            Returns the leftmost boundary of function axis
            transformation interval.
            </summary>
    </member>
    <member name="P:whiteMath.Graphers.DimensionTransformer`2.MaxFunctionAxis">
      <summary>
            Returns the rightmost boundary of function axis
            transformation interval.
            </summary>
    </member>
    <member name="P:whiteMath.Graphers.DimensionTransformer`2.MinImageAxis">
      <summary>
            Returns the leftmost boundary of image axis
            transformation interval.
            </summary>
    </member>
    <member name="P:whiteMath.Graphers.DimensionTransformer`2.MaxImageAxis">
      <summary>
            Returns the rightmost boundary of image axis
            transformation interval.
            </summary>
    </member>
    <member name="P:whiteMath.Graphers.DimensionTransformer`2.ScaleFactor">
      <summary>
            Returns the scale factor specifying the length of
            an interval on the function axis which is equivalent to one-pixel
            interval range on the image axis.
            </summary>
    </member>
    <member name="T:whiteMath.Graphers.HistoGrapher">
      <summary>
            This class is capable of drawing 2D and 3D histograms.
            </summary>
      <invariant>this.pointValuePairs != null</invariant>
    </member>
    <member name="F:whiteMath.Graphers.HistoGrapher.pointValuePairs">
      <summary>
            Hidden field.
            </summary>
    </member>
    <member name="M:whiteMath.Graphers.HistoGrapher.#ctor(System.Collections.Generic.IList{System.String},System.Collections.Generic.IList{System.Double})">
      <summary>
            Initializes the HistoGrapher object with separate lists of
            points and values.
            </summary>
      <remarks>The lengths of the lists should be equal.</remarks>
      <param name="points">A list containing the names of the points.</param>
      <param name="values">A list containing the values for corresponding points.</param>
      <requires description="points" exception="T:System.ArgumentNullException" csharp="points != null" vb="points &lt;&gt; Nothing">points != null</requires>
      <exception cref="T:System.ArgumentNullException">points == null</exception>
      <requires description="values" exception="T:System.ArgumentNullException" csharp="local_1.values != null" vb="local_1.values &lt;&gt; Nothing">local_1.values != null</requires>
      <exception cref="T:System.ArgumentNullException">values == null</exception>
      <requires description="Lengths of the lists should be equal." exception="T:System.ArgumentException" csharp="points.Count == local_1.values.Count" vb="points.Count = local_1.values.Count">points.Count == local_1.values.Count</requires>
      <exception cref="T:System.ArgumentException">points.Count != values.Count</exception>
      <requires description="The sequence should contain at least one point." exception="T:System.ArgumentOutOfRangeException" csharp="points.Count &gt; 0" vb="points.Count &gt; 0">points.Count &gt; 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">points.Count &lt;= 0</exception>
    </member>
    <member name="M:whiteMath.Graphers.HistoGrapher.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Double}})">
      <summary>
            Initializes the HistoGrapher with a sequence of point-value pairs.
            </summary>
      <param name="pointValuePairs">A sequence (e.g. a <c>Dictionary</c>) containing point-value pairs to draw.</param>
      <requires description="pointValuePairs" exception="T:System.ArgumentNullException" csharp="pointValuePairs != null" vb="pointValuePairs &lt;&gt; Nothing">pointValuePairs != null</requires>
      <exception cref="T:System.ArgumentNullException">pointValuePairs == null</exception>
      <requires description="The sequence should contain at least one point." exception="T:System.ArgumentOutOfRangeException" csharp="Count&lt;System.Collections.Generic.KeyValuePair&lt;string, double&gt;&gt;(pointValuePairs) &gt; 0" vb="Count(pointValuePairs) &gt; 0">System.Linq.Enumerable.Count&lt;System.Collections.Generic.KeyValuePair&lt;string, double&gt;&gt;(pointValuePairs) &gt; 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(pointValuePairs.Count() &gt; 0)</exception>
    </member>
    <member name="M:whiteMath.Graphers.HistoGrapher.HistoGraph2D(System.Double,System.Double,System.Double,System.Double,System.Drawing.Graphics,System.Drawing.RectangleF,System.Collections.Generic.Dictionary{System.String,System.Drawing.Brush},System.Drawing.Pen)">
      <summary>
            Draws a 2-dimensional histogram within specified rectangle.
            </summary>
      <param name="minValue">The absolute minimum of the graphing range. Must be less than the minimal value within current <c>HistoGrapher</c>'s point-value pairs.</param>
      <param name="baseValue">The absolute base-line of the graphing range. Columns' bottoms will have the coordinate of the baseline.</param>
      <param name="maxValue">The absolute maximum of the graphing range. Must be bigger that the maximal value within current <c>HistoGrapher</c>'s point-value pairs.</param>
      <param name="columnPortion">A value from (0, 1] interval which specifies what percentage of width columns will take from automatically allocated.</param>
      <param name="G">A <c>Graphics</c> object to draw with.</param>
      <param name="drawingArea">The area to contain the histogram. Full width of this rectangle will be used.</param>
      <param name="pointBrushes">A dictionary containing brushes for all <c>HistoGrapher</c>'s points.</param>
      <param name="contourPen">The point used to draw columns' contours. May be null.</param>
      <requires description="G" exception="T:System.ArgumentNullException" csharp="G != null" vb="G &lt;&gt; Nothing">G != null</requires>
      <exception cref="T:System.ArgumentNullException">G == null</exception>
      <requires description="pointBrushes" exception="T:System.ArgumentNullException" csharp="pointBrushes != null" vb="pointBrushes &lt;&gt; Nothing">pointBrushes != null</requires>
      <exception cref="T:System.ArgumentNullException">pointBrushes == null</exception>
      <requires description="The condition minValue &lt;= baseValue &lt;= maxValue AND minValue &lt; maxValue must be met." exception="T:System.ArgumentException" csharp="(minValue &lt;= baseValue ? baseValue &lt;= maxValue : !true) &amp;&amp; minValue &lt; maxValue" vb="(minValue &lt;= baseValue ? baseValue &lt;= maxValue : Not True) AndAlso minValue &lt; maxValue">(minValue &lt;= baseValue ? baseValue &lt;= maxValue : !true) &amp;&amp; minValue &lt; maxValue</requires>
      <exception cref="T:System.ArgumentException">minValue &gt; baseValue || baseValue &gt; maxValue || minValue &gt;= maxValue</exception>
      <requires description="The drawing area should be a non-empty rectangle." exception="T:System.ArgumentException" csharp="!drawingArea.IsEmpty" vb="Not drawingArea.IsEmpty">!drawingArea.IsEmpty</requires>
      <exception cref="T:System.ArgumentException">drawingArea.IsEmpty</exception>
      <requires description="The graphing range does not contain one or more HistoGrapher internal values." exception="T:System.ArgumentException" csharp="for all kvp in this.PointValuePairs 
{
    if (!(kvp.Value &lt; minValue))
    {
        return kvp.Value &lt;= maxValue;

    }
    return false;

}
" vb="for all kvp in Me.PointValuePairs &lt;unprintable lambda&gt;">for all kvp in this.PointValuePairs 
{
    if (!(kvp.Value &lt; minValue))
    {
        return kvp.Value &lt;= maxValue;

    }
    return false;

}
</requires>
      <exception cref="T:System.ArgumentException">!(Contract.ForAll(pointValuePairs, kvp =&gt; (kvp.Value &gt;= minValue &amp;&amp; kvp.Value &lt;= maxValue)))</exception>
      <requires description="The brushes dictionary must contain brushes for all grapher points." exception="T:System.ArgumentException" csharp="for all kvp in this.PointValuePairs pointBrushes.ContainsKey(kvp.Key)" vb="for all kvp in Me.PointValuePairs pointBrushes.ContainsKey(kvp.Key)">for all kvp in this.PointValuePairs pointBrushes.ContainsKey(kvp.Key)</requires>
      <exception cref="T:System.ArgumentException">!(Contract.ForAll(pointValuePairs, kvp =&gt; pointBrushes.ContainsKey(kvp.Key)))</exception>
    </member>
    <member name="P:whiteMath.Graphers.HistoGrapher.PointValuePairs">
      <summary>
            Gets a collection of point-value pairs associated with the current <c>HistoGrapher</c>.
            </summary>
    </member>
    <member name="P:whiteMath.Graphers.HistoGrapher.PointNames">
      <summary>
            Gets a sequence of point names associated with the current <c>HistoGrapher</c>.
            </summary>
    </member>
    <member name="P:whiteMath.Graphers.HistoGrapher.MinValue">
      <summary>
            Gets the minimum value from current HistoGrapher's point-value pairs.
            </summary>
    </member>
    <member name="P:whiteMath.Graphers.HistoGrapher.MaxValue">
      <summary>
            Gets the maximum value from current HistoGrapher's point-value pairs.
            </summary>
    </member>
    <member name="T:whiteMath.Matrices.MatrixSingularityException">
      <summary>
            The matrix exception signalizing that the matrix being processed is singular and 
            thus no futher actions may be performed.
            </summary>
    </member>
    <member name="T:whiteMath.Matrices.MatrixSizeException">
      <summary>
            The matrix exception signalizing that the matrix being processed has wrong size and 
            thus no futher actions may be performed.
            </summary>
    </member>
    <member name="T:whiteMath.Matrices.MinorMatrix`2">
      <summary>
            The class represents the minor matrix of a numeric matrix.
            All matrix operations supported, but any changes (i.e. element setting) made to the submatrix 
            will be reflected on the parent matrix object. The mechanism uses an encapsulated parent matrix 
            reference.
            
            An object of this class cannot be instantiated directly.
            Call method minorMatrixAt() for a particular DoubleMatrix object instead.
            </summary>
    </member>
    <member name="T:whiteMath.Matrices.Matrix`2">
      <summary>
            The generic class for matrices.
            </summary>
      <typeparam name="T">The type of matrix elements</typeparam>
    </member>
    <member name="T:whiteMath.Matrices.IMutableMatrix">
      <summary>
            The interface of mutable matrices allowing
            to set elements at specified indices.
            </summary>
    </member>
    <member name="T:whiteMath.Matrices.IMatrix">
      <summary>
            The interface supporting the minimal functionality
            to get an item from specified point, and to know
            both row and column count of the table.
            </summary>
    </member>
    <member name="M:whiteMath.Matrices.IMatrix.GetElementValue(System.Int32,System.Int32)">
      <summary>
            Returns the element at specified matrix position.
            </summary>
      <exception cref="T:System.ArgumentOutOfRangeException">
            If no such row or column exist in the 
            matrix, an ArgumentOutOfRange exception may be thrown.
            </exception>
      <param name="row">A zero-based index of a matrix row.</param>
      <param name="column">A zero-based index of a matrix column.</param>
      <returns>The element at specified matrix position.</returns>
    </member>
    <member name="P:whiteMath.Matrices.IMatrix.RowCount">
      <summary>
            Returns the total amount of rows in the matrix.
            </summary>
    </member>
    <member name="P:whiteMath.Matrices.IMatrix.ColumnCount">
      <summary>
            Returns the total amount of columns in the matrix.
            </summary>
    </member>
    <member name="M:whiteMath.Matrices.IMutableMatrix.SetElementValue(System.Int32,System.Int32,System.Object)">
      <summary>
            Sets the element at specified matrix position.
            </summary>
      <exception cref="T:System.ArgumentOutOfRangeException">
            If no such row or column exist in the 
            matrix, an ArgumentOutOfRange exception may be thrown.
            </exception>
      <exception cref="T:System.InvalidCastException">
            If the matrix is strictly typed, the cast operation on the value
            passed may fail, thus resulting in an InvalidCastException.
            </exception>
      <param name="row">A zero-based index of a matrix row.</param>
      <param name="column">A zero-based index of a matrix column.</param>
      <param name="value" />
    </member>
    <member name="T:whiteMath.Matrices.IMutableMatrix`1">
      <summary>
            The generic interface of mutable matrices allowing
            to set elements at specified indices.
            </summary>
    </member>
    <member name="T:whiteMath.Matrices.IMatrix`1">
      <summary>
            The generic interface supporting the minimal functionality
            to get an item from specified point, and to know
            both row and column count of the table.
            </summary>
    </member>
    <member name="M:whiteMath.Matrices.IMatrix`1.GetElementValue(System.Int32,System.Int32)">
      <summary>
            Returns the element at specified matrix position.
            </summary>
      <exception cref="T:System.ArgumentOutOfRangeException">
            If no such row or column exist in the 
            matrix, an ArgumentOutOfRange exception may be thrown.
            </exception>
      <param name="row">A zero-based index of a matrix row.</param>
      <param name="column">A zero-based index of a matrix column.</param>
      <returns>The element at specified matrix position.</returns>
    </member>
    <member name="M:whiteMath.Matrices.IMutableMatrix`1.SetElementValue(System.Int32,System.Int32,`0)">
      <summary>
            Sets the element at specified matrix position.
            </summary>
      <exception cref="T:System.ArgumentOutOfRangeException">
            If no such row or column exist in the 
            matrix, an ArgumentOutOfRange exception may be thrown.
            </exception>
      <param name="row">A zero-based index of a matrix row.</param>
      <param name="column">A zero-based index of a matrix column.</param>
      <param name="value" />
    </member>
    <member name="F:whiteMath.Matrices.Matrix`2.rows">
            -------------------------------
            ----- Length-concerned things--
            -------------------------------
        </member>
    <member name="M:whiteMath.Matrices.Matrix`2.getItemAt(System.Int32,System.Int32)">
      <summary>
            Returns the value at specified matrix index.
            
            Contract: 
            
            1. should NOT perform any speed-lowering index-bound checking, because all checking has
            been already performed at DoubleMatrix level in this[,] indexer.
            
            2. should NOT perform any element copying for class types.
            </summary>
      <param name="row">The target row of the matrix.</param>
      <param name="column">The target column of the matrix.</param>
      <returns>Value at the specified index pair.</returns>
    </member>
    <member name="M:whiteMath.Matrices.Matrix`2.setItemAt(System.Int32,System.Int32,whiteMath.Numeric{`0,`1})">
      <summary>
            Sets the value at the specified index pair.
            
            Contract: 
            
            1. should NOT perform any speed-lowering index-bound checking, because all checking has
            been already performed at DoubleMatrix level in this[,] indexer.
            
            2. should NOT perform any element copying for class types.
            </summary>
      <param name="row">The ROW!</param>
      <param name="column">The COLUMN!</param>
      <param name="value">The VALUE TO SET!</param>
    </member>
    <member name="M:whiteMath.Matrices.Matrix`2.transpose">
      <summary>
            Transposes the current matrix.
            Works only for square matrices, otherwise, a MatrixSizeException will be thrown.
            </summary>
    </member>
    <member name="M:whiteMath.Matrices.Matrix`2.transposedMatrixCopy">
      <summary>
            Returns the matrix that will be equal to the current matrix after the transposition.
            Performs memory allocation for the new matrix, so any changes made to it will not be reflected on the current matrix.
            </summary>
      <returns>Returns the matrix that will be equal to the current matrix after the transposition.</returns>
    </member>
    <member name="M:whiteMath.Matrices.Matrix`2.swapRows(System.Int32,System.Int32)">
      <summary>
            Virtual method. Swaps two rows with specified indices in the matrix.
            <param name="rowIndex1">The zero-based index of the first row to be swapped with the second.</param><param name="rowIndex2">The zero-based index of the second row to be swapped with the first.</param></summary>
    </member>
    <member name="M:whiteMath.Matrices.Matrix`2.swapColumns(System.Int32,System.Int32)">
      <summary>
            Virtual method. Swaps two columns with specified indices in the matrix.
            </summary>
      <param name="columnIndex1">The zero-based index of the first column to be swapped with the second.</param>
      <param name="columnIndex2">The zero-based index of the second column to be swapped with the first.</param>
    </member>
    <member name="M:whiteMath.Matrices.Matrix`2.op_Multiply(whiteMath.Matrices.Matrix{`0,`1},whiteMath.Matrices.Matrix{`0,`1})">
            -------------------------------
            --------ARITHMETIC OPERATORS---
            -------------------------------
        </member>
    <member name="M:whiteMath.Matrices.Matrix`2.layMatrixAt(whiteMath.Matrices.Matrix{`0,`1},System.Int32,System.Int32)">
      <summary>
            Inserts the submatrix at the specified point. The current matrix WILL NOT BE STRETCHED
            if the submatrix is too large. In this case, exception will be thrown.
            </summary>
      <param name="subMatrix">The submatrix object.</param>
      <param name="i">A zero-based row index</param>
      <param name="j">A zero-based column index</param>
    </member>
    <member name="M:whiteMath.Matrices.Matrix`2.getSubMatrixCopyAt(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Overloaded. Gets the stand-alone submatrix copy at the specified point and with specified size.
            </summary>
      <param name="i">Row index of the upper-left corner element.</param>
      <param name="j">Columnt index of the upper-left corner element.</param>
      <param name="rows">Row count of the submatrix.</param>
      <param name="columns">Column count of the submatrix.</param>
      <returns>The submatrix of specified size.</returns>
    </member>
    <member name="M:whiteMath.Matrices.Matrix`2.getSubMatrixCopyAt(System.Int32,System.Int32)">
      <summary>
            Overloaded. Gets the stand-alone submatrix copy at the specified point.
            </summary>
      <param name="i">Row index of the upper-left corner element</param>
      <param name="j">Column index of the upper-left corner element</param>
      <returns>The submatrix of size [RowCount-i; ColumnCount-j]</returns>
    </member>
    <member name="M:whiteMath.Matrices.Matrix`2.getSubMatrixAt(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Overloaded. Gets the binded submatrix for the current matrix.
            Changes to the submatrix WILL affect the current.
            </summary>
      <param name="i">Row index of the upper-left corner element</param>
      <param name="j">Column index of the upper-left corner element</param>
      <param name="rows">Row count of the submatrix</param>
      <param name="columns">Column count of the submatrix</param>
      <returns>A binded submatrix of specified size</returns>
    </member>
    <member name="M:whiteMath.Matrices.Matrix`2.getSubMatrixAt(System.Int32,System.Int32)">
      <summary>
            Overloaded. Gets the binded submatrix for the current matrix.
            Changes to the submatrix WILL affect the current.
            </summary>
      <param name="i">Row index of the upper-left corner element</param>
      <param name="j">Column index of the upper-left corner element</param>
      <returns>A binded submatrix of size [RowCount-i; ColumnCount-j]</returns>
    </member>
    <member name="M:whiteMath.Matrices.Matrix`2.convertToArray">
      <summary>
            Converts the current matrix to a two-dimensional array.
            
            Does not use the element copying, so when <typeparamref name="T" /> is a reference type,
            all changes made to the array OBJECTS (not to the array itself) will affect the matrix 
            elements and vice versa.
            
            Use <see cref="T:whiteMath.Matrices.Matrix`2.ElementCopyAdapter" /> if such behaviour is not expected.
            </summary>
      <returns />
    </member>
    <member name="M:whiteMath.Matrices.Matrix`2.convertFromArray(`0[0:,0:])">
      <summary>
             Fills the current matrix with the elements of matching type stored in a 2D array.
             The array size and the current matrix' size should match.
            
             Does not use the element copying, so when <typeparamref name="T" /> is a reference type,
             all changes made to the array OBJECTS (not to the array itself) will affect the matrix 
             elements and vice versa.
             
             Use <see cref="T:whiteMath.Matrices.Matrix`2.ElementCopyAdapter" /> if such behaviour is not expected.
             </summary>
      <param name="matrix" />
    </member>
    <member name="M:whiteMath.Matrices.Matrix`2.Clone">
      <summary>
            Creates a deep copy of current object.
            </summary>
      <returns>The cloned object.</returns>
      <ensures inheritedFrom="M:System.ICloneable.Clone" inheritedFromTypeName="ICloneable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:whiteMath.Matrices.Matrix`2.Equals(System.Object)">
      <summary>
            Checks whether all of the elements in the current matrix
            are equal to the respective elements in the other matrix.
            
            The other matrix may be either the IMatrix object containing
            <typeparamref name="T" /> elements or Numeric IMatrix object. (e.g. Matrix(T,C)).
            </summary>
    </member>
    <member name="M:whiteMath.Matrices.Matrix`2.windFromArray(whiteMath.Matrices.IWinder,`0[])">
      <summary>
            Winds a flat array onto current using the IWinder object.
            The IWinder object is automatically reset before winding.
            IWinder object and current matrix should be have the same dimension (i.e. row count and column count).
            </summary>
      <param name="winder">An IWinder object. Row and column count should match with current matrix.</param>
      <param name="flatMatrix">A single-dimension matrix. Element count should match with current matrix.</param>
    </member>
    <member name="M:whiteMath.Matrices.Matrix`2.checkSquare">
      <summary>
            Checks if the matrix is square.
            Throws MatrixSizeException if this requirement is not met. 
            </summary>
    </member>
    <member name="M:whiteMath.Matrices.Matrix`2.checkBounds(System.Int32,System.Int32)">
      <summary>
            Checks if the arguments do not exceed the number of total rows and columns respectively.
            Throws MatrixSizeException otherwise.
            </summary>
      <param name="exceedsRows">Argument suspicious to exceed the number of rows.</param>
      <param name="exceedsColumns">Argument suspicious to exceed the number of columns.</param>
    </member>
    <member name="M:whiteMath.Matrices.Matrix`2.checkPositive(System.Int32[])">
      <summary>
            Checks if the arguments are zero or positive.
            </summary>
    </member>
    <member name="M:whiteMath.Matrices.Matrix`2.addValue(whiteMath.Numeric{`0,`1})">
      <summary>
            Adds a double value to all of the matrix elements.
            </summary>
      <param name="value">The integer value added to all of the matrix elements.</param>
      <returns>The result matrix.</returns>
    </member>
    <member name="M:whiteMath.Matrices.Matrix`2.multiplyByValue(whiteMath.Numeric{`0,`1})">
      <summary>
            Multiplies all of the matrix elements by a double value.
            </summary>
      <param name="value">The double value.</param>
      <returns>The result matrix.</returns>
    </member>
    <member name="M:whiteMath.Matrices.Matrix`2.divideByValue(whiteMath.Numeric{`0,`1})">
      <summary>
            Divides all of the matrix elements by a double value.
            </summary>
      <param name="value">The double value.</param>
      <returns>The result matrix.</returns>
    </member>
    <member name="M:whiteMath.Matrices.Matrix`2.Determinant_LUP_Factorization">
      <summary>
            Performs the matrix determinant calculation using the LUP-factorization
            of the matrix.
            </summary>
      <returns />
    </member>
    <member name="M:whiteMath.Matrices.Matrix`2.Determinant_Permutations">
      <summary>
            Counts the matrix determinant using the definition of matrix determinant.
            Creates all of the row index permutations: thus (WARNING!)
            the complexity of algorithm is O(n!) operations for square matrices of size 'n'.
            
            Please do not use for matrices bigger than 7-10.
            </summary>
      <returns>The value of matrix determinant.</returns>
    </member>
    <member name="M:whiteMath.Matrices.Matrix`2.getMinorMatrix(System.Int32,System.Int32)">
      <summary>
            Returns the dependent minor matrix which is made by hiding
            the row with index <paramref name="rowToRemove" /> and the column with
            index <paramref name="columnToRemove" />.
            
            Any changes made to this minor matrix will be reflected on the current matrix.
            </summary>
      <param name="rowToRemove">The row to be removed to form the minor matrix.</param>
      <param name="columnToRemove">The column to be removed to form the minor matrix.</param>
      <returns>The dependent minor matrix by hiding one row and one column from the current matrix.</returns>
    </member>
    <member name="M:whiteMath.Matrices.Matrix`2.getMinorMatrixCopy(System.Int32,System.Int32)">
      <summary>
            Returns the minor matrix copy (independent from the current),
            which is made by removing the row with index <paramref name="rowToRemove" />
            and the column with index <paramref name="columnToRemove" />.
            </summary>
      <param name="rowToRemove">The index of the row to remove.</param>
      <param name="columnToRemove">The index of the column to remove.</param>
      <returns>The minor matrix copy (independent from the current).</returns>
    </member>
    <member name="M:whiteMath.Matrices.Matrix`2.inverseMatrix_LUP_Factorization">
      <summary>
            Calculates the inverse matrix using the LUP-factorization for calculating matrix determinants 
            and algebraic supplements of its elements.
            It takes O(n^5) operations to run.
            
            Works only for square, non-singular matrices.
            If these requirements are not met, either a MatrixSizeException 
            or a MatrixSingularityException shall be thrown.
            </summary>
    </member>
    <member name="M:whiteMath.Matrices.Matrix`2.LUP_Factorization(System.Int32[]@,whiteMath.Matrices.Matrix_SDA{`0,`1}@)">
      <summary>
            Preforms the LUP-factorization of a matrix (let it be A)
            in the form of:
            
            P*A = L*U.
            
            The P is an identity matrix with a plenty of row inversions.
            For the economy of space it is provided as a single-dimensional array of integers:
            
            (0, 1, 2, 3, ..., n).
            
            Element indices of this array stand for matrix rows, and elements value
            mean the position of '1' in a row.
            
            Requirements: works for any square and nonsingular matrix (having a non-zero determinant).
            If these requirements aren't met, either a MatrixSingularException or a MatrixSizeException
            would be thrown.
            </summary>
      <param name="C">The matrix C containing L + U - E. It is clear that both L and U can be easily extracted from this matrix.</param>
      <param name="P">The identity matrix with a plenty of row inversions in the form of array.</param>
    </member>
    <member name="M:whiteMath.Matrices.Matrix`2.LUP_Factorization(System.Int32[]@,whiteMath.Matrices.Matrix_SDA{`0,`1}@,whiteMath.Matrices.Matrix_SDA{`0,`1}@)">
      <summary>
            Preforms the LUP-factorization of a matrix (let it be A)
            in the form of:
            
            P*A = L*U.
            
            The P is an identity matrix with a plenty of row inversions.
            For the economy of space it is provided as a single-dimensional array of integers:
            
            (0, 1, 2, 3, ..., n).
            
            Element indices of this array stand for matrix rows, and elements value
            mean the position of '1' in a row.
            
            Requirements: works for any square and nonsingular matrix (having a non-zero determinant).
            If these requirements aren't met, either MatrixSingularException of MatrixSizeException
            would be thrown.
            </summary>
      <param name="L">The lower-triangular matrix with '1' on the main diagonal.</param>
      <param name="U">The upper-triangular matrix.</param>
      <param name="P">The identity matrix with a plenty of row inversions in the form of array.</param>
    </member>
    <member name="M:whiteMath.Matrices.Matrix`2.LUP_Factorization(whiteMath.Matrices.Matrix_SDA{`0,`1}@,whiteMath.Matrices.Matrix_SDA{`0,`1}@,whiteMath.Matrices.Matrix_SDA{`0,`1}@)">
      <summary>
            Preforms the LUP-factorization of a matrix (let it be A)
            in the form of:
            
            P*A = L*U.
            
            The P is an identity matrix with a plenty of row inversions.
            
            Requirements: works for any square and nonsingular matrix (having a non-zero determinant).
            If these requirements aren't met, either MatrixSingularException of MatrixSizeException
            would be thrown.
            </summary>
      <param name="L">The lower-triangular matrix with '1' on the main diagonal.</param>
      <param name="U">The upper-triangular matrix.</param>
      <param name="P">The identity matrix with a plenty of row inversions.</param>
    </member>
    <member name="P:whiteMath.Matrices.Matrix`2.Matrix_Type">
            -----------------------------------
            ----- MatrixType-concerned things--
            -----------------------------------
        </member>
    <member name="P:whiteMath.Matrices.Matrix`2.ColumnCount">
      <summary>
            Returns the column count for current matrix
            </summary>
    </member>
    <member name="P:whiteMath.Matrices.Matrix`2.RowCount">
      <summary>
            Returns the row count for current matrix
            </summary>
    </member>
    <member name="P:whiteMath.Matrices.Matrix`2.ElementCount">
      <summary>
            Returns the total element count for current matrix
            </summary>
    </member>
    <member name="P:whiteMath.Matrices.Matrix`2.Item(System.Int32,System.Int32)">
      <summary>
            Overloaded. Gets or sets the double value using the pair of indexes.
            Performs the bounds checking.
            
            Does NOT perform the element copying.
            All changes made to the reference type element got or set will be reflected on the matrix.
            Use <see cref="!:MatrixCopyAdapter&lt;T,C&gt;" /> if such behaviour is unwanted. 
            </summary>
      <param name="row">The zero-based row index.</param>
      <param name="column">The zero-based column index.</param>
      <returns>The double value at specified point.</returns>
    </member>
    <member name="P:whiteMath.Matrices.Matrix`2.Item(whiteMath.Matrices.IndexPair)">
      <summary>
            Overloaded. Gets or sets the numeric value using the pair of indexes.
            Performs the bounds checking.
            
            Does NOT perform the element copying.
            All changes made to the reference type element got or set will be reflected on the matrix.
            Use <see cref="!:MatrixElementCopyAdapter" /> if such behaviour is unwanted.
            </summary>
      <param name="indexPair">The IndexPair object containing a pair of indexes.</param>
      <returns>The double value at specified point.</returns>
    </member>
    <member name="P:whiteMath.Matrices.Matrix`2.IsSymmetric">
      <summary>
            Tests if current matrix is a symmetric square matrix.
            If the matrix is not square, a MatrixSizeException will be thrown.
            </summary>
    </member>
    <member name="P:whiteMath.Matrices.Matrix`2.Trace">
      <summary>
            Returns the trace (the sum of diagonal elements) of current matrix if it is square.
            If it is not, a MatrixSizeException is thrown.
            </summary>
    </member>
    <member name="M:whiteMath.Matrices.MinorMatrix`2.Clone">
      <summary>
            Returns the COPY of the current submatrix as a stand-alone Matrix object.
            The changes made to it will never influence the parent matrix.
            </summary>
      <returns />
    </member>
    <member name="P:whiteMath.Matrices.MinorMatrix`2.RemovedRow">
      <summary>
            Gets the row of the parent matrix which has been removed to get current minor matrix.
            </summary>
    </member>
    <member name="P:whiteMath.Matrices.MinorMatrix`2.RemovedColumn">
      <summary>
            Gets the column of the parent matrix which has been removed to get current minor matrix.
            </summary>
    </member>
    <member name="P:whiteMath.Matrices.MinorMatrix`2.Parent">
      <summary>
            Gets the parent matrix object.
            </summary>
    </member>
    <member name="T:whiteMath.NeuralNetworks.IValueProvider`2">
      <summary>
            The interface designed to provide values of
            specified type T.
            </summary>
      <typeparam name="T">The type of the value provided.</typeparam>
      <typeparam name="C">The calculator for the <typeparamref name="T" /> type.</typeparam>
    </member>
    <member name="T:whiteMath.NeuralNetworks.ConstValueProvider`2">
      <summary>
            The IValueProvider implementation that shall provide
            a constant value.
            </summary>
      <typeparam name="T">The type of the value provided.</typeparam>
      <typeparam name="C">The calculator for the <typeparamref name="T" /> type.</typeparam>
    </member>
    <member name="T:whiteMath.NeuralNetworks.Neuron`2">
      <summary>
            This class represents a single neuron of a neural network.
            </summary>
      <typeparam name="T">The numeric type of neuron's entry and output signal.</typeparam>
      <typeparam name="C">The calculator for the <typeparamref name="T" /> type.</typeparam>
    </member>
    <member name="P:whiteMath.NeuralNetworks.Neuron`2.Function">
      <summary>
            The function of the neuron.
            </summary>
    </member>
    <member name="P:whiteMath.NeuralNetworks.Neuron`2.EntrySignals">
      <summary>
            The neurons that shall provide entry vector values.
            </summary>
    </member>
    <member name="P:whiteMath.NeuralNetworks.Neuron`2.Weights">
      <summary>
            The weights for the entry vector values.
            </summary>
    </member>
    <member name="T:whiteMath.IConversion`2">
      <summary>
            Public interface providing the capability to
            convert variables of one type to another.
            
            For example, IConvertible(int, double) is expected to convert integer variables 
            to double-presicion floating-point variables.
            
            It is recommended for numeric conversions that the type T is able to store both the precision and the range of numeric type F.
            If precision may be lost, at least the safe range storing is strongly recommended.
            </summary>
      <typeparam name="F">The type to convert from.</typeparam>
      <typeparam name="T">The type to convert to.</typeparam>
    </member>
    <member name="M:whiteMath.IConversion`2.Convert(`0)">
      <summary>
            Converts an F type variable to the T type variable.
            </summary>
      <param name="variable">The variable to convert to the type T.</param>
      <returns>The conversion result of type F.</returns>
    </member>
    <member name="T:whiteMath.IMetricProvider`1">
      <summary>
            A generic interface for providing generic type <typeparamref name="T" />
            with an integer metrics.
            
            The method maps the <typeparamref name="T" /> space to integer numbers space.
            Two <typeparamref name="T" /> values for which the same integer metric is produced
            belong, in a way, to the same 'equivalence class'.
            </summary>
      <typeparam name="T">The type to be provided with an integer metric.</typeparam>
    </member>
    <member name="T:whiteMath.Numeric.StreamMonotonicityChecker`2">
      <summary>
            This class provides a simple way of checking monotonic increasing 
            or decreasing of a discrete stream of values.
            </summary>
      <typeparam name="T">A numeric type of values in the stream.</typeparam>
      <typeparam name="C">A calculator for the <typeparamref name="T" /> type.</typeparam>
    </member>
    <member name="M:whiteMath.Numeric.StreamMonotonicityChecker`2.#ctor(whiteMath.Numeric.StreamMonotonicityChecker{`0,`1}.MonotonicityPropertyType)">
      <summary>
            Constructs an instance of the class using the specified
            monotonicity check type.
            </summary>
      <param name="checkType">
            The type of monotonicity check, e.g. check for 
            non-decrease of values, increase etc..
            </param>
    </member>
    <member name="M:whiteMath.Numeric.StreamMonotonicityChecker`2.WillKeepMonotonicity(whiteMath.Numeric{`0,`1},System.Boolean)">
      <summary>
            Returns <c>true</c> if, after insertion of the value specified,
            the monotonicity property will remain unbroken.
            </summary>
      <param name="value">The value to be tested.</param>
      <param name="insertIfKeeps">
            If this flag is <c>true</c>, the value will be automatically inserted into the object
            if it doesn't break the monotonicity property.</param>
      <returns>
            A flag signalizing whether, after insertion of the value specified,
            the monotonicity property will remain unbroken.
            </returns>
    </member>
    <member name="M:whiteMath.Numeric.StreamMonotonicityChecker`2.InsertValue(whiteMath.Numeric{`0,`1})">
      <summary>
            Inserts a value into the checker and returns the flag signalizing
            whether the monotonicity property still holds.
            </summary>
      <param name="value">The value to be inserted.</param>
      <returns>True if, after the insertion of the value passed, the monotonicity property still holds.</returns>
    </member>
    <member name="P:whiteMath.Numeric.StreamMonotonicityChecker`2.MonotonicityPropertyHolds">
      <summary>
            Returns <c>true</c> if the monotonicity property still holds.
            </summary>
    </member>
    <member name="P:whiteMath.Numeric.StreamMonotonicityChecker`2.LastPassedValue">
      <summary>
            Gets the last value which was passed to the instance of the class
            to be checked for not violating monotonicity of the stream.
            
            Returns <c>null</c> if no values were passed previously.
            </summary>
    </member>
    <member name="P:whiteMath.Numeric.StreamMonotonicityChecker`2.MonotonicityProperty">
      <summary>
            Returns the type of monotonicity property which the current object
            was initialized with.
            </summary>
    </member>
    <member name="T:whiteMath.Summator`1">
      <summary>
            This class provides methods to sum or multiply different sequences member
            represented by the generic, [index and/or argument]-determined formula.
            
            Different methods provide summation / multiplication in different order 
            determined by [or regardless of] different metrics of the object.
            
            For example, you may want to use this class to sum up
            the taylor sequence for exp(x) with members indexed from 2 to 30, getting
            maximum precision by starting with smallest ones and ending up with biggest.
            </summary>
    </member>
    <member name="M:whiteMath.Summator`1.#ctor(`0,System.Func{`0,`0,`0})">
      <summary>
            Initializes a new instance of Summator(<typeparamref name="T" />) class
            using a <typeparamref name="T" /> value serving as a zero initializer and a function for the summing up two <typeparamref name="T" /> values.
            </summary>
      <param name="zero">A <typeparamref name="T" /> value serving as a zero initializer for overall sum.</param>
      <param name="operatorPlus">A function delegate allowing to get a sum of two numbers.</param>
    </member>
    <member name="M:whiteMath.Summator`1.Sum_Sequentially(System.Func{System.Int32,`0},System.Int32,System.Int32)">
      <summary>
            Performs a simple, sequential summation of members of an index-dependent sequence.
            Requires a general term formula dependent only on the integer member index (<paramref name="memberFormula" />).
            </summary>
      <param name="startIndex">The inclusive beginning index of sequence summation.</param>
      <param name="endIndex">The inclusive ending index of sequence summation.</param>
      <param name="memberFormula">The general term formula depending as the function of integer index.</param>
      <returns>The result of the sequential summation of provided sequence starting with index <paramref name="startIndex" /> and ending with index <paramref name="endIndex" />, both inclusive.</returns>
    </member>
    <member name="M:whiteMath.Summator`1.Sum_Sequentially(`0,System.Func{`0,System.Int32,`0},System.Int32,System.Int32)">
      <summary>
            Performs the simple, sequential summation of members of both argument- and index-dependent sequence. 
            Requires the current function argument as well as a general term formula.
            </summary>
      <param name="argument">The current argument for the sequence.</param>
      <param name="startIndex">The inclusive beginning index of sequence summation.</param>
      <param name="endIndex">The inclusive ending index of sequence summation.</param>
      <param name="memberFormula">The general term formula as the function of <typeparamref name="T" /> argument and an integer index.</param>
      <returns>The result of sequential summation of the sequence starting with index <paramref name="startIndex" /> and ending with index <paramref name="endIndex" />, both inclusive.</returns>
    </member>
    <member name="M:whiteMath.Summator`1.Sum_SmallerToBigger(System.Func{System.Int32,`0},System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
      <summary>
            Performs a smaller-to-bigger summation of sequence members.
            Works slightly slower than a simple sequential summation, 
            but as smallest values are summed up first, this method
            significantly increases precision if the sequence doesn't non-decrease
            monotonously and consequent values are of different degrees.
            
            Requires a general term formula dependent only on the member index (<paramref name="memberFormula" />),
            as well as a comparer allowing of knowing which sequence element is bigger and which is smaller.
            </summary>
      <param name="startIndex">The inclusive beginning index of sequence summation.</param>
      <param name="endIndex">The inclusive ending index of sequence summation.</param>
      <param name="comparer">The comparer to compare values of type <typeparamref name="T" />. Should return a positive value if the first value is bigger than the second, zero value if they are equal, and a negative value if the first object is less.</param>
      <param name="memberFormula">The general term formula dependent on an integer index.</param>
      <returns>The result of lower-to-bigger summation of the sequence starting with index <paramref name="startIndex" /> and ending with index <paramref name="endIndex" />, both inclusive.</returns>
    </member>
    <member name="M:whiteMath.Summator`1.Sum_SmallerToBigger(`0,System.Func{`0,System.Int32,`0},System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
      <summary>
            Performs a smaller-to-bigger summation of sequence members.
            Works slightly slower than a simple sequential summation, 
            but as smallest values are summed up first, this method
            significantly increases precision if the sequence doesn't non-decrease
            monotonously and consequent values are of different degrees.
            
            Requires a general term formula dependent on both argument and integer index (<paramref name="memberFormula" />) as well as the current function argument.
            Also requires a comparer allowing of knowing which sequence element is bigger and which is smaller.
            </summary>
      <param name="startIndex">The inclusive beginning index of sequence summation.</param>
      <param name="endIndex">The inclusive ending index of sequence summation.</param>
      <param name="comparer">The comparer to compare values of type <typeparamref name="T" />. Should return a positive value if the first value is bigger than the second, zero value if they are equal, and a negative value if the first object is less.</param>
      <param name="memberFormula">The general term formula dependent on both argument and integer index.</param>
      <param name="argument">The current argument for the sequence.</param>
      <returns>The result of sequential summation of the sequence starting with index <paramref name="startIndex" /> and ending with index <paramref name="endIndex" />, both inclusive.</returns>
    </member>
    <member name="M:whiteMath.Summator`1.Sum_ByIncreasingMetric(System.Func{System.Int32,`0},System.Int32,System.Int32,whiteMath.IMetricProvider{`0})">
      <summary>
            Performs a summation of sequence members according to their integer metric provided by a IMetricProvider object.
            The summation is performed starting with lowest metric and ending up with highest.
            Works slower than a simple sequential summation.
            
            Requires a general term formula dependent on an integer index (<paramref name="memberFormula" />).
            </summary>
      <param name="startIndex">The inclusive beginning index of sequence summation.</param>
      <param name="endIndex">The inclusive ending index of sequence summation.</param>
      <param name="metricProvider">The metric mapping values of type <typeparamref name="T" /> to their integer metric.</param>
      <param name="memberFormula">The general term formula dependent on an integer index.</param>
      <returns>The result of sequential summation of the sequence starting with index <paramref name="startIndex" /> and ending with index <paramref name="endIndex" />, both inclusive.</returns>
    </member>
    <member name="M:whiteMath.Summator`1.Sum_ByIncreasingMetric(`0,System.Func{`0,System.Int32,`0},System.Int32,System.Int32,whiteMath.IMetricProvider{`0})">
      <summary>
            Performs the summation of sequence members according to their integer metric provided by a IMetricProvider object.
            The summation is performed starting with lowest metric and ending up with highest.
            Works slower than a simple sequential summation.
            
            Requires a general term formula dependent on both argument and integer index (<paramref name="memberFormula" />) as well as the current function argument.
            </summary>
      <param name="startIndex">The inclusive beginning index of sequence summation.</param>
      <param name="endIndex">The inclusive ending index of sequence summation.</param>
      <param name="metricProvider">The metric mapping values of type <typeparamref name="T" /> to their integer metric.</param>
      <param name="memberFormula">The general term formula dependent on both argument and integer index.</param>
      <param name="argument">The current argument for the sequence.</param>
      <returns>The result of sequential summation of the sequence starting with index <paramref name="startIndex" /> and ending with index <paramref name="endIndex" />, both inclusive.</returns>
    </member>
    <member name="M:whiteMath.Summator`1.Sum_KeyValueSequence(System.Collections.Generic.LinkedList{System.Collections.Generic.KeyValuePair{System.Int32,`0}})">
      <summary>
            Суммирует все значения в слинкованном листе по "значению".
            </summary>
    </member>
    <member name="P:whiteMath.Summator`1.Zero">
      <summary>
            Gets the value served as zero.
            </summary>
    </member>
    <member name="P:whiteMath.Summator`1.OperatorPlus">
      <summary>
            Gets the method which calculates the sum of two <typeparamref name="T" /> values.
            </summary>
    </member>
    <member name="T:whiteMath.Randoms.RandomCryptographic">
      <summary>
            Represents a random number generator wrapper built
            on a cryptographically strong <see cref="T:System.Security.Cryptography.RandomNumberGenerator" /> instance.
            </summary>
    </member>
    <member name="T:whiteMath.Randoms.IRandomBoundedUnbounded`1">
      <summary>
            A generic interface providing means
            for generating random numbers either in the whole
            numeric range of type <typeparamref name="T" /> or
            in a user-specified concrete range.
            </summary>
      <typeparam name="T">The type of generated numbers.</typeparam>
    </member>
    <member name="T:whiteMath.Randoms.IRandomBounded`1">
      <summary>
            A generic interface providing means
            for generating random numbers in the specified range.
            </summary>
      <typeparam name="T">The type of generated numbers.</typeparam>
    </member>
    <member name="M:whiteMath.Randoms.IRandomBounded`1.Next(`0,`0)">
      <summary>
            Returns the next random value in the
            <c>[min; max)</c> interval.
            </summary>
      <param name="min">The lower _inclusive_ numeric boundary of random generation.</param>
      <param name="max">The upper _exclusive_ numeric boundary of random generation.</param>
      <returns>A random number laying in the [min; max) interval.</returns>
    </member>
    <member name="T:whiteMath.Randoms.IRandomUnbounded`1">
      <summary>
            A generic interface providing means
            for generating random numbers in the whole range
            of numeric type <typeparamref name="T" />.
            </summary>
      <typeparam name="T">The type of generated numbers.</typeparam>
    </member>
    <member name="M:whiteMath.Randoms.IRandomUnbounded`1.Next">
      <summary>
            Returns the next random value from
            all of the possible finite values of type <typeparamref name="T" />.
            </summary>
    </member>
    <member name="M:whiteMath.Randoms.RandomCryptographic.#ctor(System.Security.Cryptography.RandomNumberGenerator)">
      <summary>
            Initializes an instance of <see cref="T:whiteMath.Randoms.RandomCryptographic" />
            with a single instance of cryptographically strong <see cref="T:System.Security.Cryptography.RandomNumberGenerator" />.
            </summary>
      <param name="gen">
            An instance of cryptographically strong <see cref="T:System.Security.Cryptography.RandomNumberGenerator" />.
            If <c>null</c>, an instance built from <see cref="!:RNGCryptoServiceProvider.Create" /> will be used.
            </param>
    </member>
    <member name="M:whiteMath.Randoms.RandomCryptographic.NextUInt">
      <summary>
            Returns the next <c>uint</c> number.
            </summary>
      <returns>A random <c>uint</c> number.</returns>
    </member>
    <member name="M:whiteMath.Randoms.RandomCryptographic.NextUInt(System.UInt32)">
      <summary>
            Returns the next <c>uint</c> number limited
            by an exclusive upper boundary.
            </summary>
      <param name="maxValue">The exclusive upper boundary of generated numbers.</param>
      <returns>A random <c>uint</c> number which is smaller than <paramref name="maxValue" />.</returns>
      <requires description="The upper exclusive boundary for generated values should not be equal to zero." exception="T:System.ArgumentException" csharp="maxValue &gt; uint0" vb="maxValue &gt; UInteger 0">maxValue &gt; uint0</requires>
      <exception cref="T:System.ArgumentException">maxValue &lt;= 0</exception>
    </member>
    <member name="M:whiteMath.Randoms.RandomCryptographic.NextUInt(System.UInt32,System.UInt32)">
      <summary>
            Returns the next <c>uint</c> number in the <c>[<paramref name="minValue" />; <paramref name="maxValue" />)</c>
            interval.
            </summary>
      <param name="minValue">The lower inclusive boundary of generated values.</param>
      <param name="maxValue">The upper exclusive boundary of generated values.</param>
      <returns>A random <c>uint</c> number which is bigger than or equal to <paramref name="minValue" /> and less than <paramref name="maxValue" />.</returns>
      <requires description="The upper exclusive boundary should be bigger than the lower inclusive." exception="T:System.ArgumentException" csharp="maxValue &gt; minValue" vb="maxValue &gt; minValue">maxValue &gt; minValue</requires>
      <exception cref="T:System.ArgumentException">maxValue &lt;= minValue</exception>
    </member>
    <member name="M:whiteMath.Randoms.RandomCryptographic.NextULong">
      <summary>
            Returns the next <c>ulong</c> number.
            </summary>
      <returns>A random <c>ulong</c> number.</returns>
    </member>
    <member name="M:whiteMath.Randoms.RandomCryptographic.NextULong(System.UInt64)">
      <summary>
            Returns the next <c>ulong</c> number limited
            by an exclusive upper boundary.
            </summary>
      <param name="maxValue">The exclusive upper boundary of generated numbers.</param>
      <returns>A random <c>ulong</c> number which is smaller than <paramref name="maxValue" />.</returns>
      <requires description="The upper exclusive boundary for generated values should not be equal to zero." exception="T:System.ArgumentException" csharp="maxValue &gt; ulong(long)0" vb="maxValue &gt; ULong ((Long )0)">maxValue &gt; ulong(long)0</requires>
      <exception cref="T:System.ArgumentException">maxValue &lt;= 0</exception>
    </member>
    <member name="M:whiteMath.Randoms.RandomCryptographic.NextULong(System.UInt64,System.UInt64)">
      <summary>
            Returns the next <c>ulong</c> number in the <c>[<paramref name="minValue" />; <paramref name="maxValue" />)</c>
            interval.
            </summary>
      <param name="minValue">The lower inclusive boundary of generated values.</param>
      <param name="maxValue">The upper exclusive boundary of generated values.</param>
      <returns>A random <c>ulong</c> number which is bigger than or equal to <paramref name="minValue" /> and less than <paramref name="maxValue" />.</returns>
      <requires description="The upper exclusive boundary should be bigger than the lower inclusive." exception="T:System.ArgumentException" csharp="maxValue &gt; minValue" vb="maxValue &gt; minValue">maxValue &gt; minValue</requires>
      <exception cref="T:System.ArgumentException">maxValue &lt;= minValue</exception>
    </member>
    <member name="M:whiteMath.Randoms.RandomCryptographic.NextInt">
      <summary>
            Returns the next <c>int</c> value in the [int.MinValue; int.MaxValue]
            interval.
            </summary>
      <returns>The next number in the <c>[int.MinValue; int.MaxValue]</c> interval.</returns>
    </member>
    <member name="M:whiteMath.Randoms.RandomCryptographic.NextInt(System.Int32)">
      <summary>
            Returns the next non-negative <c>int</c> value that is less than
            <paramref name="maxValue" /></summary>
      <param name="maxValue">The upper exclusive bound for generated number.</param>
      <returns>A non-negative <c>int</c> number that is less than <paramref name="maxValue" /></returns>
      <requires description="The upper exclusive boundary should be a positive number." exception="T:System.ArgumentOutOfRangeException" csharp="maxValue &gt; 0" vb="maxValue &gt; 0">maxValue &gt; 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">maxValue &lt;= 0</exception>
    </member>
    <member name="M:whiteMath.Randoms.RandomCryptographic.NextInt(System.Int32,System.Int32)">
      <summary>
            Returns the next <c>int</c> value in the <c>[minValue; maxValue)</c>
            interval.
            </summary>
      <param name="minValue">The lower inclusive bound for generated number.</param>
      <param name="maxValue">The upper exclusive bound for generated number.</param>
      <returns>The next <c>int</c> value in the <c>[minValue; maxValue)</c> interval.</returns>
      <requires description="The lower inclusive boundary should be less than the upper exclusive." exception="T:System.ArgumentException" csharp="maxValue &gt; minValue" vb="maxValue &gt; minValue">maxValue &gt; minValue</requires>
      <exception cref="T:System.ArgumentException">maxValue &lt;= minValue</exception>
    </member>
    <member name="M:whiteMath.Randoms.RandomCryptographic.NextLong">
      <summary>
            Returns the next <c>long</c> value in the [long.MinValue; long.MaxValue]
            interval.
            </summary>
      <returns>The next number in the <c>[long.MinValue; long.MaxValue]</c> interval.</returns>
    </member>
    <member name="M:whiteMath.Randoms.RandomCryptographic.NextLong(System.Int64)">
      <summary>
            Returns the next non-negative <c>long</c> value that is less than
            <paramref name="maxValue" /></summary>
      <param name="maxValue">The upper exclusive bound for generated number.</param>
      <returns>A non-negative <c>long</c> number that is less than <paramref name="maxValue" /></returns>
      <requires description="The upper exclusive boundary should be a positive number." exception="T:System.ArgumentOutOfRangeException" csharp="maxValue &gt; (long)0" vb="maxValue &gt; ((Long )0)">maxValue &gt; (long)0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">maxValue &lt;= 0</exception>
    </member>
    <member name="M:whiteMath.Randoms.RandomCryptographic.NextLong(System.Int64,System.Int64)">
      <summary>
            Returns the next <c>long</c> value in the <c>[minValue; maxValue)</c>
            interval.
            </summary>
      <param name="minValue">The lower inclusive bound for generated number.</param>
      <param name="maxValue">The upper exclusive bound for generated number.</param>
      <returns>The next <c>long</c> value in the <c>[minValue; maxValue)</c> interval.</returns>
      <requires description="The lower inclusive boundary should be less than the upper exclusive." exception="T:System.ArgumentException" csharp="maxValue &gt; minValue" vb="maxValue &gt; minValue">maxValue &gt; minValue</requires>
      <exception cref="T:System.ArgumentException">maxValue &lt;= minValue</exception>
    </member>
    <member name="T:whiteMath.Randoms.RandomLongIntModular`1">
      <summary>
            This class provides high-quality uniform random <c>LongInt&lt;<typeparamref name="B" />&gt;</c>
            generation. 
            </summary>
      <typeparam name="B">The type specifying the digit base for the <c>LongInt&lt;B&gt;</c> type.</typeparam>
    </member>
    <member name="M:whiteMath.Randoms.RandomLongIntModular`1.ResetRejectionCounter">
      <summary>
            Resets the <c>TotalRejected</c>
            counter, setting its value to zero.
            </summary>
      <see cref="P:whiteMath.Randoms.RandomLongIntModular`1.TotalRejected" />
    </member>
    <member name="M:whiteMath.Randoms.RandomLongIntModular`1.#ctor(whiteMath.Randoms.IRandomBounded{System.Int32},System.Func{whiteMath.ArithmeticLong.LongInt{`0},whiteMath.ArithmeticLong.LongInt{`0},whiteMath.ArithmeticLong.LongInt{`0}})">
      <summary>
            Initializes the <c>RandomLongIntModular&lt;<typeparamref name="B" />&gt;</c> instance
            with an integer digit generator and a delegate used to multiply <c>LongInt&lt;<typeparamref name="B" />&gt;</c> numbers.
            </summary>
      <param name="intGenerator">
            A uniform distribution integer generator which will be used 
            to produce <c>LongInt&lt;<typeparamref name="B" />&gt;</c> digits.
            If <c>null</c>, a new <c>RandomStandard</c> instance will be used.
            </param>
      <see cref="T:whiteMath.Randoms.RandomStandard" />
      <param name="multiplication">
            A function taking two <c>LongInt&lt;<typeparamref name="B" />&gt;</c> numbers 
            and returning their multiplication product.
            If <c>null</c>, the simple, O(n^2) multiplication method will be used.
            </param>
      <see cref="M:whiteMath.ArithmeticLong.LongInt`1.Helper.MultiplySimple(whiteMath.ArithmeticLong.LongInt{`0},whiteMath.ArithmeticLong.LongInt{`0})" />
    </member>
    <member name="M:whiteMath.Randoms.RandomLongIntModular`1.Next(whiteMath.ArithmeticLong.LongInt{`0})">
      <summary>
            Returns the next non-negative <c>LongInt&lt;<typeparamref name="B" />&gt;</c>
            number which is less than <paramref name="maxExclusive" />.
            </summary>
      <param name="maxExclusive">The upper exclusive bound of generated numbers.</param>
      <returns>
            A non-negative <c>LongInt&lt;<typeparamref name="B" />&gt;</c> number which
            is less than <paramref name="maxExclusive" />.
            </returns>
      <requires description="maxExclusive" exception="T:System.ArgumentNullException" csharp="(() =&gt; {
    {
        System.Predicate&lt;whiteMath.ArithmeticLong.LongInt&lt;B&gt;&gt; local_2 = (System.Predicate&lt;whiteMath.ArithmeticLong.LongInt&lt;B&gt;&gt;)null;
        whiteMath.Randoms.RandomLongIntModular&lt;B&gt;.&lt;&gt;c__DisplayClass3 local_3 = new whiteMath.Randoms.RandomLongIntModular&lt;B&gt;.&lt;&gt;c__DisplayClass3();
        local_3.maxExclusive = maxExclusive;
    }
    return local_3.maxExclusive != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null; })()" vb="(() =&gt; {
    System.Predicate&lt;whiteMath.ArithmeticLong.LongInt&lt;B&gt;&gt; local_2 = ((System.Predicate(Of whiteMath.ArithmeticLong.LongInt(Of B)))Nothing);
    whiteMath.Randoms.RandomLongIntModular&lt;B&gt;.&lt;&gt;c__DisplayClass3 local_3 = New whiteMath.Randoms.RandomLongIntModular(Of B).&lt;&gt;c__DisplayClass3();
    local_3.maxExclusive = maxExclusive
    return local_3.maxExclusive &lt;&gt; ((whiteMath.ArithmeticLong.LongInt(Of B))Nothing) ; })()">(() =&gt; {
    {
        System.Predicate&lt;whiteMath.ArithmeticLong.LongInt&lt;B&gt;&gt; local_2 = (System.Predicate&lt;whiteMath.ArithmeticLong.LongInt&lt;B&gt;&gt;)null;
        whiteMath.Randoms.RandomLongIntModular&lt;B&gt;.&lt;&gt;c__DisplayClass3 local_3 = new whiteMath.Randoms.RandomLongIntModular&lt;B&gt;.&lt;&gt;c__DisplayClass3();
        local_3.maxExclusive = maxExclusive;
    }
    return local_3.maxExclusive != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null; })()</requires>
      <exception cref="T:System.ArgumentNullException">maxExclusive == null</exception>
      <requires description="The maximum exclusive bound should be a positive number." exception="T:System.ArgumentOutOfRangeException" csharp="local_3.maxExclusive &gt; op_Implicit((long)0)" vb="local_3.maxExclusive &gt; operator ((Long )0) ">local_3.maxExclusive &gt; whiteMath.ArithmeticLong.LongInt&lt;B&gt;.op_Implicit((long)0)</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">maxExclusive &lt;= 0</exception>
    </member>
    <member name="M:whiteMath.Randoms.RandomLongIntModular`1.Next(whiteMath.ArithmeticLong.LongInt{`0},whiteMath.ArithmeticLong.LongInt{`0})">
      <summary>
            Returns the next <c>LongInt&lt;<typeparamref name="B" />&gt;</c>
            which lies in the interval <c>[<paramref name="minInclusive" />; <paramref name="maxExclusive" />)</c>.
            </summary>
      <param name="minInclusive">The lower inclusive bound of generated numbers.</param>
      <param name="maxExclusive">The upper exclusive bound of generated numbers.</param>
      <returns>
            A non-negative <c>LongInt&lt;<typeparamref name="B" />&gt;</c> number 
            which lies in the interval <c>[<paramref name="minInclusive" />; <paramref name="maxExclusive" />)</c>.
            </returns>
      <requires description="minInclusive" exception="T:System.ArgumentNullException" csharp="minInclusive != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null" vb="minInclusive &lt;&gt; ((whiteMath.ArithmeticLong.LongInt(Of B))Nothing) ">minInclusive != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">minInclusive == null</exception>
      <requires description="maxExclusive" exception="T:System.ArgumentNullException" csharp="maxExclusive != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null" vb="maxExclusive &lt;&gt; ((whiteMath.ArithmeticLong.LongInt(Of B))Nothing) ">maxExclusive != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">maxExclusive == null</exception>
      <requires description="The minimum inclusive bound should be less than the maximum exclusive." exception="T:System.ArgumentException" csharp="minInclusive &lt; maxExclusive" vb="minInclusive &lt; maxExclusive ">minInclusive &lt; maxExclusive</requires>
      <exception cref="T:System.ArgumentException">minInclusive &gt;= maxExclusive</exception>
    </member>
    <member name="M:whiteMath.Randoms.RandomLongIntModular`1.Max_BinarySearch``1(whiteMath.ArithmeticLong.LongInt{``0},whiteMath.ArithmeticLong.LongInt{``0},System.Predicate{whiteMath.ArithmeticLong.LongInt{``0}})">
      <summary>
            Finds the maximum number '<c>k</c>' within a given integer interval of special structure 
            such that a predicate holds for this number '<c>k</c>'.
            </summary>
      <typeparam name="B">The numeric base class for the <see cref="T:whiteMath.ArithmeticLong.LongInt`1" /> numbers.</typeparam>
      <param name="predicate">
            A predicate that holds for all numbers, starting with the leftmost bound and ending with the 
            desired (sought-for) number, and only for these.
            </param>
      <returns>The maximum number within a given interval for which the <paramref name="predicate" /> holds.</returns>
      <requires description="leftInclusive" exception="T:System.ArgumentNullException" csharp="leftInclusive != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null" vb="leftInclusive &lt;&gt; ((whiteMath.ArithmeticLong.LongInt(Of B))Nothing) ">leftInclusive != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">leftInclusive == null</exception>
      <requires description="rightInclusive" exception="T:System.ArgumentNullException" csharp="rightInclusive != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null" vb="rightInclusive &lt;&gt; ((whiteMath.ArithmeticLong.LongInt(Of B))Nothing) ">rightInclusive != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">rightInclusive == null</exception>
      <requires description="predicate" exception="T:System.ArgumentNullException" csharp="predicate != null" vb="predicate &lt;&gt; Nothing">predicate != null</requires>
      <exception cref="T:System.ArgumentNullException">predicate == null</exception>
      <requires exception="T:System.ArgumentException" csharp="!leftInclusive &gt; rightInclusive" vb="Not leftInclusive &gt; rightInclusive ">!leftInclusive &gt; rightInclusive</requires>
      <exception cref="T:System.ArgumentException">!(!(leftInclusive &gt; rightInclusive))</exception>
    </member>
    <member name="P:whiteMath.Randoms.RandomLongIntModular`1.TotalRejected">
      <summary>
            Gets the total amount of generated numbers that 
            were discarded during rejection sampling.
            </summary>
    </member>
    <member name="T:whiteMath.Randoms.RandomLongIntRejection`1">
      <summary>
        <para>
            This class provides high-quality uniform random <c>LongInt&lt;<typeparamref name="B" />&gt;</c>
            number generation, but is incredibly slow.
            </para>
        <para>
            In practice, always use <c>RandomLongIntModular&lt;<typeparamref name="B" />&gt;</c>
            to achieve the same distribution quality with lower performance overhead.
            </para>
      </summary>
      <remarks>
            The speed of number generation is usually very slow, because the class uses rejection sampling
            even without modular reduction. Please use <c>RandomLongIntModular&lt;<typeparamref name="B" />&gt;</c>
            instead.
            </remarks>
      <see cref="T:whiteMath.Randoms.RandomLongIntModularUnoptimized`1" />
      <typeparam name="B">The type specifying the digit base for the <c>LongInt&lt;B&gt;</c> type.</typeparam>
    </member>
    <member name="M:whiteMath.Randoms.RandomLongIntRejection`1.ResetRejectionCounter">
      <summary>
            Resets the <c>TotalRejected</c>
            counter, setting its value to zero.
            </summary>
      <see cref="P:whiteMath.Randoms.RandomLongIntRejection`1.TotalRejected" />
    </member>
    <member name="M:whiteMath.Randoms.RandomLongIntRejection`1.#ctor(whiteMath.Randoms.IRandomBounded{System.Int32})">
      <summary>
            Initializes the <c>RandomLongIntRejection&lt;<typeparamref name="B" />&gt;</c> instance
            with an integer digit generator.
            </summary>
      <param name="intGenerator">
            A uniform distribution integer generator which will be used 
            to produce <c>LongInt&lt;<typeparamref name="B" />&gt;</c> digits.
            If <c>null</c>, a new <c>RandomStandard</c> instance will be used.
            </param>
      <see cref="T:whiteMath.Randoms.RandomStandard" />
    </member>
    <member name="M:whiteMath.Randoms.RandomLongIntRejection`1.NextInclusive(whiteMath.ArithmeticLong.LongInt{`0})">
      <summary>
            Returns the next non-negative <c>LongInt&lt;<typeparamref name="B" />&gt;</c>
            number which is not bigger than <paramref name="maxInclusive" />.
            </summary>
      <param name="maxInclusive">The upper inclusive bound of generated numbers.</param>
      <returns>
            A non-negative <c>LongInt&lt;<typeparamref name="B" />&gt;</c> number which
            is not bigger than <paramref name="maxInclusive" />.
            </returns>
      <requires description="maxInclusive" exception="T:System.ArgumentNullException" csharp="maxInclusive != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null" vb="maxInclusive &lt;&gt; ((whiteMath.ArithmeticLong.LongInt(Of B))Nothing) ">maxInclusive != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">maxInclusive == null</exception>
      <requires description="The maximum inclusive number should not be negative." exception="T:System.ArgumentOutOfRangeException" csharp="!maxInclusive.Negative" vb="Not maxInclusive.Negative">!maxInclusive.Negative</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">maxInclusive.Negative</exception>
    </member>
    <member name="M:whiteMath.Randoms.RandomLongIntRejection`1.Next(whiteMath.ArithmeticLong.LongInt{`0})">
      <summary>
            Returns the next non-negative <c>LongInt&lt;<typeparamref name="B" />&gt;</c>
            number which is less than <paramref name="maxExclusive" />.
            </summary>
      <param name="maxExclusive">The upper exclusive bound of generated numbers.</param>
      <returns>
            A non-negative <c>LongInt&lt;<typeparamref name="B" />&gt;</c> number which
            is less than <paramref name="maxExclusive" />.
            </returns>
      <requires description="maxExclusive" exception="T:System.ArgumentNullException" csharp="maxExclusive != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null" vb="maxExclusive &lt;&gt; ((whiteMath.ArithmeticLong.LongInt(Of B))Nothing) ">maxExclusive != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">maxExclusive == null</exception>
      <requires description="The maximum exclusive bound should be a positive number." exception="T:System.ArgumentOutOfRangeException" csharp="maxExclusive &gt; op_Implicit((long)0)" vb="maxExclusive &gt; operator ((Long )0) ">maxExclusive &gt; whiteMath.ArithmeticLong.LongInt&lt;B&gt;.op_Implicit((long)0)</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">maxExclusive &lt;= 0</exception>
    </member>
    <member name="M:whiteMath.Randoms.RandomLongIntRejection`1.Next(whiteMath.ArithmeticLong.LongInt{`0},whiteMath.ArithmeticLong.LongInt{`0})">
      <summary>
            Returns the next <c>LongInt&lt;<typeparamref name="B" />&gt;</c>
            which lies in the interval <c>[<paramref name="minInclusive" />; <paramref name="maxExclusive" />)</c>.
            </summary>
      <param name="minInclusive">The lower inclusive bound of generated numbers.</param>
      <param name="maxExclusive">The upper exclusive bound of generated numbers.</param>
      <returns>
            A non-negative <c>LongInt&lt;<typeparamref name="B" />&gt;</c> number 
            which lies in the interval <c>[<paramref name="minInclusive" />; <paramref name="maxExclusive" />)</c>.
            </returns>
      <requires description="minInclusive" exception="T:System.ArgumentNullException" csharp="minInclusive != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null" vb="minInclusive &lt;&gt; ((whiteMath.ArithmeticLong.LongInt(Of B))Nothing) ">minInclusive != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">minInclusive == null</exception>
      <requires description="maxExclusive" exception="T:System.ArgumentNullException" csharp="maxExclusive != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null" vb="maxExclusive &lt;&gt; ((whiteMath.ArithmeticLong.LongInt(Of B))Nothing) ">maxExclusive != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">maxExclusive == null</exception>
      <requires description="The minimum inclusive bound should be less than the maximum exclusive." exception="T:System.ArgumentException" csharp="minInclusive &lt; maxExclusive" vb="minInclusive &lt; maxExclusive ">minInclusive &lt; maxExclusive</requires>
      <exception cref="T:System.ArgumentException">minInclusive &gt;= maxExclusive</exception>
    </member>
    <member name="P:whiteMath.Randoms.RandomLongIntRejection`1.TotalRejected">
      <summary>
            Gets the total amount of generated numbers that 
            were discarded during rejection sampling.
            </summary>
    </member>
    <member name="T:whiteMath.Randoms.IRandomFloatingPoint`1">
      <summary>
            A generic interface providing means 
            for generating random floating-point numbers in the <c>[0; 1)</c> interval.
            </summary>
      <typeparam name="T">The type of generated numbers.</typeparam>
    </member>
    <member name="M:whiteMath.Randoms.IRandomFloatingPoint`1.Next_SingleInterval">
      <summary>
            Returns the next random value in the
            [0; 1) interval.
            </summary>
      <returns>A value in the [0; 1) interval.</returns>
    </member>
    <member name="T:whiteMath.Randoms.IRandomBytes">
      <summary>
            An interface which provides a method
            for generating pseudo-random sequences of
            bytes.
            </summary>
    </member>
    <member name="M:whiteMath.Randoms.IRandomBytes.NextBytes(System.Byte[])">
      <summary>
            Generates a sequence of bytes
            and stores them in a buffer.
            </summary>
      <param name="buffer">The buffer to store the random sequence of bytes.</param>
    </member>
    <member name="T:whiteMath.Randoms.RandomBounded">
      <summary>
            This class contains extension methods for <see cref="T:whiteMath.Randoms.IRandomBounded`1" />.
            </summary>
    </member>
    <member name="M:whiteMath.Randoms.RandomBounded.NextString(whiteMath.Randoms.IRandomBounded{System.Int32},System.Collections.Generic.IList{System.Char},System.Int32)">
      <summary>
            Forms a random string of the desired length containing characters from a <c>char</c> list.
            There are no guarantees for each character to appear in the string.
            </summary>
      <param name="gen">An integer generator which will be used to randomly traverse the character list.</param>
      <param name="characters">A list of characters. Duplicates will increase the chance of appearing in the result string.</param>
      <param name="length">A non-negative desired length of the string.</param>
      <returns>A random string of the desired length containing characters from a <c>char</c> list.</returns>
      <requires description="gen" exception="T:System.ArgumentNullException" csharp="gen != null" vb="gen &lt;&gt; Nothing">gen != null</requires>
      <exception cref="T:System.ArgumentNullException">gen == null</exception>
      <requires description="characters" exception="T:System.ArgumentNullException" csharp="characters != null" vb="characters &lt;&gt; Nothing">characters != null</requires>
      <exception cref="T:System.ArgumentNullException">characters == null</exception>
      <requires description="The length of the string should be a non-negative value." exception="T:System.ArgumentOutOfRangeException" csharp="length &gt;= 0" vb="length &gt;= 0">length &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">length &lt; 0</exception>
    </member>
    <member name="M:whiteMath.Numeric`2.Equals(System.Object)">
      <summary>
            Checks whether the value of the current <c>Numeric&lt;<typeparamref name="T" />,<typeparamref name="C" />&gt;</c> 
            object is equal to the value of another <c>Numeric&lt;<typeparamref name="T" />,<typeparamref name="C" />&gt;</c> object or
            <typeparamref name="T" /> object.
            </summary>
      <param name="obj">The object to test for equality with.</param>
      <returns>True if values are equal, false otherwise.</returns>
    </member>
    <member name="M:whiteMath.Numeric`2.Equals(whiteMath.Numeric{`0,`1})">
      <summary>
            Checks whether the value of the current <c>Numeric&lt;<typeparamref name="T" />,<typeparamref name="C" />&gt;</c>
            object is equal to the value of another <c>Numeric&lt;<typeparamref name="T" />,<typeparamref name="C" />&gt;</c> object.
            </summary>
      <param name="obj">The object to test for equality with.</param>
      <returns>True if values are equal, false otherwise.</returns>
    </member>
    <member name="M:whiteMath.Numeric`2.GetHashCode">
      <summary>
            Returns the hash code of the value stored.
            </summary>
      <returns>The hash code of the value stored.</returns>
    </member>
    <member name="M:whiteMath.Numeric`2.ToString">
      <summary>
            Returns the standard string representation of the value stored.
            </summary>
      <returns>The string representation of the value stored.</returns>
      <ensures inheritedFrom="M:System.ValueType.ToString" inheritedFromTypeName="ValueType" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:whiteMath.Numeric`2.CompareTo(whiteMath.Numeric{`0,`1})">
      <summary>
            Compares the current number to another.
            </summary>
      <param name="another">A value for the current number to compare with.</param>
      <returns>
            A positive value if the current number is bigger than the number passed,
            a zero value if they are equal, and a negative value if the second number is bigger.
            </returns>
    </member>
    <member name="P:whiteMath.Numeric`2.Calculator">
      <summary>
            Returns the calculator for the instantiated numeric class.
            </summary>
    </member>
    <member name="P:whiteMath.Numeric`2.IntegerPart">
      <summary>
            Returns the integer part for the current Numeric object.
            </summary>
      <see cref="M:whiteMath.ICalc`1.intPart(`0)" />
    </member>
    <member name="P:whiteMath.Numeric`2.FractionalPart">
      <summary>
            Returns the fractional part for the current Numeric object.
            </summary>
      <see cref="M:whiteMath.ICalcExtensionMethods.fracPart``1(whiteMath.ICalc{``0},``0)" />
    </member>
    <member name="P:whiteMath.Numeric`2.Copy">
      <summary>
            Gets a deep copy of current number.
            </summary>
    </member>
    <member name="P:whiteMath.Numeric`2.Zero">
      <summary>
            Gets a zero number for T type.
            </summary>
    </member>
    <member name="P:whiteMath.Numeric`2.Even">
      <summary>
            Tests whether the current number is even.
            </summary>
      <exception cref="T:whiteMath.NonIntegerTypeException">
            This exception will be thrown if <typeparamref name="T" /> is 
            non-integer type.
            </exception>
    </member>
    <member name="P:whiteMath.Numeric`2.NumericComparison">
      <summary>
            Gets the comparison delegate for this numeric class
            implicitly using calculator's methods mor() and eqv().
            </summary>
    </member>
    <member name="P:whiteMath.Numeric`2.TComparison">
      <summary>
            Gets the comparison delegate for the underlying (hidden)
            T type using its calculator's methods mor() and eqv().
            </summary>
    </member>
    <member name="P:whiteMath.Numeric`2.NumericComparer">
      <summary>
            Gets the comparer for this numeric class.
            implicitly using calculator's methods mor() and eqv().
            </summary>
    </member>
    <member name="P:whiteMath.Numeric`2.TComparer">
      <summary>
            Gets the comparer for the underlying (hidden)
            T type using its calculator's methods mor() and eqv().
            </summary>
    </member>
    <member name="T:whiteMath.NumericExtensions">
      <summary>
            This class provides static methods for numeric array conversion.
            </summary>
    </member>
    <member name="M:whiteMath.NumericExtensions.ConvertToNumericArray``2(System.Collections.Generic.IList{``0})">
      <summary>
            Converts a list of T to the array of Numeric objects.
            </summary>
      <typeparam name="T">The type of numbers in Numeric objects.</typeparam>
      <typeparam name="C">The calculator for the number type.</typeparam>
      <param name="list">The list object containint T elements.</param>
      <returns>An array of Numeric objects.</returns>
    </member>
    <member name="M:whiteMath.NumericExtensions.ConvertToUnboxedArray``2(System.Collections.Generic.IList{whiteMath.Numeric{``0,``1}})">
      <summary>
            Converts a list of Numeric objects to the equivalent array of unboxed T objects.
            </summary>
      <typeparam name="T">The type of numbers in array.</typeparam>
      <typeparam name="C">The calculator for the number type.</typeparam>
      <param name="list">The list object containing Numeric elements.</param>
      <returns>An array of T objects.</returns>
    </member>
    <member name="T:whiteMath.Complex">
      <summary>
            Struct representing a complex number as a pair of two numeric values.
            </summary>
    </member>
    <member name="M:whiteMath.Complex.#ctor(System.Double,System.Double)">
      <summary>
            Standard constructor of a complex number.
            </summary>
      <param name="real" />
      <param name="img" />
    </member>
    <member name="M:whiteMath.Complex.op_Implicit(System.Double)~whiteMath.Complex">
      <summary>
            Implicit conversion of real to complex numbers
            </summary>
      <param name="value" />
      <returns />
    </member>
    <member name="M:whiteMath.Complex.Parse(System.String)">
      <summary>
            Parses the string containing the Complex number.
            Syntax:
            
            1. [re; im]
            2. (re; im)
            3. re; im
            
            Numerator and denominator should be written in the format in accordance 
            to their own Parse methods.
            </summary>
      <param name="value" />
      <returns />
    </member>
    <member name="P:whiteMath.Complex.Module">
      <summary>
            Performs calculation of complex number module
            </summary>
    </member>
    <member name="P:whiteMath.Complex.Adjoint">
      <summary>
            Returns the adjoint complex number for the current number
            </summary>
    </member>
    <member name="P:whiteMath.Complex.Angle">
      <summary>
            Returns the angle in radians for the current complex number.
            </summary>
    </member>
    <member name="T:whiteMath.Complex.Helper">
      <summary>
            Static class providing various mathematical algorithms
            working with complex numbers.
            </summary>
    </member>
    <member name="M:whiteMath.Complex.Helper.MultiplySimple(whiteMath.Complex,whiteMath.Complex)">
      <summary>
            Represents a simple multiplying algorithm
            for two complex numbers.
            
            first = a + bi; 
            second = c + di; 
            result = (ac - bd; bc + ad)
            </summary>
      <param name="one" />
      <param name="two" />
      <returns />
    </member>
    <member name="M:whiteMath.Complex.Helper.MultiplyKaratsuba(whiteMath.Complex,whiteMath.Complex)">
      <summary>
            A Karatsuba-like multiplying algorithm
            using three multiplications instead of four in the simplest form.
            </summary>
      <param name="one" />
      <param name="two" />
      <returns />
    </member>
    <member name="T:whiteMath.Functions.AnalyticFunction">
      <summary>
            A function that automatically forms its action list
            depending on the string representation of the function.
            </summary>
    </member>
    <member name="M:whiteMath.Functions.Function.#ctor">
      <summary>
            A special constructor for AnalyticFunction class
            </summary>
    </member>
    <member name="M:whiteMath.Functions.Function.#ctor(System.Collections.Generic.List{System.String})">
      <summary>
            Creates a new function using the specified action list
            </summary>
      <param name="actions" />
    </member>
    <member name="M:whiteMath.Functions.Function.Value(System.Double)">
      <summary>
            Calculates the function value depending on the argument passed.
            </summary>
      <param name="x" />
      <returns />
    </member>
    <member name="P:whiteMath.Functions.Function.PrecompiledVersion">
      <summary>
            Returns the precompiled version of the function.
            Consumes more memory, but calculates its value faster.
            </summary>
    </member>
    <member name="M:whiteMath.Functions.AnalyticFunction.#ctor(System.String)">
      <summary>
            Creates a new analytic function object on the basis
            of function string like "f(x) = 5x"
            </summary>
      <param name="functionString" />
    </member>
    <member name="M:whiteMath.Functions.AnalyticFunction.CheckNPrepare(System.String@)">
      <summary>
            Возвращает букву переменной-аргумента и подготавливает все дело.
            </summary>
      <param name="str" />
      <returns />
    </member>
    <member name="M:whiteMath.Functions.AnalyticFunction.Derivative">
      <summary>
            Returns the derivative of the current analytic function.
            </summary>
      <returns />
    </member>
    <member name="M:whiteMath.Functions.AnalyticFunction.isSuccessfulFunctionMatch(System.Text.RegularExpressions.Match,System.String)">
      <summary>
            Должны выполняться три условия, чтобы считать матч функцией.
            Например, для ln(x)/ln(x) не выполнится только одно.
            </summary>
      <param name="match" />
      <param name="functionString" />
      <returns />
    </member>
    <member name="M:whiteMath.Functions.AnalyticFunction.isSuccessfulBinaryMatch(System.Text.RegularExpressions.Match)">
      <summary>
            Должны выполняться два условия.
            Во втором аргументе количество ( должно быть равно количеству )
            Иначе забоссится вот что:
            
            ln(x)/ln(2*x)
            
            Он схватит результат 'x)'. Потому что умножение проверяется прежде сложения.
            </summary>
      <param name="match" />
      <returns />
    </member>
    <member name="M:whiteMath.Functions.AnalyticFunction.Analyze(System.String,System.Char,System.Int32)">
      <summary>
            Analyzes the function string and recursively forms the action list.
            </summary>
      <param name="str" />
      <param name="argument" />
      <param name="curAc" />
      <returns />
    </member>
    <member name="P:whiteMath.Functions.AnalyticFunction.HasDerivative">
      <summary>
            Returns true if the derivative analytic function can be calculated,
            else otherwise. For example, the function "sign(x)" does not have
            any analytic function derivative formula.
            </summary>
    </member>
    <member name="M:whiteMath.Functions.StringExtensions.withoutOuterParentheses(System.String)">
      <summary>
            Returs a reference to the string equal to the calling object.
            But... without any outer parentheses. ((sin(x))) = sin(x);
            </summary>
      <param name="str" />
      <returns />
    </member>
    <member name="M:whiteMath.Functions.StringExtensions.findSign(System.String,System.Char[])">
      <summary>
            Finds the specified sign.
            </summary>
      <param name="str" />
      <param name="signs" />
      <returns />
    </member>
    <member name="M:whiteMath.Functions.StringExtensions.hasOuterParentheses(System.String@)">
      <summary>
            Проверяет, есть ли внешние скобки в строке функции.
            Если есть, то убирает их и возвращает true.
            </summary>
      <param name="str" />
      <returns />
    </member>
    <member name="M:whiteMath.Functions.StringExtensions.hasOuterParentheses(System.String)">
      <summary>
            Returns the flag whether the string has outer parentheses.
            without modifying it.
            </summary>
      <param name="str">The calling string object.</param>
      <returns>THe flag indicating whether the string has outer parentheses.</returns>
    </member>
    <member name="M:whiteMath.Functions.StringExtensions.encloseIfNegative(System.String)">
      <summary>
            Encloses the calling object in parentheses if it symbolizes a negative value.
            </summary>
      <param name="obj" />
      <returns />
    </member>
    <member name="M:whiteMath.Functions.StringExtensions.parseOperation(System.String,System.String,System.Func{System.Double,System.Double,System.Double})">
      <summary>
            Parses the two strings into their double equivalents and performs an operation on them.
            </summary>
      <param name="one" />
      <param name="two" />
      <param name="operation" />
      <returns />
    </member>
    <member name="M:whiteMath.Functions.StringExtensions.enumerateParentheses(System.String)">
            ------------------------------------------
            ------- PARENTHESES LEVEL PREPARE --------
            ------------------------------------------
        </member>
    <member name="M:whiteMath.Functions.StringExtensions.removeParenthesesEnumeration(System.String)">
      <summary>
            Removes the parentheses enumeration from the string.
            </summary>
      <param name="parent" />
      <returns />
    </member>
    <member name="F:whiteMath.Functions.StringExtensions.numberPattern">
            ------------------------------------------
            ------- REMOVE DOUBLING PARENTHESES-------
            ------------------------------------------
        </member>
    <member name="M:whiteMath.Functions.StringExtensions.hasPlusMinus(System.String@)">
      <summary>
            Сокращает сумму в одно слагаемое, если они отличаются только коэффициентом.
            </summary>
      <param name="obj" />
      <returns />
    </member>
    <member name="M:whiteMath.Functions.StringExtensions.hasUnneededParentheses(System.String@)">
      <summary>
            Modifies the string object so that it does not contain any unneeded parentheses anymore.
            </summary>
      <param name="obj" />
      <returns />
    </member>
    <member name="M:whiteMath.Functions.StringExtensions.insertMultiplicationSign(System.String)">
      <summary>
            Вставляет знак умножения между всякой ерундой, вроде 25sin(x)
            </summary>
      <param name="obj" />
    </member>
    <member name="T:whiteMath.Functions.IFunctionDifferentiable`2">
      <summary>
            The function interface providing the capability to get the derivative function for the current.
            </summary>
      <typeparam name="TypeArg">The type of the function argument.</typeparam>
      <typeparam name="TypeValue">The type of the function value.</typeparam>
    </member>
    <member name="T:whiteMath.Functions.IFunctionExtensions">
      <summary>
            Static class containing extension methods for any kind of IFunction.
            </summary>
    </member>
    <member name="M:whiteMath.Functions.IFunctionExtensions.As_IFunction``2(System.Func{``0,``1})">
      <summary />
      <typeparam name="TArg" />
      <typeparam name="TVal" />
      <param name="func" />
      <returns />
    </member>
    <member name="M:whiteMath.Functions.IFunctionExtensions.GetFunctionTable``1(whiteMath.Functions.IFunction{``0,``0},System.Collections.Generic.IList{``0})">
      <summary>
            Creates the function table basing on the arguments list.
            The function table is represented by the point array.
            </summary>
      <example>
            If the argument list is { 1, 2 }, then the object returned is
            { (1, f(1)), (2, f(2)) }.
            </example>
      <typeparam name="T">The type of function argument and value.</typeparam>
      <param name="obj">The calling function object.</param>
      <param name="arguments">The argument parameter list.</param>
      <returns>The function table in the format of a point array.</returns>
    </member>
    <member name="M:whiteMath.Functions.IFunctionExtensions.GetFunctionTable``2(whiteMath.Functions.IFunction{``0,``0},``0,``0,System.Int32)">
      <summary>
            Creates the function table beginning from a certain point x0, 
            with a certain step and overall point count.
            The function table is represented by the point array.
            </summary>
      <typeparam name="T">The type of function argument and value.</typeparam>
      <typeparam name="C">The calculator for the function argument/value type.</typeparam>
      <param name="obj">The calling function object.</param>
      <param name="x0">The first point of the table.</param>
      <param name="step">The step between the table points.</param>
      <param name="pointCount">The overall point count.</param>
      <returns>The function table in the format of a point array.</returns>
    </member>
    <member name="M:whiteMath.Functions.IFunctionExtensions.GetFunctionTable``2(whiteMath.Functions.IFunction{``0,``0},whiteMath.BoundedInterval{``0,``1},System.Int32)">
      <summary>
            Creates the function table on a certain interval with a specified amount of table points.
            </summary>
      <typeparam name="T">The type of function argument and value.</typeparam>
      <typeparam name="C">The calculator for the function argument/value type.</typeparam>
      <param name="obj">The calling function object.</param>
      <param name="interval">The interval on which the table is created. Warning! Both of the interval bounds are counted INCLUSIVE!</param>
      <param name="pointCount">The overall point count of the function table</param>
      <returns>The function table in the format of point array.</returns>
    </member>
    <member name="M:whiteMath.Functions.IFunctionExtensions.PointwiseEquals``2(whiteMath.Functions.IFunction{``0,``0},whiteMath.Functions.IFunction{``0,``0},``0,System.Collections.Generic.IList{``0})">
      <summary>
            Checks whether the current function is equal to another at least within the
            finite set of points. 
            </summary>
      <typeparam name="T">The type of function argument/value.</typeparam>
      <typeparam name="C">The calculator for the function argument.</typeparam>
      <param name="obj">The calling function object.</param>
      <param name="another">The function object to test equality with.</param>
      <param name="epsilon">The upper epsilon bound of 'equality' criteria. If |f(x) - g(x)| &lt; eps, two functions are considered equal.</param>
      <param name="points">The points list to test equality on.</param>
      <returns>True if the functions are epsilon-equal within the points list passed, false otherwise.</returns>
    </member>
    <!-- Badly formed XML comment ignored for member "M:whiteMath.Functions.IFunctionExtensions.MaybeEquals``2(whiteMath.Functions.IFunction{``0,``0},whiteMath.Functions.IFunction{``0,``0},``0,``0[])" -->
    <member name="M:whiteMath.Functions.IFunctionExtensions.SignVariations``2(System.Collections.Generic.IList{whiteMath.Functions.IFunction{``0,``0}},whiteMath.Numeric{``0,``1})">
      <summary>
            Returns the number of sign variations in the function list for some certain
            point.
            </summary>
      <typeparam name="T">The type of polynom coefficients.</typeparam>
      <typeparam name="C">The type of polynom coefficients' calculator.</typeparam>
      <param name="list">The list of the polynoms to be analyzed.</param>
      <returns>The number of sign variations within the list. Zero values do not count.</returns>
    </member>
    <member name="M:whiteMath.Functions.IFunctionExtensions.MaximumSearchTernaryMethod``2(whiteMath.Functions.IFunction{``0,``0},whiteMath.BoundedInterval{``0,``1},``0,whiteMath.Functions.IFunctionExtensions.SearchFor)">
      <summary>
            Searches for the function maximum/minimum. using the ternary search method.
            
            Conditions:
            1a. If one searches for the maximum, f(x) should be STRICTLY increasing before the maximum and STRICTLY decreasing after the maximum.
            1b. If one searches for the minimum, f(x) should be STRICTLY decreasing before the minimum and STRICTLY increasing after the minimum.
            1*. Only one maximum/minimum should exist on the interval.
            </summary>
      <typeparam name="T">The type of function argument/value.</typeparam>
      <typeparam name="C">The calculator for the function argument.</typeparam>
      <param name="obj">The calling function object.</param>
      <param name="interval">The interval on which the maximum lies.</param>
      <param name="absolutePrecision">The desired precision of the argument value.</param>
      <param name="what">What to search for, maximum or minimum. Should be of 'SearchFor' enum type.</param>
      <returns>The 'x0' value such that f(x0) ~= max f(x) on the interval.</returns>
    </member>
    <member name="M:whiteMath.Functions.IFunctionExtensions.ZeroSearchBisectionMethod``2(whiteMath.Functions.IFunction{``0,``0},whiteMath.BoundedInterval{``0,``1},whiteMath.Numeric{``0,``1},whiteMath.Numeric{``0,``1})">
      <summary>
            Searches for the function root (zero value) on the interval [a; b].
            The interval is counted as with INCLUSIVE bounds!
            
            The conditions of method success:
            
            1. The function f(x) is continuous on the interval [a; b].
            2. The value f(a) and f(b) are of different signs.
            
            These conditions guarantee the existence of the zero on the interval [a; b].
            The method results in finding ONE of these zeroes.
            </summary>
      <typeparam name="T">The type of function argument/value.</typeparam>
      <typeparam name="C">The calculator for the argument type.</typeparam>
      <param name="obj">The calling function object.</param>
      <param name="interval">The interval on which the zero is searched. The value </param>
      <param name="epsilonArg">The epsilon value of the argument interval. The 'root' argument would be actually any value in the interval [-epsilon; +epsilon]</param>
      <param name="epsilonFunc">The epsilon value of the function zero. That means, that any function value in the interval [-epsilonFunc; epsilonFunc] is considered zero value. This parameter is usually set to absolute zero (so that only true 0 counts), but may become useful when the function calculation method contains precision errors resulting in zero becoming 'non-zero'.</param>
      <returns>The argument value resulting in f(x) ~= 0.</returns>
    </member>
    <member name="M:whiteMath.Functions.IFunctionExtensions.IntegralMonteCarloApproximation``2(whiteMath.Functions.IFunction{``0,``0},whiteMath.Randoms.IRandomBounded{``0},whiteMath.BoundedInterval{``0,``1},``0,``0)">
      <summary>
            Returns the Monte-Carlo stochastic approximation of the function integral.
            
            Requirements: calculator for the function argument/value should provide
            reasonable implementation of the 'fromDouble()' method.
            </summary>
      <typeparam name="T">The type of the function's argument/value.</typeparam>
      <typeparam name="C">The calculator for the function argument.</typeparam>
      <param name="obj">The calling function object.</param>
      <param name="generator">The uniform distribution (pseudo)random generator.</param>
      <param name="interval">The interval on which the integral will be approximated.</param>
      <param name="rectangleHeight">The height of the testing rectangle. Should be more than the function's absolute maximum on the interval tested, otherwise the method would return wrong results. On the other side, the difference between the height and the function's absolute maximum should not be very large as it will reduce the accuracy of the method. The ideal case is equality of the max f(x) on [a; b] and the rectangle height.</param>
      <param name="throwsCount">A positive integer value of overall tests.</param>
      <returns>The value approximating the function integral on the interval specified.</returns>
    </member>
    <member name="M:whiteMath.Functions.IFunctionExtensions.IntegralRectangleApproximation``2(whiteMath.Functions.IFunction{``0,``0},whiteMath.BoundedInterval{``0,``1},System.Int32)">
      <summary>
            Returns the rectangle approximation of the function integral.
            </summary>
      <typeparam name="T">The type of function argument/value.</typeparam>
      <typeparam name="C">The calculator for the argument type.</typeparam>
      <param name="obj">The calling function object.</param>
      <param name="interval">The interval to approximate the integral on.</param>
      <param name="pointCount">The overall point count used to calculate the integral.</param>
      <returns />
    </member>
    <member name="M:whiteMath.Functions.IFunctionExtensions.IntegralRectangleBoundedApproximation``2(whiteMath.Functions.IFunction{``0,``0},whiteMath.BoundedInterval{``0,``1},System.Int32)">
      <summary>
            Warning! Works correctly only for the MONOTONOUS (on the interval specified) function!
            Returns the bounded approximation of monotonous function's Riman integral.
            </summary>
      <typeparam name="T">The type of function argument/value.</typeparam>
      <typeparam name="C">The calculator for the argument type.</typeparam>
      <param name="obj">The calling function object.</param>
      <param name="interval">The interval to approximate the integral on.</param>
      <param name="pointCount">The overall point count used to approximate the integral value. The more this value is, the more precise is the calculation.</param>
      <returns>The interval in which the integral's value lies.</returns>
    </member>
    <member name="M:whiteMath.Functions.IFunctionExtensions.IntegralSimpsonMethod``2(whiteMath.Functions.IFunction{``0,``0},whiteMath.BoundedInterval{``0,``1},System.Int32)">
      <summary>
            Uses the Simpson formula to calculate the approximate integral area
            on the interval using an even number of points.
            </summary>
      <typeparam name="T">The type of function argument/value.</typeparam>
      <typeparam name="C">The calculator for function argument.</typeparam>
      <param name="obj">The calling function object.</param>
      <param name="interval">The interval on which the integral should be approximated. No matter if bounds are exclusive, they ARE COUNTED AS INCLUSIVE.</param>
      <param name="pointCount">The number of points that should be used to calculate the method.</param>
      <returns>The approximate value of the integral calculated by Simpson method.</returns>
    </member>
    <member name="M:whiteMath.Functions.IFunctionExtensions.IntegralSimpsonMethodError``2(whiteMath.Functions.IFunction{``0,``0},whiteMath.BoundedInterval{``0,``1},System.Int32,``0)">
      <summary>
            Returns the maximum error for the Simpson integral approximation method
            depending on the interval on which the calculation is performed,
            the maximum absolute value of the function's fourth derivative and the point count (should be even).
            </summary>
      <typeparam name="T">The type of function argument/value.</typeparam>
      <typeparam name="C">The calculator for the function argument.</typeparam>
      <param name="obj">The calling function object. Is not actually used.</param>
      <param name="interval">The interval on which the calculation is performed. No matter if bounds are exclusive, they are considered INCLUSIVE.</param>
      <param name="pointCount">The point count on the interval.</param>
      <param name="maxFourthDerivative">The maximum absolute value of the function's fourth derivative.</param>
      <returns>The maximum error of the simpson method.</returns>
    </member>
    <member name="M:whiteMath.Functions.IFunctionExtensions.IntegralSimpsonNeededPointCount``2(whiteMath.Functions.IFunction{``0,``0},whiteMath.BoundedInterval{``0,``1},``0,``0)">
      <summary>
            TODO: write description
            </summary>
      <typeparam name="T" />
      <typeparam name="C" />
      <param name="obj" />
      <param name="interval" />
      <param name="maxError" />
      <param name="maxFourthDerivative" />
      <returns />
    </member>
    <member name="T:whiteMath.Functions.IFunctionExtensions._FUNC_FUNCTION`2">
      <summary>
            Функция создаваемая на основе делегата Func(T,T).
            </summary>
    </member>
    <member name="T:whiteMath.Functions.CubicFunction`2">
      <summary>
            Represents a standard cubic function:
            y = a(x-x0)^3 + b(x-x0)^2 + c(x-x0) + d.
            </summary>
      <typeparam name="T" />
      <typeparam name="C" />
    </member>
    <member name="M:whiteMath.Functions.CubicFunction`2.#ctor(`0,`0,`0,`0,`0)">
      <summary>
            Creates a new instance of cubic function with
            explicitly specified coefficients.
            </summary>
      <param name="a">The cubic coefficient.</param>
      <param name="b">The quadratic coefficient.</param>
      <param name="c">The linear coefficient.</param>
      <param name="d">The free coefficient.</param>
      <param name="x0">The shift value. Positive value shifts the function to the right.</param>
    </member>
    <member name="M:whiteMath.Functions.CubicFunction`2.#ctor(whiteMath.General.Point{`0},whiteMath.General.Point{`0},`0,`0)">
      <summary>
            Creates the cubic function basing on the two points and two derivative values in the first point.
            </summary>
      <param name="firstPoint">The first point for the function to pass.</param>
      <param name="secondPoint">The second point for the function to pass.</param>
      <param name="firstDerivative">The value of the first derivative in the first point.</param>
      <param name="secondDerivative">The value of the second derivative in the first point.</param>
    </member>
    <member name="T:whiteMath.Functions.Interpolation`2">
      <summary>
            This class provides static methods
            to create continuous or piece functions
            interpolating the points arrays.
            <typeparam name="T">The type of numeric arguments of the function.</typeparam><typeparam name="C">The calculator for the numeric type T.</typeparam></summary>
    </member>
    <member name="M:whiteMath.Functions.Interpolation`2.CreatePieceLinearFunction(System.Collections.Generic.IList{whiteMath.General.Point{`0}},`0)">
      <summary>
            Creates a continuous piece-linear function from the points list.
            The user should also specify a default value to return
            when the function argument is out of the interpolation area bounds.
            </summary>
      <param name="points" />
      <param name="defaultValue" />
      <returns />
    </member>
    <member name="M:whiteMath.Functions.Interpolation`2.CreatePolynom(System.Collections.Generic.IList{whiteMath.General.Point{`0}})">
      <summary>
            Creates an interpolational polynom from the points array. 
            This polynom, according to the equivalence of the representation, 
            is unique.
            </summary>
      <param name="points" />
      <returns />
    </member>
    <member name="M:whiteMath.Functions.Interpolation`2.CreateNaturalCubicSpline(System.Collections.Generic.IList{whiteMath.General.Point{`0}},`0)">
      <summary>
            Creates a continuous natural cubic spline of defect 1.
            Max. continuous derivative of the spline is second.
            </summary>
      <param name="points" />
      <param name="defaultValue" />
      <returns />
    </member>
    <member name="T:whiteMath.Functions.PieceFunctionType">
      <summary>
            This enum determines the type of the piece function.
            </summary>
    </member>
    <member name="T:whiteMath.Functions.PieceFunction`2">
      <summary>
            Represents a piece function where argument intervals are mapped to their respective functions.
            </summary>
      <typeparam name="T" />
      <typeparam name="C" />
    </member>
    <member name="M:whiteMath.Functions.PieceFunction`2.#ctor(`0,System.Collections.Generic.KeyValuePair{whiteMath.BoundedInterval{`0,`1},whiteMath.Functions.IFunction{`0,`0}}[])">
      <summary>
            Creates a new instance of PieceFunction using a parameter list of KeyValuePair objects and a default value.
            </summary>
      <param name="pieces">The list of the KeyValuePair objects mapping intervals to functions.</param>
      <param name="defaultValue">The default value to return when the argument passed maps to no interval.</param>
    </member>
    <member name="M:whiteMath.Functions.PieceFunction`2.#ctor(System.Collections.Generic.IList{System.Collections.Generic.KeyValuePair{whiteMath.BoundedInterval{`0,`1},whiteMath.Functions.IFunction{`0,`0}}},`0)">
      <summary>
            Creates a new instance of PieceFunction using a list (or array) of KeyValuePair objects and a default value.
            </summary>
      <param name="pieces">The list of the KeyValuePair objects mapping intervals to functions.</param>
      <param name="defaultValue">The default value to return when the argument passed maps to no interval.</param>
    </member>
    <member name="M:whiteMath.Functions.PieceFunction`2.#ctor(System.Collections.Generic.IList{whiteMath.BoundedInterval{`0,`1}},System.Collections.Generic.IList{whiteMath.Functions.IFunction{`0,`0}},`0)">
      <summary>
            Creates a new instance of PieceFunction using two separate lists
            of intervals and functions. The lengths of the lists should be the same,
            with intervals[i] logically mapped to functions[i].
            </summary>
      <param name="intervals">The list of intervals for the piece function.</param>
      <param name="pieces">The list of functions for the piece function.</param>
      <param name="defaultValue">The default value to return when the argument is out of every interval's bounds.</param>
    </member>
    <member name="M:whiteMath.Functions.PieceFunction`2.selfCheck">
      <summary>
            Checks that intervals do not intersect.
            </summary>
    </member>
    <member name="M:whiteMath.Functions.PieceFunction`2.Value(`0)">
      <summary>
            Returns the value of the piece function.
            Searches through the intervals mapping to the functions,
            when the argument is within the interval, the value of the 
            respective function is returned.
            </summary>
      <param name="x">The argument of the function.</param>
      <returns>The value of the piece function in the specified point.</returns>
    </member>
    <member name="P:whiteMath.Functions.PieceFunction`2.Type">
      <summary>
            Gets the type of the piece function.
            </summary>
    </member>
    <member name="T:whiteMath.Functions.PieceFunction`2._KVPComparer">
      <summary>
            Сравнивает KeyValuePairs на основе левых границ их интервалов.
            ЗАМОРОЧЕНО!!!
            </summary>
    </member>
    <member name="T:whiteMath.Functions.Polynom`2">
      <summary>
            Represents a polynomial function of certain degree.
            The function is determined by the coefficients' array.
            It is supposed that coefficients of the polynom are all REAL.
            
            Warning! This class DOES NOT WORK with complex number types for coefficients!
            </summary>
      <typeparam name="T">The type of the polynom coefficients and values.</typeparam>
      <typeparam name="C">The calculator for the coefficient values.</typeparam>
    </member>
    <member name="M:whiteMath.Functions.Polynom`2.Derivative(System.Int32)">
      <summary>
            Returns the derivative of a certain degree for the polynom.
            If the current polynom is of degree N, its derivative of degree D 
            is also a polynomial function of degree Max(0; N-D).
            </summary>
      <param name="derivativeDegree" />
      <returns />
    </member>
    <member name="M:whiteMath.Functions.Polynom`2.IntegralMultiple(System.Int32)">
      <summary>
            Returns the polynom that is the multiple integral of the current polynom
            with specified integral degree.
            
            Equivalent to taking a single integral (each time - with zero free constant value)
            several times - but works significantly faster.
            
            All coefficients of the resulting polynom up to index 'integralDegree'
            are set to zero.
            </summary>
      <param name="integralDegree">The degree of the integral.</param>
      <returns>The multiple integral of the current polynom.</returns>
    </member>
    <member name="M:whiteMath.Functions.Polynom`2.Integral(whiteMath.Numeric{`0,`1})">
      <summary>
            Returns the polynom that is the integral of the current polynom
            with specified free constant value.
            </summary>
      <param name="freeConstant">The value of the integral's free constant.</param>
      <returns>The integral polynom object.</returns>
    </member>
    <member name="M:whiteMath.Functions.Polynom`2.Integral(whiteMath.General.Point{`0})">
      <summary>
            Returns the polynom that is the integral of the current polynom,
            which satisfies the condition of passing the specified point.
            </summary>
      <param name="point" />
      <returns />
    </member>
    <member name="M:whiteMath.Functions.Polynom`2.#ctor(whiteMath.Numeric{`0,`1}[])">
      <summary>
            Creates a new instance of Polynom object basing on the coefficients.
            </summary>
      <param name="coefficients" />
    </member>
    <member name="M:whiteMath.Functions.Polynom`2.#ctor(System.Collections.Generic.IList{whiteMath.Numeric{`0,`1}})">
      <summary>
            Creates a new instance of Polynom object basing on the coefficients
            array.
            </summary>
      <param name="coefficients" />
    </member>
    <member name="M:whiteMath.Functions.Polynom`2.#ctor(whiteMath.General.Point{`0}[])">
      <summary>
            Creates the polynom passing each of the points in the array.
            </summary>
    </member>
    <member name="M:whiteMath.Functions.Polynom`2.#ctor(System.Collections.Generic.IList{whiteMath.General.Point{`0}})">
      <summary>
            Creates the polynom passing each of the points in the array.
            </summary>
      <param name="points">The array of the points.</param>
    </member>
    <member name="M:whiteMath.Functions.Polynom`2.ToAnalyticFunction">
      <summary>
            Creates an analytic function from the polynomial.
            The calculation of its value would be performed without
            any Gorner's scheme, thus slower and less accurate. 
            </summary>
      <returns />
    </member>
    <member name="M:whiteMath.Functions.Polynom`2.Div(whiteMath.Functions.Polynom{`0,`1},whiteMath.Functions.Polynom{`0,`1},whiteMath.Functions.Polynom{`0,`1}@)">
      <summary>
            Performs the polynom division with the remainder.
            </summary>
      <param name="one">The dividend polynom.</param>
      <param name="two">The divisor polynom.</param>
      <param name="rem">The reference to the polynom to which the remainder result will be assigned.</param>
      <returns>The division result.</returns>
    </member>
    <member name="M:whiteMath.Functions.Polynom`2.Equals(whiteMath.Functions.Polynom{`0,`1})">
      <summary>
            Tests whether the current polynom is equal
            to another using objects' coefficients lists.
            </summary>
      <param name="polynom">The object to test equality with.</param>
      <returns>True if the current polynom is equal to the passed object, false otherwise.</returns>
    </member>
    <member name="M:whiteMath.Functions.Polynom`2.Equals(whiteMath.Functions.LagrangePolynom{`0,`1})">
      <summary>
            Tests whether the current polynom is equal
            to a certain LagrangePolynom by converting the latter
            to canonical polynomial form and comparing the coefficients.
            </summary>
      <param name="polynom">The object to test equality with.</param>
      <returns>True if the current polynom is equal to the passed object, false otherwise.</returns>
    </member>
    <member name="M:whiteMath.Functions.Polynom`2.ToString(whiteMath.Functions.Polynom{`0,`1}.PolynomStringRepresentationType)">
      <summary>
            Returns the string representation of the polynomial function
            as an array of coefficients - or, in the functional form
            i.e. 'f(x) = ...'.
            </summary>
      <param name="type">The type of the string representation.</param>
      <returns>The string representation of the current object.</returns>
    </member>
    <member name="M:whiteMath.Functions.Polynom`2.Clone">
      <summary>
            Creates a deep copy of the current Polynom object.
            </summary>
      <returns>A deep copy of the current Polynom object.</returns>
      <ensures inheritedFrom="M:System.ICloneable.Clone" inheritedFromTypeName="ICloneable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:whiteMath.Functions.Polynom`2.GreatestCommonDivisor(whiteMath.Functions.Polynom{`0,`1},whiteMath.Functions.Polynom{`0,`1})">
      <summary>
            Finds the greatest common divisor of two polynoms.
            
            You may wish to cancel the resulting polynom
            as its coefficients may be multiples of the same number.
            </summary>
      <param name="first">The first polynom.</param>
      <param name="second">The second polynom.</param>
      <returns>The greatest common divisor of </returns>
    </member>
    <member name="M:whiteMath.Functions.Polynom`2.GreatestCommonDivisor(whiteMath.Functions.Polynom{`0,`1})">
      <summary>
            Returns the greatest common divisor of the current
            polynom and the polynom passed as the argument.
            
            You may wish to cancel the returning polynom
            as the coefficients may be multiples of the same number.
            </summary>
      <param name="another">The second polynom.</param>
      <returns>The greatest common divisor of the current polynom and the other.</returns>
    </member>
    <member name="M:whiteMath.Functions.Polynom`2.IntegerCoefficientsCancel">
      <summary>
            Cancels the polynom with integer coefficients by the greatest common divisor of
            its coefficients.
            
            The resulting polynom contains all the same roots, but its value range is less than
            of the current.
            
            If either some of the coefficients isn't integer or GCD = 1, the current polynom will be returned.
            <returns>The polynom with cancelled coefficients containing all the same roots.</returns></summary>
    </member>
    <member name="M:whiteMath.Functions.Polynom`2.DifferentRealRootsAmount">
      <summary>
            Returns the overall amount of different real polynom roots.
            Some of the roots may be multiple.
            </summary>
      <returns>The overall amount of different real polynom roots.</returns>
    </member>
    <member name="P:whiteMath.Functions.Polynom`2.Degree">
      <summary>
            Returns the degree of the polynom, that is, the
            maximum power of the X in the analytic notation.
            </summary>
    </member>
    <member name="P:whiteMath.Functions.Polynom`2.IsZero">
      <summary>
            Tests whether the current polynom equals zero.
            </summary>
    </member>
    <member name="P:whiteMath.Functions.Polynom`2.NormedPolynom">
      <summary>
            Returns the polynom normed by its high-order coefficient.
            The high-order coefficient of the resulting polynom would be equal to 1.
            
            The polynom returned would contain all the same roots as the current.
            </summary>
    </member>
    <member name="P:whiteMath.Functions.Polynom`2.Item(System.Int32)">
      <summary>
            Returns the polynom coefficient at the specified X power.
            </summary>
      <param name="index">The X power which coefficient is to be returned.</param>
      <returns>The respective polynom coefficient at the specified X power.</returns>
    </member>
    <member name="P:whiteMath.Functions.Polynom`2.RealRootGuaranteedInterval">
      <summary>
            Returns the interval in which all of the polynom
            real roots are.
            </summary>
    </member>
    <member name="P:whiteMath.Functions.Polynom`2.RealRootPositiveInterval">
      <summary>
            Returns the interval in which all of the polynom's positive roots are.
            Uses the Lagrange theorem.
            </summary>
    </member>
    <member name="P:whiteMath.Functions.Polynom`2.RealRootsNegativeInterval">
      <summary>
            Returns the interval in which all of the polynom's positive roots are.
            Uses the Lagrange theorem.
            </summary>
    </member>
    <member name="P:whiteMath.Functions.Polynom`2.SturmPolynomSequence">
      <summary>
            Returns the Sturm polynom sequence for the current polynom.
            Used in Sturm theorem which helps to find the number of real roots
            contained in some interval.
            
            nrr(f(x), x in (a; b)) = V(S(a)) - V(S(b));
            
            Where V(S(x)) is number of sign changes in the polynom's Sturm sequence.
            Zeroes of the sequence do not count.
            
            For example, if the Sturm sequence at some point 'x' produces values -1, 1, 0, 1, then V(S(x)) = 1.
            </summary>
      <returns>The Sturm polynom sequence for the current polynom.</returns>
    </member>
    <member name="T:whiteMath.Functions.Polynom`2.PolynomStringRepresentationType">
      <summary>
            Determines the type of polynom's string representation
            in the ToString() method.
            </summary>
    </member>
    <member name="M:whiteMath.Functions.PolynomExtensions.InfinitySignVariations``2(System.Collections.Generic.IList{whiteMath.Functions.Polynom{``0,``1}},System.Boolean)">
      <summary>
            Gets the amount of polynom sequence's sign variations either
            at positive or negative infinity using polynom's degree and the sign of its higher coefficient.
            
            Works fast.
            </summary>
      <typeparam name="T">The type of polynom coefficients.</typeparam>
      <typeparam name="C">The calculator for the coefficients' type.</typeparam>
      <param name="list">The sequence of polynoms to be evaluated for sign variations.</param>
      <param name="negativeInfinity">If this flag is set to FALSE, the evalution is at positive infinity. Otherwise, at negative infinity.</param>
      <returns>The number of polynom's sign variations.</returns>
    </member>
    <member name="T:whiteMath.Functions.IFunctionAction`2">
      <summary>
            Represents the precompiled function action.
            </summary>
    </member>
    <member name="T:whiteMath.Functions.LinearFunction`2">
      <summary>
            Represents the standard linear function: f(x) = kx + b.
            </summary>
      <typeparam name="T">The type of both function argument and value.</typeparam>
      <typeparam name="C">The calculator for the T type.</typeparam>
    </member>
    <member name="M:whiteMath.Functions.LinearFunction`2.#ctor(`0,`0)">
      <summary>
            Constructs the linear function on the basis of tangent coefficient 'k' and the free member 'b'.
            </summary>
      <param name="k" />
      <param name="b" />
    </member>
    <member name="M:whiteMath.Functions.LinearFunction`2.#ctor(whiteMath.General.Point{`0},whiteMath.General.Point{`0})">
      <summary>
            Constructs the linear function on the basis of two points passed.
            </summary>
      <param name="firstPoint" />
      <param name="secondPoint" />
    </member>
    <member name="T:whiteMath.Functions.PrecompiledFunction.Argument">
      <summary>
            The function node symbolizing the argument.
            </summary>
    </member>
    <member name="T:whiteMath.Functions.SyntaxAnalyzer">
      <summary>
            Class used for syntax analysis of function action lists.
            </summary>
    </member>
    <member name="T:whiteMath.Graphers.GraphicDrawerGraphClickEventHandler">
      <summary>
            Handler for the event called when the user clicks on the graph.
            </summary>
      <param name="source" />
      <param name="e" />
    </member>
    <member name="T:whiteMath.Graphers.GraphicDrawerGraphClickEventArgs">
      <summary>
            The event arguments for GraphicDrawerGraphClick.
            Contains the coordinates of the pixel clicked in two forms:
            
            1) Pixel component
            2) Function component
            </summary>
    </member>
    <member name="P:whiteMath.Graphers.GraphicDrawerGraphClickEventArgs.PixelClicked">
      <summary>
            Gets the relative (to the upper-left point) coordinates of the image pixel clicked.
            </summary>
    </member>
    <member name="P:whiteMath.Graphers.GraphicDrawerGraphClickEventArgs.X">
      <summary>
            Gets the X coordinate in the real (non-screen, but functional) coordinate system.
            </summary>
    </member>
    <member name="P:whiteMath.Graphers.GraphicDrawerGraphClickEventArgs.Y">
      <summary>
            Gets the Y coordinate in the real (non-screen, but functional) coordinate system.
            </summary>
    </member>
    <member name="T:whiteMath.Graphers.GraphicDrawer">
      <summary>
            Windows form for drawing graphs using Grapher objects.
            Suitable for bounded and unbounded graphers.
            
            author: Pavel Kabir
            revised: 21.01.2010
            version: 1.1
            </summary>
    </member>
    <member name="M:whiteMath.Graphers.GraphicDrawer.checkBoxWindowed_CheckedChanged(System.Object,System.EventArgs)">
      <summary>
            Обработчик события на то, если пользователь хочет изменить разрешение.
            </summary>
      <param name="sender" />
      <param name="e" />
    </member>
    <member name="M:whiteMath.Graphers.GraphicDrawer.restoreTextBoxesInitial">
      <summary>
            Restores the initial xMin and xMax values in the textboxes.
            </summary>
    </member>
    <member name="M:whiteMath.Graphers.GraphicDrawer.setTextBoxesWithValues">
      <summary>
            Sets the textboxes with new xMin and so on values.
            </summary>
    </member>
    <member name="M:whiteMath.Graphers.GraphicDrawer.buttonRestore_Click(System.Object,System.EventArgs)">
      <summary>
            Восстанавливает умолчания по границам рисования
            и перерисовывает график.
            </summary>
      <param name="sender" />
      <param name="e" />
    </member>
    <member name="M:whiteMath.Graphers.GraphicDrawer.checkBoxNotWindowed_CheckedChanged(System.Object,System.EventArgs)">
      <summary>
            Проверка, указал ли пользователь иное разрешение,
            чем разрешение рабочего окна.
            </summary>
      <param name="sender" />
      <param name="e" />
    </member>
    <member name="M:whiteMath.Graphers.GraphicDrawer.ShowImageInPictureBox">
      <summary>
            Показывает кусочек каринки в pictureBox с учетом текущих координат.
            </summary>
    </member>
    <member name="M:whiteMath.Graphers.GraphicDrawer.buttonGraphToFile_Click(System.Object,System.EventArgs)">
      <summary>
            Сохраняет в файл построенный график.
            </summary>
      <param name="sender">Источник события</param>
      <param name="e">Параметры события</param>
    </member>
    <member name="F:whiteMath.Graphers.GraphicDrawer.Do_Not_Check_Correctness">
      <summary>
            Used to avoid parsing text values while graphing.
            </summary>
    </member>
    <member name="F:whiteMath.Graphers.GraphicDrawer.components">
      <summary>
            Required designer variable.
            </summary>
    </member>
    <member name="M:whiteMath.Graphers.GraphicDrawer.Dispose(System.Boolean)">
      <summary>
            Clean up any resources being used.
            </summary>
      <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
    </member>
    <member name="M:whiteMath.Graphers.GraphicDrawer.InitializeComponent">
      <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
    </member>
    <member name="M:whiteMath.Graphers.Components.MultiGrapherPens.getCurveColor(System.Int32)">
      <summary>
            Returns the user-selected color for the curve with specified index in the multigrapher's list.
            </summary>
      <param name="multiGrapherIndex">A zero-based index of grapher contained in the multigrapher's list.</param>
      <returns />
    </member>
    <member name="M:whiteMath.Graphers.Components.MultiGrapherPens.getCurveColor">
      <summary>
            Returns the user-selected color for the curve.
            </summary>
      <returns />
    </member>
    <member name="M:whiteMath.Graphers.Components.MultiGrapherPens.getCurveColors">
      <summary>
            Returns the color array for the multigrapher.
            </summary>
      <returns />
    </member>
    <member name="M:whiteMath.Graphers.Components.MultiGrapherPens.getAxisColor">
      <summary>
            Returns the user-selected color for the axis.
            </summary>
      <returns />
    </member>
    <member name="M:whiteMath.Graphers.Components.MultiGrapherPens.setGrapher(whiteMath.Graphers.AbstractGrapher)">
      <summary>
            Set grapher!
            </summary>
      <param name="grapher" />
    </member>
    <member name="F:whiteMath.Graphers.Components.MultiGrapherPens.components">
      <summary> 
            Required designer variable.
            </summary>
    </member>
    <member name="M:whiteMath.Graphers.Components.MultiGrapherPens.Dispose(System.Boolean)">
      <summary> 
            Clean up any resources being used.
            </summary>
      <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
    </member>
    <member name="M:whiteMath.Graphers.Components.MultiGrapherPens.InitializeComponent">
      <summary> 
            Required method for Designer support - do not modify 
            the contents of this method with the code editor.
            </summary>
    </member>
    <member name="T:whiteMath.Graphers.LineType">
      <summary>
            The enumeration is used to specify the line type for <c>GraphingArgs</c> class.
            </summary>
      <see cref="T:whiteMath.Graphers.GraphingArgs" />
    </member>
    <member name="F:whiteMath.Graphers.LineType.Line">
      <summary>
            With this <c>LineType</c>, the graph will be created 
            as a sequence of simple lines connecting consecutive pairs of points.
            </summary>
    </member>
    <member name="F:whiteMath.Graphers.LineType.CardinalCurve">
      <summary>
            With this <c>LineType</c>, the graph will be created
            as a smooth cardinal spline going through the points.
            </summary>
    </member>
    <member name="F:whiteMath.Graphers.LineType.Polygon">
      <summary>
            Whith this <c>LineType</c>, the graph will be created
            as a closed polygon.
            </summary>
    </member>
    <member name="T:whiteMath.Graphers.GraphingArgs">
      <summary>
            This structure encapsulates the drawing parameters 
            for the <c>Graph()</c> method of <c>Graphers</c>.
            </summary>
      <see cref="T:whiteMath.Graphers.IGrapher" />
      <see cref="T:whiteMath.Graphers.AbstractGrapher" />
      <see cref="T:whiteMath.Graphers.StandardGrapher" />
      <invariant>this.IndentFromBounds &gt;= 0</invariant>
    </member>
    <member name="M:whiteMath.Graphers.GraphingArgs.#ctor(System.Int32,System.Drawing.Brush,System.Drawing.Pen,System.Drawing.Font,System.Drawing.Pen,System.Drawing.Pen,whiteMath.Graphers.LineType)">
      <summary>
            Initializes the <c>GraphingArgs</c> structure
            with drawing parameters.
            </summary>
      <param name="indentFromBounds">
            The indent (in pixels) from the boundaries of drawing area.
            </param>
      <param name="backgroundBrush">
            The brush which will be used to fill
            the background of the drawing area.
            If <c>null</c>, no background will be drawn.
            </param>
      <param name="coordPen">
            The pen which will be used to draw the axes.
            If <c>null</c>, no axes will be drawn.
            </param>
      <param name="coordFont">
            The font which will be used to draw the values
            on the axes.
            If <c>null</c>, no values will be drawn on the axes.
            </param>
      <param name="gridPen">
            The pen which will be used to draw the
            coordinate grid.
            If <c>null</c>, no grid will be drawn.
            </param>
      <param name="curvePen">
            The pen which will be used to draw the graph curve. 
            If <c>null</c>, the graph curve won't be drawn.
            </param>
      <param name="curveType" />
      <requires description="The indent from image bounds must be a non-negative value." exception="T:System.ArgumentOutOfRangeException" csharp="indentFromBounds &gt;= 0" vb="indentFromBounds &gt;= 0">indentFromBounds &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">indentFromBounds &lt;0</exception>
    </member>
    <member name="M:whiteMath.Graphers.GraphingArgs.Clone">
      <summary>
            Creates an exact, independent copy of the GraphingArgs structure.
            </summary>
      <returns>An exact, independent copy of the GraphingArgs structure.</returns>
      <ensures inheritedFrom="M:System.ICloneable.Clone" inheritedFromTypeName="ICloneable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:whiteMath.Graphers.GraphingArgs.IndentFromBounds">
      <summary>
            Gets or sets the indent from the boundaries of drawing area, in pixels.
            </summary>
      <getter>
        <ensures csharp="result &gt;= 0" vb="result &gt;= 0">result &gt;= 0</ensures>
      </getter>
      <setter>
        <requires csharp="value &gt;= 0" vb="value &gt;= 0">value &gt;= 0</requires>
      </setter>
    </member>
    <member name="P:whiteMath.Graphers.GraphingArgs.CurvePen">
      <summary>
            Gets or sets the pen which will be used to draw the graph curve. 
            If <c>null</c>, the graph curve won't be drawn.
            </summary>
    </member>
    <member name="P:whiteMath.Graphers.GraphingArgs.CoordPen">
      <summary>
            Gets or sets the pen which will be used to draw the axes.
            If <c>null</c>, no axes will be drawn.
            </summary>
    </member>
    <member name="P:whiteMath.Graphers.GraphingArgs.CoordFont">
      <summary>
            Gets or sets the font which will be used to draw the values
            on the axes.
            If <c>null</c>, no values will be drawn on the axes.
            </summary>
    </member>
    <member name="P:whiteMath.Graphers.GraphingArgs.GridPen">
      <summary>
            Gets or sets the pen which will be used to draw the
            coordinate grid.
            If <c>null</c>, no grid will be drawn.
            </summary>
    </member>
    <member name="P:whiteMath.Graphers.GraphingArgs.BackgroundBrush">
      <summary>
            Gets or sets the brush which will be used to fill
            the background of the drawing area.
            If <c>null</c>, no background will be drawn.
            </summary>
    </member>
    <member name="P:whiteMath.Graphers.GraphingArgs.CurveType">
      <summary>
            Gets or sets the curve type of the graph.
            </summary>
    </member>
    <member name="T:whiteMath.Graphers.HistoGraphingArgs">
      <summary>
            This structure encapsulates the drawing parameters for
            graphing methods of <c>HistoGraphers</c>.
            </summary>
      <see cref="T:whiteMath.Graphers.HistoGrapher" />
    </member>
    <member name="P:whiteMath.Graphers.HistoGraphingArgs.IncrementDirection">
      <summary>
            Gets or sets the orientation of the histogram, that is,
            the increment direction of the columns.
            </summary>
    </member>
    <member name="P:whiteMath.Graphers.HistoGraphingArgs.ColumnBrushes">
      <summary>
            Gets or sets the dictionary that maps <c>HistoGrapher</c>'s point names
            to brushes which will be used to draw corresponding columns on the histogram.
            If <c>null</c>, no columns will be drawn.
            This dictionary must contain all point names of <c>HistoGrapher</c>.
            </summary>
      <see cref="P:whiteMath.Graphers.HistoGrapher.PointNames" />
      <see cref="!:HistoGrapher.CreateBrushes" />
    </member>
    <member name="P:whiteMath.Graphers.HistoGraphingArgs.PointAliases">
      <summary>
            Gets or sets the dictionary that maps <c>HistoGrapher</c>'s point names
            to aliases which will instead be drawn
            on the histogram.
            If <c>null</c>, existing point names will be used.
            </summary>
    </member>
    <member name="P:whiteMath.Graphers.HistoGraphingArgs.ColumnSeparatorPen">
      <summary>
            Gets or sets the pen which will be used to separate columns vertically from each other.
            If <c>null</c>, no separator will be drawn.
            </summary>
    </member>
    <member name="P:whiteMath.Graphers.HistoGraphingArgs.ColumnValueLinePen">
      <summary>
            Gets or sets the pen which will be used to connect the uppermost edge of the column
            with the axis (where the text specifying the column's value is usually located).
            If <c>null</c>, no such lines will be drawn.
            </summary>
    </member>
    <member name="P:whiteMath.Graphers.HistoGraphingArgs.AutoValueLinePen">
      <summary>
            Gets pr sets the pen which will be used to draw lines going out from
            axis' automatic values and to the opposite border of the histogram.
            </summary>
    </member>
    <member name="P:whiteMath.Graphers.HistoGraphingArgs.InsideColumnValueFont">
      <summary>
            A font which will be used to draw values inside the columns.
            If <c>null</c>, no values will be drawn inside the column.
            </summary>
    </member>
    <member name="P:whiteMath.Graphers.HistoGraphingArgs.InsideColumnValuePosition">
      <summary>
            A value indicating the alignment of values inside the columns.
            (if these values are drawn at all).
            </summary>
    </member>
    <member name="P:whiteMath.Graphers.HistoGraphingArgs.AxisValueFont">
      <summary>
            A font which will be used to draw values on the axis.
            </summary>
    </member>
    <member name="T:whiteMath.Graphers.IGrapher">
      <summary>
            Interface written to support minimal grapher functionality.
            </summary>
    </member>
    <member name="M:whiteMath.Graphers.IGrapher.Graph(System.Drawing.Image,whiteMath.Graphers.GraphingArgs)">
      <summary>
            Graph method supported by graphers with bounded graphing range.
            The method signature assumes that the grapher knows on which range to graph.
            
            CONTRACT:
            
            Recommended to provide a working implementation.
            
            If the grapher is unbounded(i.e. cannot graph without explicitly
            specifying the range), then the method should throw
            a NotSupportedException.
            </summary>
      <param name="dest">Image object on which the graph should be painted.</param>
      <param name="ga">GraphingArgs object incapsulating the graphing parameters.</param>
    </member>
    <member name="M:whiteMath.Graphers.IGrapher.Graph(System.Drawing.Image,whiteMath.Graphers.GraphingArgs,System.Double,System.Double)">
      <summary>
            Graph method supported by graphers with either bounded or unbounded range.
            
            The method signature assumes that the implementation class knows how to calculate
            the function bounds (yMin and yMax) knowing the argument bounds.
            
            CONTRACT:
            
            A working implementation SHOULD be provided for any grapher.
            However, the method is allowed throw a NotSupportedException, if:
            
                a) The implementation class allows the function go to infinity on the argument range, 
                so the graphing should only be made on a fully specified ranges,
                both X and Y interval.
                
            </summary>
      <param name="dest">Image object on which the graph should be painted.</param>
      <param name="ga">GraphingArgs object incapsulating the graphing parameters.</param>
      <param name="xMin">Lower inclusive bound of the argument graphing range.</param>
      <param name="xMax">Higher inclusive bound of the argument graphing range.</param>
    </member>
    <member name="M:whiteMath.Graphers.IGrapher.Graph(System.Drawing.Image,whiteMath.Graphers.GraphingArgs,System.Double,System.Double,System.Double,System.Double)">
      <summary> 
            Graph method supported by any graphers with either bounded or unbounded range.
            
            CONTRACT: the implementation MUST be provided for every grapher.
            </summary>
      <param name="dest">Image object on which the graph should be painted.</param>
      <param name="ga">GraphingArgs object incapsulating the graphing parameters.</param>
      <param name="xMin">Lower inclusive bound of the argument graphing range.</param>
      <param name="xMax">Higher inclusive bound of the argument graphing range.</param>
      <param name="yMin">Lower inclusive bound of the function graphing range.</param>
      <param name="yMax">Higher inclusive bound of the agrument graphing range.</param>
    </member>
    <member name="T:whiteMath.Graphers.IGrapherBounded">
      <summary>
             A grapher interface type that allows user to know about the minimums and maximums 
             of X and Y axis respectively.
            
             Grapher implementing this interface is expected to be bounded
             (by argument or by both argument and function values)
             
             CONTRACT: at least Axis1 properties should return non-infinity values
             (because otherwise the bounded grapher makes no sense), 
             
             except for the MultiGrapher, which can be fully unbounded.
             MultiGrapher implements this interface for the sake
             of knowing the argument and function extreme values - in case of containing only 
             bounded graphers inside.
             
             <see>MultiGrapher</see></summary>
    </member>
    <member name="P:whiteMath.Graphers.IGrapherBounded.MinAxis1">
      <summary>
            Returns the minimum value of the grapher argument.
            </summary>
    </member>
    <member name="P:whiteMath.Graphers.IGrapherBounded.MaxAxis1">
      <summary>
            Returns the maximum value of the grapher argument.
            </summary>
    </member>
    <member name="P:whiteMath.Graphers.IGrapherBounded.MinAxis2">
      <summary>
            Returns the minimum value of the grapher function.
            </summary>
    </member>
    <member name="P:whiteMath.Graphers.IGrapherBounded.MaxAxis2">
      <summary>
            Returns the maximum value of the grapher function.
            </summary>
    </member>
    <member name="M:whiteMath.Graphers.GrapherAddMultiplyConverter.#ctor(System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Allows automatic conversion of the points array by formula: 
            
            xNew = x*k1 + s1; 
            yNew = y*k2 + s2; 
            
            </summary>
      <param name="k1">Axis X multiply coefficient</param>
      <param name="s1">Axis X addition coefficient</param>
      <param name="k2">Axis Y multiply coefficient</param>
      <param name="s2">Axis Y addition coefficient</param>
    </member>
    <member name="M:whiteMath.Graphers.GrapherAddMultiplyConverter.convertArrayOfX(System.Double[])">
      <summary>
            Makes a new array by formula xNew = xOld * k1 + s1;
            </summary>
      <param name="xArray">A source array of X</param>
      <returns>New array!</returns>
    </member>
    <member name="M:whiteMath.Graphers.GrapherAddMultiplyConverter.deConvertArrayOfX(System.Double[])">
      <summary>
            Restores the former array by formula xOld = (xNew - s1)/k1
            </summary>
      <param name="modifiedArray" />
      <returns />
    </member>
    <member name="M:whiteMath.Graphers.GrapherAddMultiplyConverter.convertArrayOfY(System.Double[])">
      <summary>
            Makes a new array by formula yNew = yOld * k2 + s2;
            </summary>
      <param name="yArray">A source array of Y</param>
      <returns>New array!</returns>
    </member>
    <member name="M:whiteMath.Graphers.GrapherAddMultiplyConverter.deConvertArrayOfY(System.Double[])">
      <summary>
            Restores the former array by formula yOld = (yNew - s2)/k2
            </summary>
      <param name="modifiedArray" />
      <returns />
    </member>
    <member name="M:whiteMath.Graphers.GrapherHelper.GetBlankImage(System.Int32,System.Int32,System.Drawing.Color)">
      <summary>
            Gets a blank image with specified background color.
            </summary>
      <param name="width">A positive width in pixels.</param>
      <param name="height">A positive height in pixels.</param>
      <param name="backgroundColor">The background color.</param>
      <returns />
    </member>
    <member name="M:whiteMath.Graphers.GrapherHelper.SaveImageToFile(System.Drawing.Image,System.String,System.Drawing.Imaging.ImageFormat)">
      <summary>
            Saves the specified image to a file.
            Calls the standard Image.Save method.
            </summary>
      <param name="img">The image object you want to save.</param>
      <param name="FileName">The full file name.</param>
      <param name="ImageType">ImageFormat object to specify the image format.</param>
    </member>
    <member name="T:whiteMath.Graphers.AbstractGrapher">
      <summary>
            Represents a bounded or unbounded grapher.
            
            Provides a standard interface for all of the graphers.
            By default contains no points array, that is, unbounded,
            but can be extended to be bounded.
            
            For unbounded subclasses, the overriding of methods Graph without
            mentioning the argument range is recommended to throw a 
            <code>NotSupportedException</code>.
            
            !!! It is recommended that you extend from this class, not from the
            !!! IGrapher interface.
            </summary>
    </member>
    <member name="M:whiteMath.Graphers.AbstractGrapher.copyGrapherSignature(whiteMath.Graphers.AbstractGrapher,whiteMath.Graphers.AbstractGrapher)">
      <summary>
            Copies the following characteristics from one grapher to another:
                1. Axis names.
                2. Axis "X" and "Y" coordinate steps.
                3. Axis numbers formatters.
                
                It DOES NOT copy the grapher name, points array etc. 
                Just the signature of the grapher.
                
                It is used in cases when you subclass the AbstractGrapher
                and want to delegate the grapher functionality to the
                inner object using composition.
                (<see>FunctionGrapher</see>)
            </summary>
      <param name="from">Grapher from which the copying is produced.</param>
      <param name="to">Grapher which is to receive the signature.</param>
    </member>
    <member name="M:whiteMath.Graphers.AbstractGrapher.getRecommendedIndentFromBorder(System.Drawing.Graphics,System.Drawing.Font,System.String,System.String)">
      <summary>
            Returns the value of recommended indent from image borders 
            depending on the font and formatters used to draw axis names and numbers on the graph.
            
            The value returned is measured using the screen graphics resolution and axis names length.
            </summary>
      <param name="?" />
      <returns />
    </member>
    <member name="M:whiteMath.Graphers.AbstractGrapher.getRecommendedIndentFromBorder(System.Drawing.Graphics,System.Drawing.Font)">
      <summary>
            Overloaded version of the method that uses encapsulated Grapher formatters.
            </summary>
      <param name="G" />
      <param name="coordinateFont" />
      <returns />
    </member>
    <member name="T:whiteMath.Graphers.StandardGrapher">
      <summary>
            Represents a standard grapher with points array inside.
            Class itself is abstract, but can be derived from.
            
            Features:
            
                1. Provides methods to get new graphers by argument [OR] by indexes
                2. Provides methods to get minimal and maximal argument and function values.
                
                3. Is bounded, that is, calling Graph() without mentioning a range
                   will result in a call equivalent to drawing the overall points array.
                   No exception is thrown.
                4. Is a multi-range grapher suitable for drawing discontinuous functions
                   with a bounded argument range.
                
                5. ???   
                6. PROFIT!!!
                
            </summary>
    </member>
    <member name="M:whiteMath.Graphers.StandardGrapher.GetPointsArray">
      <summary>
            Gets the grapher points array as specified.
            </summary>
      <returns />
    </member>
    <member name="M:whiteMath.Graphers.StandardGrapher.GetAxis1Array">
      <summary>
            Gets the Axis1 data array as specified.
            </summary>
      <returns />
    </member>
    <member name="M:whiteMath.Graphers.StandardGrapher.GetAxis2Array">
      <summary>
            Gets the Axis2 data array as specified.
            </summary>
      <returns />
    </member>
    <member name="M:whiteMath.Graphers.StandardGrapher.newGrapherByArgumentBounds(System.Double,System.Double)">
      <summary>
            Returns the standard array grapher scaled by argument bounds.
            Does not contain any points whose X argument is out of the bounds specified.
            </summary>
      <param name="Axis1Min">The lower bound of the argument scaling.</param>
      <param name="Axis1Max">The upper bound of the argument scaling.</param>
      <returns />
    </member>
    <member name="M:whiteMath.Graphers.StandardGrapher.newGrapherByIndexBounds(System.Int32,System.Int32)">
      <summary>
            Returns the standard array grapher scaled by points array indices.
            </summary>
      <param name="minInd">The lower index of points array to copy to the new grapher.</param>
      <param name="maxInd">The upper index of points array to copy to the new grapher.</param>
      <returns />
    </member>
    <member name="M:whiteMath.Graphers.StandardGrapher.MakeGraphingArray">
      <summary>
            Creates a mid-ready graphing array with all the coefficients
            accounted.
            </summary>
    </member>
    <member name="M:whiteMath.Graphers.StandardGrapher.MakeGraphingArray(System.Double,System.Double,System.Double,System.Double)">
      <summary />
      <param name="xMin">The lower X boundary of the range.</param>
      <param name="xMax">The upper X boundary of the range.</param>
      <param name="yMin">The lower Y boundary of the range.</param>
      <param name="yMax">The upper Y boundary of the range.</param>
    </member>
    <member name="M:whiteMath.Graphers.StandardGrapher.findYminYmax(System.Double,System.Double,System.Double@,System.Double@)">
      <summary>
            для метода Graph, который не знает об области
            значений данного диапазона.
            </summary>
    </member>
    <member name="M:whiteMath.Graphers.StandardGrapher.DrawCoordGrid(System.Drawing.Graphics,System.Drawing.Pen,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Double,System.Double)">
      <summary>
            Draws the coordinate grid.
            </summary>
    </member>
    <member name="M:whiteMath.Graphers.StandardGrapher.DrawCoordinates(System.Drawing.Graphics,System.Drawing.Pen,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Double,System.Double)">
      <summary>
            Рисует линии координатных осей с насечками.
            А также внешнюю окантовку графика (с насечками +))
            </summary>
    </member>
    <member name="T:whiteMath.Graphers.Services.DotListComparer`2">
      <summary>
            Compares the two points on the basis of their X coordinate.
            </summary>
      <typeparam name="T">The type of point coordinates.</typeparam>
    </member>
    <member name="M:whiteMath.Graphers.Services.GrapherArrayWork.CheckForCastInfinities(System.Collections.Generic.IList{whiteMath.General.Point{System.Double}})">
      <summary>
            Checks for infinities which may occur while converting from double to float.
            </summary>
      <param name="pointsArray" />
      <returns />
    </member>
    <member name="T:whiteMath.Graphers.GrapherGraphException">
      <summary>
            This type of exception is thrown when the graphing operation has not been completed successfully.
            </summary>
    </member>
    <member name="P:whiteMath.Graphers.FunctionGrapher.DotCount">
      <summary>
            How many points to calculate in the mentioned diap.
            Graphing quality depends on it. Usually 1000 is enough.
            </summary>
    </member>
    <member name="T:whiteMath.Graphers.GrapherExtensionMethods">
      <summary>
            Методы расширения, используемые при работе с функциями.
            </summary>
    </member>
    <member name="M:whiteMath.Graphers.GrapherExtensionMethods.isNormalNumber(System.Double)">
      <summary>
            Checks whether the double value is 'normal', i.e. not an infinity or NaN.
            </summary>
      <param name="a" />
      <returns />
    </member>
    <member name="M:whiteMath.Graphers.GrapherExtensionMethods.CreateFunctionGrapher(whiteMath.Functions.IFunction{System.Double,System.Double})">
      <summary>
            Creates the FunctionGrapher for the calling IFunction object.
            </summary>
      <param name="func" />
      <returns />
    </member>
    <member name="T:whiteMath.Graphers.MultiGrapher">
      <summary>
            Support multiple graphs on a single surface.
            Because the grapher objects passed to the constructor can be a mix of bounded
            and unbounded graphers, the graph methods expects you to explicitly mention
            the graphing diap.
            
            Once again: call ONLY the <code>Graph()</code> methods with ALL of the bounds
            written explicitly. Otherwise, it would throw NotSupportedException.
            
            Although the grapher derives from the IBoundedGrapher interface,
            be careful as its properties <code>MinAxis1</code>, <code>MaxAxis1</code>,
            will return non-infinity values --ONLY-- if the graphers passed to the constructor 
            are bounded and provide explicit implementation of these methods respectively, 
            deriving from the <code>IGrapherBounded</code> interface.
            
            Values of the MinAxis2, MaxAxis2 should always be checked for infinities
            because of the possibly infinite function range on the bounded argument diap.
            
            For example, <example>imagine a FunctionGrapher containing f(x)=tg(x).</example>
            The argument range may be finite on (0; 2*pi), but, the function varies from -inf to +inf.
            
            <see>FunctionGrapher</see>
            
            Otherwise, if a single unbounded grapher comes around, these properties will return
            infinity values.
            
            <see>IGrapherBounded</see>
            
            Author: Pavel Kabir
            Version: 0.9
            Revised: 04.07.2010
            </summary>
    </member>
    <member name="M:whiteMath.Graphers.MultiGrapher.setBoundsToInfinities">
      <summary>
            Service method used in "findMinsAndMaxes".
            in case when one of the graphers is unbounded.
            </summary>
    </member>
    <member name="M:whiteMath.Graphers.MultiGrapher.getGrapherList">
      <summary>
            Returns the grapher list previously passed to the constructor.
            </summary>
    </member>
    <member name="M:whiteMath.Graphers.MultiGrapher.setPens(System.Drawing.Pen[])">
      <summary>
            Method used to set different pens for different graphers previously passed to the
            constructor.
            
            The number of parameters passed must strictly match the number of graphers 
            passed to the constructor. Otherwise, a <code>GrapherException</code> is thrown.
            </summary>
      <param name="pens">A list of pens matching the graphers list. </param>
    </member>
    <member name="T:whiteMath.NonIntegerTypeException">
      <summary>
            The exception class which signalizes that the operation
            is supported only for integer numeric types.
            </summary>
    </member>
    <member name="M:whiteMath.NonIntegerTypeException.#ctor(System.String)">
      <summary>
            Creates a new instance of <c>NonIntegerTypeException</c>.
            </summary>
      <param name="message">The name of the type that does not support the operation which thus results in an exception.</param>
    </member>
    <member name="T:whiteMath.NonFractionalTypeException">
      <summary>
            The exception class which signalizes that the operation
            is supported only for fractional numeric types.
            </summary>
    </member>
    <member name="M:whiteMath.NonFractionalTypeException.#ctor(System.String)">
      <summary>
            Creates a new instance of <c>NonFractionalTypeException</c>.
            </summary>
      <param name="message">The name of the type that does not support the operation which thus results in an exception.</param>
    </member>
    <member name="T:whiteMath.NonNegativeTypeException">
      <summary>
            The exception class which signalizes that the operation
            is not supported because an object has non-negative numeric type.
            </summary>
    </member>
    <member name="M:whiteMath.NonNegativeTypeException.#ctor(System.String)">
      <summary>
            Creates a new instance of <c>NonNegativeTypeException</c></summary>
      <param name="message">The name of the type that does not support the operation which thus results in an exception.</param>
    </member>
    <member name="T:whiteMath.ICalcExtensionMethods">
      <summary>
            This static class provides different extension methods for 
            the ICalc(T) interface.
            </summary>
    </member>
    <member name="M:whiteMath.ICalcExtensionMethods.fromDoubleSafe``1(whiteMath.ICalc{``0},System.Double)">
      <summary>
            If the current calculator for the <typeparamref name="T" /> type does not support conversions
            from the double type AND the <paramref name="num" /> does not exceed the range of long, 
            this method will result in smaller number of exceptions, because
            if <paramref name="num" /> value contains only integral part, the 'fromInt(int)' calculator method
            will be preferred over the 'fromDouble(double)'.
            </summary>
      <typeparam name="T">The type of numbers for the calculator.</typeparam>
      <param name="calculator">The calling calculator object.</param>
      <param name="num">The number which is to be converted to the <typeparamref name="T" /> type.</param>
      <returns>The <typeparamref name="T" /> value returned by either fromInt (preferred) of fromDouble calculator method.</returns>
    </member>
    <member name="M:whiteMath.ICalcExtensionMethods.fracPart``1(whiteMath.ICalc{``0},``0)">
      <summary>
            Returns the fractional part of the number.
            </summary>
      <typeparam name="T">The type of numbers for the calculator.</typeparam>
      <param name="calculator">The calling calculator object.</param>
      <param name="num">The number which fractional part is to be returned.</param>
      <returns>The fractional part of the number.</returns>
    </member>
    <member name="M:whiteMath.ICalcExtensionMethods.isNormalNumber``1(whiteMath.ICalc{``0},``0)">
      <summary>
            Checks whether the number is not a NaN or an Infinity.
            </summary>
      <typeparam name="T" />
      <param name="calculator" />
      <param name="num" />
      <returns />
    </member>
    <member name="M:whiteMath.ICalcExtensionMethods.isNonNegative``1(whiteMath.ICalc{``0},``0)">
      <summary>
            Tests whether a number is non-negative according to the calling calculator object.
            </summary>
    </member>
    <member name="M:whiteMath.ICalcExtensionMethods.isNonPositive``1(whiteMath.ICalc{``0},``0)">
      <summary>
            Tests whether a number is non-positive according to the calling calculator object.
            </summary>
    </member>
    <member name="M:whiteMath.ICalcExtensionMethods.isPositive``1(whiteMath.ICalc{``0},``0)">
      <summary>
            Tests whether a number is positive according to the calling calculator object.
            </summary>
    </member>
    <member name="M:whiteMath.ICalcExtensionMethods.isNegative``1(whiteMath.ICalc{``0},``0)">
      <summary>
            Tests whether a number is negative according to the calling calculator object.
            </summary>
    </member>
    <member name="M:whiteMath.ICalcExtensionMethods.isInfinity``1(whiteMath.ICalc{``0},``0)">
      <summary>
            Checks whether the number is an Infinity.
            </summary>
      <typeparam name="T">The type of the number.</typeparam>
      <param name="num">The number to be tested.</param>
      <param name="calculator">A calculator for the <typeparamref name="T" /> type.</param>
      <returns>True if the number is an infinity according to the <paramref name="calculator" />, false othewise.</returns>
    </member>
    <member name="M:whiteMath.ICalcExtensionMethods.tryParse``1(whiteMath.ICalc{``0},System.String,``0@)">
      <summary>
            Tries to parse the string value into the number.
            If successful, returns true and sets the 'res' parameter to the parsed value.
            False is returned otherwise; no exceptions are thrown.
            </summary>
      <typeparam name="T">The type of the number.</typeparam>
      <param name="calculator">A calculator for the <typeparamref name="T" /> type.</param>
      <param name="value">The value to be parsed into a <typeparamref name="T" /> variable.</param>
      <param name="res">A variable to store the result. Will be null or zero in case of a failure.</param>
      <returns>True if the conversion succeeded, false otherwise.</returns>
    </member>
    <member name="T:whiteMath.Imaging.PathDecal">
      <summary>
            Represents a decal on the image with a path shape.
            </summary>
    </member>
    <member name="T:whiteMath.Imaging.RectangleDecal">
      <summary>
            Represents a decal on the image with a shape of a rectangle.
            </summary>
    </member>
    <member name="M:whiteMath.Imaging.Extensions.drawDecals(System.Drawing.Graphics,System.Collections.Generic.IList{whiteMath.Imaging.IDecal})">
      <summary>
            Extension method that draws all the decals from the list specified using the calling graphics object.
            </summary>
      <param name="G" />
      <param name="decals" />
    </member>
    <member name="M:whiteMath.Imaging.Extensions.invert(System.Drawing.Color)">
      <summary>
            Extension method that inverts the calling color object.
            </summary>
      <param name="color" />
      <returns />
    </member>
    <member name="M:whiteMath.Imaging.Extensions.pensFromColors(System.Collections.Generic.IList{System.Drawing.Color})">
      <summary>
            Extension method that creates a pen array from a color list.
            </summary>
      <param name="colors" />
      <returns />
    </member>
    <member name="T:whiteMath.Matrices.MatrixNumericHelper`2">
      <summary>
            Static class providing different methods to operate with matrices.
            Provides standard arithmetic methods with (A, B, res C) signature
            as an alternative to overloaded operators in the Matrix class itself - because in this case
            the user himself can control the overall number of matrices created, preserving memory.
            -----------------
            Is thread-safe.
            -----------------
            Please notice that all of the arithmetic methods DO NOT PERFORM THE OPERANDS' size checking!
            If you wish to perform one, please explicitly use the static boolean methods
            checkArithmeticSize(...) for most operations and checkMultiplySize(...) for matrix multiplication.
            </summary>
    </member>
    <member name="M:whiteMath.Matrices.MatrixNumericHelper`2.getMatrixType(whiteMath.Matrices.Matrix{`0,`1})">
            ---------------------------------------------
                        SERVICE METHODS
            ---------------------------------------------
        </member>
    <member name="M:whiteMath.Matrices.MatrixNumericHelper`2.getMatrixOfSize(whiteMath.Matrices.MatrixType,System.Int32,System.Int32)">
      <summary>
            Gets a blank matrix of the specified size.
            The type of the matrix depends on the MatrixType object passed.
            </summary>
      <param name="rows" />
      <param name="columns" />
      <returns />
    </member>
    <member name="M:whiteMath.Matrices.MatrixNumericHelper`2.multiplyStrassen(whiteMath.Matrices.Matrix{`0,`1},whiteMath.Matrices.Matrix{`0,`1},whiteMath.Matrices.Matrix{`0,`1})">
      <summary>
            Performs the matrix multiplication using the quick Strassen algorithm.
            Consumes more memory than simple iterational method, but much quicker
            on bigger dimensions (128+).
            
            If the dimension of method parameters passed is N, then maximum additional object memory consumption is 
            <value>9N + [if N&gt;64: (log2(N)-6)*f] + o(N)</value>
            Where f == (nearly) 4.5*(new Matrix of 2N*2N memory consumption).
            </summary>
      <param name="A">The matrix to multiply.</param>
      <param name="B">The matrix to multiply by.</param>
      <param name="result">The resulting matrix of [A.Rows x B.Columns] size.</param>
    </member>
    <member name="M:whiteMath.Matrices.MatrixNumericHelper`2.strassenSkeleton(whiteMath.Matrices.Matrix{`0,`1},whiteMath.Matrices.Matrix{`0,`1},whiteMath.Matrices.Matrix{`0,`1},System.Int32)">
      <summary>
            Private recursive Strassen multiplying method skeleton called implicitly by the wrapper method.
            </summary>
      <param name="A">The matrix to multiply</param>
      <param name="B">The matrix to multiply by</param>
      <param name="result">The resulting matrix</param>
      <param name="curDim">Current matrix dimension</param>
    </member>
    <member name="M:whiteMath.Matrices.MatrixNumericHelper`2.sum(whiteMath.Matrices.Matrix{`0,`1},whiteMath.Matrices.Matrix{`0,`1},whiteMath.Matrices.Matrix{`0,`1})">
      <summary>
            Fills the result matrix with (A[i,j] + B[i,j]) elements.
            </summary>
      <param name="A">The first matrix</param>
      <param name="B">The second matrix</param>
      <param name="result">The result matrix</param>
    </member>
    <member name="M:whiteMath.Matrices.MatrixNumericHelper`2.dif(whiteMath.Matrices.Matrix{`0,`1},whiteMath.Matrices.Matrix{`0,`1},whiteMath.Matrices.Matrix{`0,`1})">
      <summary>
            Fills the result matrix with (A[i,j] - B[i,j]) elements.
            </summary>
      <param name="A">The first matrix</param>
      <param name="B">The second matrix</param>
      <param name="result">The result matrix</param>
    </member>
    <member name="M:whiteMath.Matrices.MatrixNumericHelper`2.negate(whiteMath.Matrices.Matrix{`0,`1},whiteMath.Matrices.Matrix{`0,`1})">
      <summary>
            Negates the source matrix and writes the result to another matrix.
            The result matrix can match with the source, though.
            </summary>
      <param name="A">The source matrix</param>
      <param name="result">The matrix that should contain the result</param>
    </member>
    <member name="M:whiteMath.Matrices.MatrixNumericHelper`2.addValue(whiteMath.Matrices.Matrix{`0,`1},whiteMath.Numeric{`0,`1},whiteMath.Matrices.Matrix{`0,`1})">
      <summary>
            Adds a <see cref="T:whiteMath.Numeric`2" /> value to all of the matrix elements 
            and writes the result to another matrix.
            The result matrix can point to the source.
            </summary>
      <param name="A" />
      <param name="value" />
      <param name="result" />
    </member>
    <member name="M:whiteMath.Matrices.MatrixNumericHelper`2.substractValue(whiteMath.Matrices.Matrix{`0,`1},whiteMath.Numeric{`0,`1},whiteMath.Matrices.Matrix{`0,`1})">
      <summary>
            Substracts a Numeric&lt;T,C&gt; value from all of the matrix elements and writes the result to another matrix.
            The result matrix, though, can match with the source.
            </summary>
      <param name="A" />
      <param name="value" />
      <param name="result" />
    </member>
    <member name="M:whiteMath.Matrices.MatrixNumericHelper`2.divValue(whiteMath.Matrices.Matrix{`0,`1},whiteMath.Numeric{`0,`1},whiteMath.Matrices.Matrix{`0,`1})">
      <summary>
            Divides all of the matrix elements by a Numeric&lt;T,C&gt; value and writes the result to another matrix.
            The reference to the result matrix CAN point to the source.
            </summary>
      <param name="A">The matrix whose elements are to be divided by a constant value.</param>
      <param name="value" />
      <param name="result" />
    </member>
    <member name="M:whiteMath.Matrices.MatrixNumericHelper`2.mulValue(whiteMath.Matrices.Matrix{`0,`1},whiteMath.Numeric{`0,`1},whiteMath.Matrices.Matrix{`0,`1})">
      <summary>
            Multiplies all of the matrix elements by a Numeric&lt;T,C&gt; value and writes the result to another matrix.
            The reference to the result matrix CAN point to the source.
            </summary>
      <param name="A">The matrix whose elements are to be multiplied by a constant value.</param>
      <param name="value" />
      <param name="result" />
    </member>
    <member name="M:whiteMath.Matrices.MatrixNumericHelper`2.eachElementMul(whiteMath.Matrices.Matrix{`0,`1},whiteMath.Matrices.Matrix{`0,`1},whiteMath.Matrices.Matrix{`0,`1})">
      <summary>
            For each A[i,j] counts A[i,j]*B[i,j] and writes the result to another matrix.
            The source matrix can match with result parameter.
            </summary>
      <param name="A" />
      <param name="B" />
      <param name="result" />
    </member>
    <member name="M:whiteMath.Matrices.MatrixNumericHelper`2.eachElementDiv(whiteMath.Matrices.Matrix{`0,`1},whiteMath.Matrices.Matrix{`0,`1},whiteMath.Matrices.Matrix{`0,`1})">
      <summary>
            For each A[i,j] counts A[i,j]/B[i,j] and writes the result to another matrix.
            The source matrix can match with result parameter.
            Caution! Watch out for zeros in the B[i,j].
            </summary>
      <param name="A" />
      <param name="B" />
      <param name="result" />
    </member>
    <member name="M:whiteMath.Matrices.MatrixNumericHelper`2.multiplySimple(whiteMath.Matrices.Matrix{`0,`1},whiteMath.Matrices.Matrix{`0,`1},whiteMath.Matrices.Matrix{`0,`1})">
      <summary>
            Standard multiplying method with O(n^3).
            </summary>
      <param name="A" />
      <param name="B" />
      <param name="result" />
    </member>
    <member name="M:whiteMath.Matrices.MatrixNumericHelper`2.checkArithmeticSize(whiteMath.Matrices.IMatrix,whiteMath.Matrices.IMatrix,whiteMath.Matrices.IMatrix)">
      <summary>
            Checks if matrices passed to common arithmetic methods (sum and substraction between matrices etc., 
            arithmetic operations between matrices and <see cref="T:whiteMath.Numeric`2" /> values etc.)
            
            The principle is that (dim(A) = dim(B) = dim(res)) should be true, where dim is imaginary function
            returning the [row x columns] dimension object.
            </summary>
      <param name="A">The first matrix.</param>
      <param name="B">The second matrix.</param>
      <param name="res">The result matrix.</param>
      <returns>True if sizes are valid, false otherwise.</returns>
    </member>
    <member name="M:whiteMath.Matrices.MatrixNumericHelper`2.checkMultiplySize(whiteMath.Matrices.IMatrix,whiteMath.Matrices.IMatrix,whiteMath.Matrices.IMatrix)">
      <summary>
            Checks if matrices passed to the multiplying method all have valid size.
            </summary>
      <param name="A">The first matrix.</param>
      <param name="B">The second matrix.</param>
      <param name="res">The result matrix of (A.Rows x B.Columns) size.</param>
      <returns>True if sizes are valid, false otherwise.</returns>
    </member>
    <member name="T:whiteMath.Matrices.IndexPair">
      <summary>
            A struct representing a pair of matrix indexes.
            Provides an alternative way of indexing in Matrix objects;
            Also used in Winder-classes for compact next-IndexPair return of getNextIndexPair();
            <see>Winder.getNextIndexPair()</see></summary>
    </member>
    <member name="M:whiteMath.Matrices.IndexPair.#ctor(System.Int32,System.Int32)">
      <summary>
            Constructs a new IndexPair object using a pair of matrix indices.
            </summary>
      <param name="row">A row index</param>
      <param name="column">A column index</param>
    </member>
    <member name="T:whiteMath.Matrices.MatrixType">
      <summary>
            Enumeration containing main matrix types, used by MatrixHelper class.
            
            1. Matrix based on a single-dimensional array. Quick element indexation, lower memory consumption.
            2. Matrix based on double indexing. Stupid.
            </summary>
    </member>
    <member name="T:whiteMath.Matrices.Submatrix`2">
      <summary>
            The class represents the continuous submatrix of a numeric matrix.
            All matrix operations supported, but any changes made to the submatrix will be reflected 
            on the parent matrix object. The mechanism uses an encapsulated parent matrix 
            reference.
            
            An object of this class cannot be instantiated directly.
            Call method getSubmatrixAt() for a particular Matrix object instead.
            </summary>
    </member>
    <member name="M:whiteMath.Matrices.Submatrix`2.Clone">
      <summary>
            Returns the COPY of the current submatrix as a stand-alone Matrix object.
            The changes made to it will never influence the parent matrix.
            </summary>
      <returns />
    </member>
    <member name="P:whiteMath.Matrices.Submatrix`2.RowOffset">
      <summary>
            Gets the row offset (in the parent matrix) for the current submatrix.
            </summary>
    </member>
    <member name="P:whiteMath.Matrices.Submatrix`2.ColumnOffset">
      <summary>
            Gets the column offset (in the parent matrix) for the current submatrix.
            </summary>
    </member>
    <member name="P:whiteMath.Matrices.Submatrix`2.Parent">
      <summary>
            Gets the parent matrix object.
            </summary>
    </member>
    <member name="T:whiteMath.Matrices.Matrix_SDA`2">
      <summary>
            Matrix containing the single-dimensional array inside.
            Works fast.
            </summary>
    </member>
    <member name="M:whiteMath.Matrices.Matrix_SDA`2.#ctor(System.Int32,System.Int32)">
      <summary>
            Constructs a new single-dimensional-array-based Matrix object
            </summary>
      <param name="rows">Height of the matrix</param>
      <param name="columns">Width of the matrix</param>
    </member>
    <member name="M:whiteMath.Matrices.Matrix_SDA`2.#ctor">
      <summary>
            Constructor "internal-only" version
            </summary>
    </member>
    <member name="M:whiteMath.Matrices.Matrix_SDA`2.setItemAt(System.Int32,System.Int32,whiteMath.Numeric{`0,`1})">
      <summary>
            Implementing <see>setItemAt()</see>
            WARNING! Does not perform any object copying, just reference copying.
            For class types, all changes made to the element passed will be reflected on the matrix element as well.
            Please explicitly use the number copy method if needed.
            </summary>
    </member>
    <member name="M:whiteMath.Matrices.Matrix_SDA`2.getItemAt(System.Int32,System.Int32)">
      <summary>
            Implementing <see>getItemAt()</see></summary>
    </member>
    <member name="M:whiteMath.Matrices.Matrix_SDA`2.negate">
      <summary>
            Negates the matrix so that all the elements change their sign to the opposite.
            </summary>
      <returns />
    </member>
    <member name="M:whiteMath.Matrices.Matrix_SDA`2.Clone">
      <summary>
            Provides a deep clone of the current matrix.
            </summary>
      <returns>The cloned matrix.</returns>
    </member>
    <member name="M:whiteMath.Matrices.SLAESolving.LU_FactorizationSolving``2(whiteMath.Matrices.Matrix{``0,``1},whiteMath.Vector{``0,``1},whiteMath.Vector{``0,``1}@)">
      <summary>
            This algorithm uses the LU-Factorization of coefficient matrix in order
            to calculate the solution of the equation system.
            
            As LU-Factorization is not guaranteed to exist for every 
            non-singular matrix, this method may sometimes fail.
            </summary>
      <param name="coefficients">A square matrix of unknown terms' coefficients.</param>
      <param name="freeTerm">A vector of free terms.</param>
      <param name="x">The vector containing the solution of the equation system.</param>
    </member>
    <member name="T:RowByRowWinder">
      <summary>
            Provides a standard row-by-row winding/unwinding of the matrix.
            </summary>
    </member>
    <member name="T:whiteMath.Matrices.Winder">
      <summary>
            Provides standard support for winding and unwinding between Matrix objects
            and single-dimensional arrays of Matrix elements.
            </summary>
    </member>
    <member name="T:whiteMath.Matrices.IWinder">
      <summary>
            Minimal interface functionality for winders.
            </summary>
    </member>
    <member name="M:whiteMath.Matrices.IWinder.reset">
      <summary>
            Resets the winder so the indexing starts from the beginning
            (often from the from the [0,0], but this may vary depending on the implementation)
            </summary>
    </member>
    <member name="M:whiteMath.Matrices.Winder.getNextIndexPair">
      <summary>
            Returns the next index pair for winding/unwinding the matrix with/into a flat array.
            </summary>
      <returns>The IndexPair object.</returns>
    </member>
    <member name="T:SpiralWinder">
      <summary>
            TODO: check if it works all right
            </summary>
    </member>
    <member name="T:whiteMath.Matrices.ChaoticWinder">
      <summary>
            Performs a (pseudo) chaotic matrix winding/unwinding.
            Please notice: though randomized, the order of winding/unwinding 
            will not change once created.
            </summary>
    </member>
    <member name="M:whiteMath.Matrices.ChaoticWinder.formTrace">
      <summary>
            Обеспечивает двусторонний проход по массиву стандартной построчной развертки
            путем пошаговой перестановки текущего элемента со случайным и 
            центрально-симметрично текущему со случайным.
            </summary>
    </member>
    <member name="T:Winders">
      <summary>
            This method provides extension methods for constructing different matrix winders.
            </summary>
    </member>
    <member name="T:ZigZagWinder">
      <summary>
            Performs a zig-zag matrix winding/unwinding
            </summary>
    </member>
    <member name="F:ZigZagWinder.direction">
      <summary>
            The direction to go.
            
            1 - Left
            2 - Up-Left
            3 - Up
            4 - Up-Right
            5 - Right
            6 - Down-Right
            7 - Down
            8 - Down-Left
            0 - Stay
            </summary>
    </member>
    <member name="F:ZigZagWinder.celltype">
      <summary>
            The cell type basing on the surrounding matrix borders type
            
            Two-based summarizing:
            
            0 - No borders
            1 - Upper border
            2 - Down border
            4 - Left border
            8 - Right border
            ==&gt;
            
            0 - No borders
            1 - Upper border
            2 - Down border
            3 - Up-Down border
            4 - Left border
            5 - Up-Left border
            6 - Down-left border
            7 - Up-Down-Left border
            8 - Right border
            9 - Up-Right border
            10 - Down-Right border
            11 - Up-Down-Right border
            12 - Left-Right border
            13 - Up-Left-Right border
            14 - Left-Right-Down border
            15 - All-side border (single element matrix)
            </summary>
    </member>
    <member name="M:ZigZagWinder.analyzeDirection">
      <summary>
            Analyzes the direction basing on where from we have came to the moment
            and on what the cell type is.
            </summary>
    </member>
    <member name="M:ZigZagWinder.performStep">
      <summary>
            Делает один шаг по матрице, в зависимости от определенного направления
            Не нужно предусматривать выход за границы - он уже предусмотрен на предыдущем этапе.
            </summary>
    </member>
    <member name="M:ZigZagWinder.analyzeCellType">
      <summary>
            Analyzes the cell type basing on what the surrounding matrix borders are.
            </summary>
    </member>
    <member name="T:whiteMath.Randoms.UnboundedGenerator`1">
      <summary>
            Represents a method which is able to generate
            random numbers in the whole range of the <typeparamref name="T" />
            type.
            </summary>
      <typeparam name="T">The type of numbers generated by the method.</typeparam>
      <returns>A random value from all of the possible finite values of numeric type <typeparamref name="T" />.</returns>
    </member>
    <member name="T:whiteMath.Randoms.UpperBoundedGenerator`1">
      <summary>
            Represents a method which is able to generate
            non-negative random numbers smaller than the specified
            value.
            </summary>
      <typeparam name="T">The type of numbers generated by the method.</typeparam>
      <param name="maxValue">An exlusive upper boundary for generated numbers.</param>
      <returns>A non-negative random value which is smaller than <paramref name="maxValue" />.</returns>
    </member>
    <member name="T:whiteMath.Randoms.BoundedGenerator`1">
      <summary>
            Represents a method which is able to generate
            random numbers in the specified range.
            </summary>
      <typeparam name="T">The type of numbers generated by the method.</typeparam>
      <param name="minValue">A lower inclusive boundary for generated numbers.</param>
      <param name="maxValue">An upper exclusive boundary for generated numbers.</param>
      <returns>A random value in the interval <c>[minValue; maxValue)</c></returns>
    </member>
    <member name="T:whiteMath.Randoms.ByteGenerator">
      <summary>
            Represents a method which accepts a <c>byte[]</c>
            buffer and fills it with random values.
            </summary>
      <param name="buffer">An array to be filled with random values.</param>
    </member>
    <member name="T:whiteMath.Randoms.RandomFunctionalityExtensions">
      <summary>
            This class provides methods for extending functionality of
            existing random generators by making use of their methods
            to create new ones.
            </summary>
      <see cref="T:whiteMath.Randoms.IRandomFloatingPoint`1" />
      <see cref="T:whiteMath.Randoms.IRandomBytes" />
      <see cref="T:whiteMath.Randoms.IRandomUnbounded`1" />
      <see cref="T:whiteMath.Randoms.IRandomBounded`1" />
    </member>
    <member name="M:whiteMath.Randoms.RandomFunctionalityExtensions.TreatAsBoundedGenerator``2(whiteMath.Randoms.IRandomFloatingPoint{``0})">
      <summary>
            Makes use of an <c>IRandomFloatingPoint&lt;<typeparamref name="T" />&gt;</c>
            instance and enables it to produce values in an arbitrary range (i.e. wraps it
            around to make it an <c>IRandomBounded&lt;<typeparamref name="T" />&gt;</c> object).
            </summary>
      <remarks>
            Because the wrapper object will use multiplication scaling to produce random numbers, 
            please notice that for bigger intervals the quality of the distribution
            may seriously suffer due to scale irregularity of some numeric types, e.g. <c>double</c>.
            </remarks>
      <typeparam name="T">The type of numbers generated by <paramref name="gen" />.</typeparam>
      <typeparam name="C">A calculator type for the <typeparamref name="T" /> type.</typeparam>
      <param name="gen">An <c>IRandomFloatingPoint&lt;<typeparamref name="T" />&gt;</c> instance.</param>
      <returns>
            An <c>IRandomBounded&lt;<typeparamref name="T" />&gt;</c> object that makes use 
            of <paramref name="gen" /> and produces values in arbitrary ranges by scaling.</returns>
    </member>
    <member name="M:whiteMath.Randoms.RandomFunctionalityExtensions.TreatAsUnboundedGenerator``2(whiteMath.Randoms.IRandomFloatingPoint{``0},``0,``0)">
      <summary>
            Makes use of an <c>IRandomFloatingPoint&lt;<typeparamref name="T" />&gt;</c>
            instance and enables it to produce values in a constant, pre-set range (i.e. wraps it
            around to make it an as an <c>IRandomUnbounded&lt;<typeparamref name="T" />&gt;</c> object).
            </summary>
      <remarks>
            Because the wrapper object will use multiplication scaling to produce random numbers, 
            please notice that for bigger intervals the quality of the distribution
            may seriously suffer due to scale irregularity of some numeric types, e.g. <c>double</c>.
            </remarks>
      <typeparam name="T">The type of numbers generated by <paramref name="gen" />.</typeparam>
      <typeparam name="C">A calculator type for the <typeparamref name="T" /> type.</typeparam>
      <param name="gen">An <c>IRandomFloatingPoint&lt;<typeparamref name="T" />&gt;</c> instance.</param>
      <param name="minimum">The lower inclusive boundary for generated values.</param>
      <param name="maximum">The upper exclusive boundary for generated values.</param>
      <returns>
            An <c>IRandomBounded&lt;<typeparamref name="T" />&gt;</c> object that makes use 
            of <paramref name="gen" /> and produces values in arbitrary ranges by scaling.</returns>
    </member>
    <member name="M:whiteMath.Randoms.RandomFunctionalityExtensions.CreateNextBytes(whiteMath.Randoms.UnboundedGenerator{System.Int32})">
      <summary>
            Returns a delegate that is able to generate random byte 
            sequences on the basis of random <c>int</c> generator delegate.
            </summary>
      <param name="intGenerator">A delegate which returns a random integer number, recommended to cover the whole range <c>[int.MinValue; int.MaxValue]</c>.</param>
      <returns>A delegate that wraps around the <paramref name="intGenerator" /> to produce random byte sequences.</returns>
    </member>
    <member name="M:whiteMath.Randoms.RandomFunctionalityExtensions.CreateNextBytes(whiteMath.Randoms.UnboundedGenerator{System.Int64})">
      <summary>
            Returns a delegate that is able to generate random byte sequences 
            on the basis of a random <see cref="T:System.Int64" /> generator.
            </summary>
      <param name="longGenerator">A delegate which returns a random long number, recommended to cover the whole range <c>[long.MinValue; long.MaxValue]</c>.</param>
      <returns>A delegate that wraps around the <paramref name="longGenerator" /> to produce random byte sequences.</returns>
    </member>
    <member name="M:whiteMath.Randoms.RandomFunctionalityExtensions.___CreateNextUIntInclusive(whiteMath.Randoms.ByteGenerator)">
      <summary>
            На основе генератора случайных байтов возвращает 
            генератор uint, который дает числа не больше заданного значения.
            </summary>
    </member>
    <member name="M:whiteMath.Randoms.RandomFunctionalityExtensions.CreateNextUIntUnbounded(whiteMath.Randoms.ByteGenerator)">
      <summary>
            Returns a delegate that is able to generate random
            <c>uint</c> numbers in the whole range of <c>uint</c> numeric type.
            </summary>
      <param name="byteGenerator">A delegate that fills the passed byte array with random values.</param>
      <returns>
            A delegate that wraps around the <paramref name="byteGenerator" /> to produce random 
            <c>uint</c> values in the whole range of <c>uint</c> numeric type.
            </returns>
    </member>
    <member name="M:whiteMath.Randoms.RandomFunctionalityExtensions.CreateNextUIntUpperBounded(whiteMath.Randoms.ByteGenerator)">
      <summary>
            Returns a delegate that is able to generate random
            <c>uint</c> numbers which are strictly smaller than the specified value.
            </summary>
      <param name="byteGenerator">A delegate that fills the passed byte array with random values.</param>
      <returns>
            A delegate that wraps around the <paramref name="byteGenerator" /> to produce random <c>uint</c> values 
            which are strictly smaller than the argument passed to the delegate.
            </returns>
    </member>
    <member name="M:whiteMath.Randoms.RandomFunctionalityExtensions.CreateNextUIntBounded(whiteMath.Randoms.ByteGenerator)">
      <summary>
            Returns a delegate that is able to generate random
            <c>uint</c> numbers in an arbitrary range.
            </summary>
      <param name="byteGenerator">A delegate that fills the passed byte array with random values.</param>
      <returns>A delegate that wraps around the <paramref name="byteGenerator" /> to produce random <c>uint</c> values 
            in the specified range.</returns>
    </member>
    <member name="M:whiteMath.Randoms.RandomFunctionalityExtensions.CreateNextIntUnbounded(whiteMath.Randoms.ByteGenerator)">
      <summary>
            Returns a delegate that is able to generate random
            <c>int</c> numbers in an the whole range of <c>int</c> numeric type.
            </summary>
      <param name="byteGenerator">A delegate that fills the passed byte array with random values.</param>
      <returns>
            A delegate that wraps around the <paramref name="byteGenerator" /> to 
            produce random <c>int</c> values in the whole range of <c>int</c> numeric type.
            </returns>
    </member>
    <member name="M:whiteMath.Randoms.RandomFunctionalityExtensions.CreateNextIntUpperBounded(whiteMath.Randoms.ByteGenerator)">
      <summary>
            Returns a delegate that is able to generate random
            <c>int</c> numbers which are strictly smaller than the specified value.
            </summary>
      <param name="byteGenerator">
            A delegate that fills the passed byte array with random values.
            </param>
      <returns>
            A delegate that wraps around the <paramref name="byteGenerator" /> to produce random <c>int</c> values 
            which are strictly smaller than the argument passed to the delegate.
            </returns>
    </member>
    <member name="M:whiteMath.Randoms.RandomFunctionalityExtensions.CreateNextIntBounded(whiteMath.Randoms.ByteGenerator)">
      <summary>
            Returns a delegate that is able to generate random
            <c>int</c> numbers in an arbitrary range.
            </summary>
      <param name="byteGenerator">A delegate that fills the passed byte array with random values.</param>
      <returns>
            A delegate that wraps around the <paramref name="byteGenerator" /> 
            to produce random <c>int</c> values in the range supplied as its argument.
            </returns>
    </member>
    <member name="M:whiteMath.Randoms.RandomFunctionalityExtensions.___CreateNextULongInclusive(whiteMath.Randoms.ByteGenerator)">
      <summary>
            На основе генератора случайных байтов возвращает 
            генератор ulong, который дает числа не больше заданного значения.
            </summary>
    </member>
    <member name="M:whiteMath.Randoms.RandomFunctionalityExtensions.CreateNextULongUnbounded(whiteMath.Randoms.ByteGenerator)">
      <summary>
            Returns a delegate that is able to generate random
            <c>ulong</c> numbers in the whole range of <c>ulong</c> numeric type.
            </summary>
      <param name="byteGenerator">A delegate that fills the passed byte array with random values.</param>
      <returns>A delegate that wraps around the <paramref name="byteGenerator" /> to produce random <c>ulong</c> values in the whole range of <c>ulong</c> numeric type.</returns>
    </member>
    <member name="M:whiteMath.Randoms.RandomFunctionalityExtensions.CreateNextULongUpperBounded(whiteMath.Randoms.ByteGenerator)">
      <summary>
            Returns a delegate that is able to generate random
            <c>ulong</c> numbers which are strictly smaller than the specified value.
            </summary>
      <param name="byteGenerator">A delegate that fills the passed byte array with random values.</param>
      <returns>
            A delegate that wraps around the <paramref name="byteGenerator" /> to produce random <c>ulong</c> values 
            which are strictly smaller than the argument passed to the delegate.
            </returns>
    </member>
    <member name="M:whiteMath.Randoms.RandomFunctionalityExtensions.CreateNextULongBounded(whiteMath.Randoms.ByteGenerator)">
      <summary>
            Returns a delegate that is able to generate random
            <c>ulong</c> numbers in an arbitrary range.
            </summary>
      <param name="byteGenerator">A delegate that fills the passed byte array with random values.</param>
      <returns>A delegate that wraps around the <paramref name="byteGenerator" /> to produce random <c>ulong</c> values 
            in the specified range.</returns>
    </member>
    <member name="M:whiteMath.Randoms.RandomFunctionalityExtensions.CreateNextLongUnbounded(whiteMath.Randoms.ByteGenerator)">
      <summary>
            Returns a delegate that is able to generate random
            <c>long</c> numbers in an arbitrary range.
            </summary>
      <param name="byteGenerator">A delegate that fills the passed byte array with random values.</param>
      <returns>A delegate that wraps around the <paramref name="byteGenerator" /> to produce random <c>ulong</c> values in the whole range of <c>long</c> numeric type.</returns>
    </member>
    <member name="M:whiteMath.Randoms.RandomFunctionalityExtensions.CreateNextLongUpperBounded(whiteMath.Randoms.ByteGenerator)">
      <summary>
            Returns a delegate that is able to generate random
            <c>long</c> numbers which are strictly smaller than the specified value.
            </summary>
      <param name="byteGenerator">A delegate that fills the passed byte array with random values.</param>
      <returns>
            A delegate that wraps around the <paramref name="byteGenerator" /> to produce random <c>long</c> values 
            which are strictly smaller than the argument passed to the delegate.
            </returns>
    </member>
    <member name="M:whiteMath.Randoms.RandomFunctionalityExtensions.CreateNextLongBounded(whiteMath.Randoms.ByteGenerator)">
      <summary>
            Returns a delegate that is able to generate random
            <c>long</c> numbers in an arbitrary range.
            </summary>
      <param name="byteGenerator">A delegate that fills the passed byte array with random values.</param>
      <returns>
            A delegate that wraps around the <paramref name="byteGenerator" /> 
            to produce random <c>long</c> values in the range supplied as its argument.
            </returns>
    </member>
    <member name="T:whiteMath.Randoms.RandomFunctionalityExtensions.___RandomFP_BoundedWrapper`2">
      <summary>
            This class wraps around a <c>RandomFloatingPoint&lt;<typeparamref name="T" />&gt;</c>
            to treat it as an unbounded generator in a certain interval 
            (absolute minimum and absolute maximum values should be provided).
            </summary>
      <remarks>
            Please notice that for bigger intervals the quality of the distribution
            may seriously suffer due to scale irregularity of some numeric types, e.g. <c>double</c>.
            </remarks>
      <typeparam name="T">The type of generated numbers.</typeparam>
      <typeparam name="C">A calculator type for the <typeparamref name="T" /> type.</typeparam>
    </member>
    <member name="M:whiteMath.Randoms.RandomFunctionalityExtensions.___RandomFP_BoundedWrapper`2.Next(`0,`0)">
      <summary>
            Returns the next random number in the specified interval.
            </summary>
      <remarks>
            Please notice that for bigger intervals the quality of the distribution
            may seriously suffer due to scale irregularity of some numeric types, e.g. <c>double</c>.
            </remarks>
      <param name="min">The lower inclusive bound of generated numbers.</param>
      <param name="max">The upper exclusive bound of generated numbers.</param>
      <requires description="The lower boundary of generated values should be less than the upper boundary." exception="T:System.ArgumentException" csharp="Calculator.mor(max, min)" vb="Calculator.mor(max, min)">whiteMath.Numeric&lt;T, C&gt;.Calculator.mor(max, min)</requires>
      <exception cref="T:System.ArgumentException">Numeric&gt;=T</exception>
    </member>
    <member name="M:whiteMath.Randoms.RandomFunctionalityExtensions.___RandomFP_BoundedWrapper`2.#ctor(whiteMath.Randoms.IRandomFloatingPoint{`0})">
      <summary>
            Initializes the wrapper instance with a floating-point generator.
            </summary>
      <param name="gen">A floating-point generator for the type <typeparamref name="T" /></param>
      <requires description="gen" exception="T:System.ArgumentNullException" csharp="gen != null" vb="gen &lt;&gt; Nothing">gen != null</requires>
      <exception cref="T:System.ArgumentNullException">gen == null</exception>
    </member>
    <member name="T:whiteMath.Randoms.RandomFunctionalityExtensions.___RandomFP_UnboundedWrapper`2">
      <summary>
            This class wraps around a <c>RandomFloatingPoint&lt;<typeparamref name="T" />&gt;</c>
            to treat it as an unbounded generator in a certain interval 
            (absolute minimum and absolute maximum values should be provided).
            </summary>
      <remarks>
            Please notice that for bigger intervals the quality of the distribution
            may seriously suffer due to scale irregularity of some numeric types, e.g. <c>double</c>.
            </remarks>
      <typeparam name="T">The type of generated numbers.</typeparam>
      <typeparam name="C">A calculator type for the <typeparamref name="T" /> type.</typeparam>
    </member>
    <member name="M:whiteMath.Randoms.RandomFunctionalityExtensions.___RandomFP_UnboundedWrapper`2.Next">
      <summary>
            Returns the next random number in the <c>[AbsoluteMinimum; AbsoluteMaximum)</c> interval.
            </summary>
      <remarks>
            Please notice that for bigger intervals the quality of the distribution
            may seriously suffer due to scale irregularity of some numeric types, e.g. <c>double</c>.
            </remarks>
    </member>
    <member name="M:whiteMath.Randoms.RandomFunctionalityExtensions.___RandomFP_UnboundedWrapper`2.#ctor(whiteMath.Randoms.IRandomFloatingPoint{`0},`0,`0)">
      <summary>
            Initializes the wrapper instance with a floating-point generator
            and a numeric interval.
            </summary>
      <param name="gen">A floating-point generator.</param>
      <param name="minimum">The lower inclusive boundary for generated numbers.</param>
      <param name="maximum">The upper exclusive boundary for generated numbers.</param>
      <requires description="gen" exception="T:System.ArgumentNullException" csharp="gen != null" vb="gen &lt;&gt; Nothing">gen != null</requires>
      <exception cref="T:System.ArgumentNullException">gen == null</exception>
      <requires description="The upper boundary of generated values should be bigger than the lower boundary." exception="T:System.ArgumentException" csharp="Calculator.mor(maximum, minimum)" vb="Calculator.mor(maximum, minimum)">whiteMath.Numeric&lt;T, C&gt;.Calculator.mor(maximum, minimum)</requires>
      <exception cref="T:System.ArgumentException">Numeric&gt;=T</exception>
    </member>
    <member name="P:whiteMath.Randoms.RandomFunctionalityExtensions.___RandomFP_UnboundedWrapper`2.Generator">
      <summary>
            Gets a floating-point number generator which is internally used 
            to produce numbers in the <c>[0; 1)</c> interval.
            </summary>
    </member>
    <member name="P:whiteMath.Randoms.RandomFunctionalityExtensions.___RandomFP_UnboundedWrapper`2.Minimum">
      <summary>
            Gets the lower boundary of generated numbers.
            This boundary is inclusive.
            </summary>
    </member>
    <member name="P:whiteMath.Randoms.RandomFunctionalityExtensions.___RandomFP_UnboundedWrapper`2.Maximum">
      <summary>
            Gets the upper boundary for generated numbers.
            This boundary is exclusive.
            </summary>
    </member>
    <member name="T:whiteMath.Randoms.RandomLaggedFibonacci">
      <summary>
            This class represents a pseudo-random lagged Fibonacci generator for <c>double</c> values.
            </summary>
      <remarks>
        <list type="bullet">
          <item>Identical randomization degree of each resulting number bit.</item>
          <item>An enormous period of repetition.</item>
        </list>
      </remarks>
    </member>
    <member name="M:whiteMath.Randoms.RandomLaggedFibonacci.#ctor(System.Int32,System.Int32,System.Int32)">
      <summary>
            Constructs a Lagged Fibonacci pseudo-random number generator with an integer seed
            number (uses an instance of standard Random() class for generating first sequence members)
            and the lag values.
            
            Examples of recommended lag values:
            
            a) 17; 5
            b) 55; 24
            c) 97; 33.
            
            It is not recommended to provide random lag values as it will affect
            the quality of the generator randomization.
            </summary>
      <param name="seed">The integer seed number to generate the first numbers of the random sequence. Optional. By default, the negative value means that the seed will be queried from the CPU ticks counter.</param>
      <param name="a">The first lag of the fibonacci generator. Optional. By default, equals 97.</param>
      <param name="b">The second lag of the fibonacci generator. Optional. By default, equals 33.</param>
    </member>
    <member name="M:whiteMath.Randoms.RandomLaggedFibonacci.#ctor(whiteMath.Randoms.IRandomFloatingPoint{System.Double},System.Int32,System.Int32)">
      <summary>
            Constructs a Fibonacci lagged pseudo-random number generator using the lag values and 
            another generator for the first sequence members.
            
            Examples of recommended lag values:
            
            a) 17; 5
            b) 55; 24
            c) 97; 33.
            
            It is not recommended to provide random lag values as it will affect
            the quality of the generator randomization.
            </summary>
      <param name="firstGenerator">The IRandom(T) implementer object to receive the first values of the pseudo-random sequence.</param>
      <param name="a">The first lag of the fibonacci generator. Optional. By default, equals 97.</param>
      <param name="b">The second lag of the fibonacci generator. Optional. By default, equals 33.</param>
    </member>
    <member name="M:whiteMath.Randoms.RandomLaggedFibonacci.Next_SingleInterval">
      <summary>
            Returns the next pseudo-random double number laying in the interval [0; 1).
            </summary>
      <returns>The next pseudo-random double number in the interval [0; 1).</returns>
    </member>
    <member name="T:whiteMath.Properties.Resources">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:whiteMath.Properties.Resources.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:whiteMath.Properties.Resources.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:whiteMath.Properties.Resources.NTTPrimeModuli">
      <summary>
               Looks up a localized string similar to B	N	P	ROOT
            32768	1073741824	1152851177738600449	804911200347773933
            16384	1073741824	288195192853364737	207507089585983252
            8192	1073741824	72040012589301761	9647479288820224
            4096	1073741824	18005614227619841	8709862950100963
            2048	1073741824	4499241309306881	2463718276889591
            1024	1073741824	1123718063456257	322364716996375
            512	1073741824	280391571210241	61991505263316
            256	1073741824	69840463200257	242209199987
            128	1073741824	17330193039361	13239120933133
            64	1073741824	4264902524929	726743782342
            32	 [rest of string was truncated]";.
             </summary>
    </member>
    <member name="T:whiteMath.Randoms.RandomLongIntModularUnoptimized`1">
      <summary>
            This class provides high-quality uniform random <c>LongInt&lt;<typeparamref name="B" />&gt;</c>
            generation. 
            </summary>
      <remarks>
            The speed of number generation might not be very high as the class uses number 
            multiplication/division along with rejection sampling, though optimized.
            </remarks>
      <typeparam name="B">The type specifying the digit base for the <c>LongInt&lt;B&gt;</c> type.</typeparam>
    </member>
    <member name="M:whiteMath.Randoms.RandomLongIntModularUnoptimized`1.ResetRejectionCounter">
      <summary>
            Resets the <c>TotalRejected</c>
            counter, setting its value to zero.
            </summary>
      <see cref="P:whiteMath.Randoms.RandomLongIntModularUnoptimized`1.TotalRejected" />
    </member>
    <member name="M:whiteMath.Randoms.RandomLongIntModularUnoptimized`1.#ctor(whiteMath.Randoms.IRandomBounded{System.Int32},System.Func{whiteMath.ArithmeticLong.LongInt{`0},whiteMath.ArithmeticLong.LongInt{`0},whiteMath.ArithmeticLong.LongInt{`0}})">
      <summary>
            Initializes the <c>RandomLongIntModular&lt;<typeparamref name="B" />&gt;</c> instance
            with an integer digit generator and a delegate used to multiply <c>LongInt&lt;<typeparamref name="B" />&gt;</c> numbers.
            </summary>
      <param name="intGenerator">
            A uniform distribution integer generator which will be used 
            to produce <c>LongInt&lt;<typeparamref name="B" />&gt;</c> digits.
            If <c>null</c>, a new <c>RandomStandard</c> instance will be used.
            </param>
      <see cref="T:whiteMath.Randoms.RandomStandard" />
      <param name="multiplication">
            A function taking two <c>LongInt&lt;<typeparamref name="B" />&gt;</c> numbers 
            and returning their multiplication product.
            If <c>null</c>, the simple, O(n^2) multiplication method will be used.
            </param>
      <see cref="M:whiteMath.ArithmeticLong.LongInt`1.Helper.MultiplySimple(whiteMath.ArithmeticLong.LongInt{`0},whiteMath.ArithmeticLong.LongInt{`0})" />
    </member>
    <member name="M:whiteMath.Randoms.RandomLongIntModularUnoptimized`1.Next(whiteMath.ArithmeticLong.LongInt{`0})">
      <summary>
            Returns the next non-negative <c>LongInt&lt;<typeparamref name="B" />&gt;</c>
            number which is less than <paramref name="maxExclusive" />.
            </summary>
      <param name="maxExclusive">The upper exclusive bound of generated numbers.</param>
      <returns>
            A non-negative <c>LongInt&lt;<typeparamref name="B" />&gt;</c> number which
            is less than <paramref name="maxExclusive" />.
            </returns>
      <requires description="maxExclusive" exception="T:System.ArgumentNullException" csharp="maxExclusive != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null" vb="maxExclusive &lt;&gt; ((whiteMath.ArithmeticLong.LongInt(Of B))Nothing) ">maxExclusive != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">maxExclusive == null</exception>
      <requires description="The maximum exclusive bound should be a positive number." exception="T:System.ArgumentOutOfRangeException" csharp="maxExclusive &gt; op_Implicit((long)0)" vb="maxExclusive &gt; operator ((Long )0) ">maxExclusive &gt; whiteMath.ArithmeticLong.LongInt&lt;B&gt;.op_Implicit((long)0)</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">maxExclusive &lt;= 0</exception>
    </member>
    <member name="M:whiteMath.Randoms.RandomLongIntModularUnoptimized`1.Next(whiteMath.ArithmeticLong.LongInt{`0},whiteMath.ArithmeticLong.LongInt{`0})">
      <summary>
            Returns the next <c>LongInt&lt;<typeparamref name="B" />&gt;</c>
            which lies in the interval <c>[<paramref name="minInclusive" />; <paramref name="maxExclusive" />)</c>.
            </summary>
      <param name="minInclusive">The lower inclusive bound of generated numbers.</param>
      <param name="maxExclusive">The upper exclusive bound of generated numbers.</param>
      <returns>
            A non-negative <c>LongInt&lt;<typeparamref name="B" />&gt;</c> number 
            which lies in the interval <c>[<paramref name="minInclusive" />; <paramref name="maxExclusive" />)</c>.
            </returns>
      <requires description="minInclusive" exception="T:System.ArgumentNullException" csharp="minInclusive != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null" vb="minInclusive &lt;&gt; ((whiteMath.ArithmeticLong.LongInt(Of B))Nothing) ">minInclusive != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">minInclusive == null</exception>
      <requires description="maxExclusive" exception="T:System.ArgumentNullException" csharp="maxExclusive != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null" vb="maxExclusive &lt;&gt; ((whiteMath.ArithmeticLong.LongInt(Of B))Nothing) ">maxExclusive != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">maxExclusive == null</exception>
      <requires description="The minimum inclusive bound should be less than the maximum exclusive." exception="T:System.ArgumentException" csharp="minInclusive &lt; maxExclusive" vb="minInclusive &lt; maxExclusive ">minInclusive &lt; maxExclusive</requires>
      <exception cref="T:System.ArgumentException">minInclusive &gt;= maxExclusive</exception>
    </member>
    <member name="P:whiteMath.Randoms.RandomLongIntModularUnoptimized`1.TotalRejected">
      <summary>
            Gets the total amount of generated numbers that 
            were discarded during rejection sampling.
            </summary>
    </member>
    <member name="T:whiteMath.Randoms.RandomLongIntQuick`1">
      <summary>
            This class provides quick pseudo-random number generation
            for <c>LongInt&lt;B&gt;</c> type, but sometimes seriously violates
            uniformity. 
            </summary>
      <typeparam name="B">The type specifying the digit base for the <c>LongInt&lt;B&gt;</c> type.</typeparam>
    </member>
    <member name="M:whiteMath.Randoms.RandomLongIntQuick`1.#ctor(whiteMath.Randoms.IRandomBounded{System.Int32})">
      <summary>
            Initializes the <c>RandomLongIntQuick&lt;<typeparamref name="B" />&gt;</c> instance
            with a bounded <c>int</c> random number generator.
            </summary>
      <param name="intGenerator">
            A uniform integer generator which will be used to produce 
            <c>LongInt&lt;<typeparamref name="B" />&gt;</c> digits. 
            If <c>null</c>, a new instance of <c>RandomStandard</c> will be used.
            </param>
      <see cref="T:whiteMath.Randoms.RandomStandard" />
    </member>
    <member name="M:whiteMath.Randoms.RandomLongIntQuick`1.NextInclusive(whiteMath.ArithmeticLong.LongInt{`0})">
      <summary>
            Returns the next non-negative <c>LongInt&lt;<typeparamref name="B" />&gt;</c>
            number which is not bigger than <paramref name="maxInclusive" />.
            </summary>
      <param name="maxInclusive">The upper inclusive bound of generated numbers.</param>
      <returns>
            A non-negative <c>LongInt&lt;<typeparamref name="B" />&gt;</c> number which
            is not bigger than <paramref name="maxInclusive" />.
            </returns>
      <requires description="maxInclusive" exception="T:System.ArgumentNullException" csharp="maxInclusive != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null" vb="maxInclusive &lt;&gt; ((whiteMath.ArithmeticLong.LongInt(Of B))Nothing) ">maxInclusive != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">maxInclusive == null</exception>
      <requires description="The maximum inclusive bound should not be negative." exception="T:System.ArgumentException" csharp="!maxInclusive.Negative" vb="Not maxInclusive.Negative">!maxInclusive.Negative</requires>
      <exception cref="T:System.ArgumentException">maxInclusive.Negative</exception>
    </member>
    <member name="M:whiteMath.Randoms.RandomLongIntQuick`1.Next(whiteMath.ArithmeticLong.LongInt{`0})">
      <summary>
            Returns the next non-negative <c>LongInt&lt;<typeparamref name="B" />&gt;</c>
            number which is less than <paramref name="maxExclusive" />.
            </summary>
      <param name="maxExclusive">The upper exclusive bound of generated numbers.</param>
      <returns>
            A non-negative <c>LongInt&lt;<typeparamref name="B" />&gt;</c> number which
            is less than <paramref name="maxExclusive" />.
            </returns>
      <requires description="maxExclusive" exception="T:System.ArgumentNullException" csharp="maxExclusive != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null" vb="maxExclusive &lt;&gt; ((whiteMath.ArithmeticLong.LongInt(Of B))Nothing) ">maxExclusive != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">maxExclusive == null</exception>
      <requires description="The upper exclusive bound should be strictly positive." exception="T:System.ArgumentException" csharp="maxExclusive &gt; op_Implicit((long)0)" vb="maxExclusive &gt; operator ((Long )0) ">maxExclusive &gt; whiteMath.ArithmeticLong.LongInt&lt;B&gt;.op_Implicit((long)0)</requires>
      <exception cref="T:System.ArgumentException">maxExclusive &lt;= 0</exception>
    </member>
    <member name="M:whiteMath.Randoms.RandomLongIntQuick`1.Next(whiteMath.ArithmeticLong.LongInt{`0},whiteMath.ArithmeticLong.LongInt{`0})">
      <summary>
            Returns the next <c>LongInt&lt;<typeparamref name="B" />&gt;</c>
            which lies in the interval <c>[<paramref name="minInclusive" />; <paramref name="maxExclusive" />)</c>.
            </summary>
      <param name="minInclusive">The lower inclusive bound of generated numbers.</param>
      <param name="maxExclusive">The upper exclusive bound of generated numbers.</param>
      <returns>
            A non-negative <c>LongInt&lt;<typeparamref name="B" />&gt;</c> number 
            which lies in the interval <c>[<paramref name="minInclusive" />; <paramref name="maxExclusive" />)</c>.
            </returns>
      <requires description="minInclusive" exception="T:System.ArgumentNullException" csharp="minInclusive != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null" vb="minInclusive &lt;&gt; ((whiteMath.ArithmeticLong.LongInt(Of B))Nothing) ">minInclusive != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">minInclusive == null</exception>
      <requires description="maxExclusive" exception="T:System.ArgumentNullException" csharp="maxExclusive != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null" vb="maxExclusive &lt;&gt; ((whiteMath.ArithmeticLong.LongInt(Of B))Nothing) ">maxExclusive != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">maxExclusive == null</exception>
      <requires description="The minimum inclusive bound should be less than the upper exclusive one." exception="T:System.ArgumentException" csharp="minInclusive &lt; maxExclusive" vb="minInclusive &lt; maxExclusive ">minInclusive &lt; maxExclusive</requires>
      <exception cref="T:System.ArgumentException">minInclusive &gt;= maxExclusive</exception>
    </member>
    <member name="M:whiteMath.Randoms.RandomMersenneTwister.#ctor(System.UInt32)">
      <summary>
            Initializes the generator with a non-zero seed.
            The seed number itself should be as 'random' as possible - consider
            using system clock or another generator for that.
            </summary>
      <param name="seed">A non-zero seed value. If it is zero, a clock-dependent value will be used.</param>
    </member>
    <member name="M:whiteMath.Randoms.RandomMersenneTwister.#ctor">
      <summary>
            Initializes the generator with a clock-dependent seed value.
            </summary>
    </member>
    <member name="M:whiteMath.Randoms.RandomMersenneTwister.NextUInt">
      <summary>
            Generates the next unsigned integer.
            </summary>
      <returns>A random unsigned integer in [uint.MinValue; uint.MaxValue) interval.</returns>
    </member>
    <member name="T:whiteMath.Randoms.RandomNormalBoxMuller`2">
      <summary>
            This class is a wrapper around a uniformly distributed
            fractional random numbers generator and is dedicated to
            generating normal random numbers with specified expectation
            and standard deviation.
            </summary>
      <typeparam name="T">The type of random numbers generated. Is expected to be a fractional number type.</typeparam>
      <typeparam name="C">A calculator for the <typeparamref name="T" /> numeric type.</typeparam>
    </member>
    <member name="T:whiteMath.Randoms.RandomStandard">
      <summary>
            Represents a wrapper for a standard <c>Random</c> class from the C# library
            to provide additional functionality (e.g. generating <c>long</c> values) and to implement 
            <c>IRandomBounded&lt;T&gt;</c>, <c>IRandomUnbounded&lt;T&gt;</c> and <c>IRandomFloatingPoint&lt;T&gt;</c> interfaces 
            for compatibility with whiteMath library methods.
            </summary>
      <invariant>this.rnd != null</invariant>
    </member>
    <member name="M:whiteMath.Randoms.RandomStandard.#ctor">
      <summary>
            Creates a new instance of RandomStandard class using a clock-dependent
            unknown seed value. 
            </summary>
    </member>
    <member name="M:whiteMath.Randoms.RandomStandard.#ctor(System.Int32)">
      <summary>
            Creates a new instance of RandomStandard class using an explicitly
            provided integer seed value.
            </summary>
      <param name="seed" />
    </member>
    <member name="M:whiteMath.Randoms.RandomStandard.NextBytes(System.Byte[])">
      <summary>
            Generates a sequence of random bytes
            and stores them in the buffer.
            </summary>
      <param name="buffer">A byte array to store the random sequence.</param>
    </member>
    <member name="M:whiteMath.Randoms.RandomStandard.NextInt">
      <summary>
            Returns the next pseudo-random integer value
            in the [int.MinValue; int.MaxValue] interval.
            </summary>
      <returns>The next integer value in the [int.MinValue; int.MaxValue] interval.</returns>
    </member>
    <member name="M:whiteMath.Randoms.RandomStandard.NextInt(System.Int32,System.Int32)">
      <summary>
            Returns the next pseudo-random integer value
            in the [minValue; maxValue) interval.
            </summary>
      <param name="minValue">The lower inclusive bound of the number to be generated.</param>
      <param name="maxValue">The upper exclusive bound of the number to be generated.</param>
      <returns>The next integer value in the [min; max) interval.</returns>
      <requires description="The lower inclusive bound should be less than the upper exclusive." exception="T:System.ArgumentException" csharp="minValue &lt; maxValue" vb="minValue &lt; maxValue">minValue &lt; maxValue</requires>
      <exception cref="T:System.ArgumentException">minValue &gt;= maxValue</exception>
    </member>
    <member name="M:whiteMath.Randoms.RandomStandard.NextULong">
      <summary>
            Returns the next <c>ulong</c> number.
            </summary>
      <returns>A random <c>ulong</c> number.</returns>
    </member>
    <member name="M:whiteMath.Randoms.RandomStandard.NextULong(System.UInt64)">
      <summary>
            Returns the next <c>ulong</c> number limited
            by an exclusive upper boundary.
            </summary>
      <param name="maxValue">The exclusive upper boundary of generated numbers.</param>
      <returns>A random <c>ulong</c> number which is smaller than <paramref name="maxValue" />.</returns>
      <requires description="The upper exclusive boundary for generated values should not be equal to zero." exception="T:System.ArgumentException" csharp="maxValue &gt; ulong(long)0" vb="maxValue &gt; ULong ((Long )0)">maxValue &gt; ulong(long)0</requires>
      <exception cref="T:System.ArgumentException">maxValue &lt;= 0</exception>
    </member>
    <member name="M:whiteMath.Randoms.RandomStandard.NextULong(System.UInt64,System.UInt64)">
      <summary>
            Returns the next <c>ulong</c> number in the <c>[<paramref name="minValue" />; <paramref name="maxValue" />)</c>
            interval.
            </summary>
      <param name="minValue">The lower inclusive boundary of generated values.</param>
      <param name="maxValue">The upper exclusive boundary of generated values.</param>
      <returns>A random <c>ulong</c> number which is bigger than or equal to <paramref name="minValue" /> and less than <paramref name="maxValue" />.</returns>
      <requires description="The upper exclusive boundary should be bigger than the lower inclusive." exception="T:System.ArgumentException" csharp="maxValue &gt; minValue" vb="maxValue &gt; minValue">maxValue &gt; minValue</requires>
      <exception cref="T:System.ArgumentException">maxValue &lt;= minValue</exception>
    </member>
    <member name="M:whiteMath.Randoms.RandomStandard.NextLong">
      <summary>
            Returns the next <c>long</c> value in the [long.MinValue; long.MaxValue]
            interval.
            </summary>
      <returns>The next number in the <c>[long.MinValue; long.MaxValue]</c> interval.</returns>
    </member>
    <member name="M:whiteMath.Randoms.RandomStandard.NextLong(System.Int64)">
      <summary>
            Returns the next non-negative <c>long</c> value that is less than
            <paramref name="maxValue" /></summary>
      <param name="maxValue">The upper exclusive bound for generated number.</param>
      <returns>A non-negative <c>long</c> number that is less than <paramref name="maxValue" /></returns>
      <requires description="The upper exclusive boundary should be a positive number." exception="T:System.ArgumentOutOfRangeException" csharp="maxValue &gt; (long)0" vb="maxValue &gt; ((Long )0)">maxValue &gt; (long)0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">maxValue &lt;= 0</exception>
    </member>
    <member name="M:whiteMath.Randoms.RandomStandard.NextLong(System.Int64,System.Int64)">
      <summary>
            Returns the next <c>long</c> value in the <c>[minValue; maxValue)</c>
            interval.
            </summary>
      <param name="minValue">The lower inclusive bound for generated number.</param>
      <param name="maxValue">The upper exclusive bound for generated number.</param>
      <returns>The next <c>long</c> value in the <c>[minValue; maxValue)</c> interval.</returns>
      <requires description="The lower inclusive boundary should be less than the upper exclusive." exception="T:System.ArgumentException" csharp="maxValue &gt; minValue" vb="maxValue &gt; minValue">maxValue &gt; minValue</requires>
      <exception cref="T:System.ArgumentException">maxValue &lt;= minValue</exception>
    </member>
    <member name="M:whiteMath.Randoms.RandomStandard.NextDouble_SingleInterval">
      <summary>
            Returns the next pseudo-random double value
            in the [0; 1) interval.
            </summary>
      <returns>The next double value in the [0; 1) interval.</returns>
    </member>
    <member name="M:whiteMath.Randoms.RandomStandard.NextDouble">
      <summary>
            Returns the next pseudo-random double value
            in the (-double.MaxValue; double.MaxValue) interval.
            </summary>
      <returns>The next double value in the (-double.MaxValue; double.MaxValue) interval.</returns>
    </member>
    <member name="M:whiteMath.Randoms.RandomStandard.NextDouble(System.Double,System.Double)">
      <summary>
            Return the next pseudo-random double value
            in the [min; max) interval.
            </summary>
      <param name="min">The lower inclusive bound of the number to be generated.</param>
      <param name="max">The upper exclusive bound of the number to be generated.</param>
      <returns>The next pseudo-random double value in the [min; max) interval.</returns>
    </member>
    <member name="T:whiteMath.Rational`2">
      <summary>
            The struct representing the rational number as a pair of integer-like numbers.
            For example:
            <example>Rational&lt;LongInt, CalcLongInt&gt;</example><example>Rational&lt;int, CalcInt&gt;</example></summary>
      <typeparam name="T">The integer-like type of numerator and denominator.</typeparam>
    </member>
    <member name="M:whiteMath.Rational`2.#ctor(`0,`0)">
      <summary>
            The standard constructor for generic Rational numbers.
            User should explicitly specify both the numerator and the denumerator.
            </summary>
      <param name="numerator" />
      <param name="denominator" />
    </member>
    <member name="M:whiteMath.Rational`2.#ctor">
      <summary>
            Parameterless constructor for inner purposes.
            </summary>
    </member>
    <member name="M:whiteMath.Rational`2.normalize">
      <summary>
            Нормализует число, делит числитель и знаменатель на НОД,
            делает числитель положительным.
            </summary>
    </member>
    <member name="M:whiteMath.Rational`2.checkInf(whiteMath.Rational{`0,`1}@)">
      <summary>
            Проверяет число на то, не бесконечность ли оно случаем.
            Если бесконечность, меняет его, чтобы оно стало истинной бесконечностью.
            </summary>
      <param name="obj" />
      <returns />
    </member>
    <member name="M:whiteMath.Rational`2.op_Addition(whiteMath.Rational{`0,`1},whiteMath.Rational{`0,`1})">
            -----------------------------------
            ----ARITHMETIC OPERATORS-----------
            -----------------------------------
        </member>
    <member name="M:whiteMath.Rational`2.op_UnaryNegation(whiteMath.Rational{`0,`1})">
      <summary>
            Унарный минус.
            </summary>
      <param name="one" />
      <returns />
    </member>
    <member name="M:whiteMath.Rational`2.op_Equality(whiteMath.Rational{`0,`1},whiteMath.Rational{`0,`1})">
            -----------------------------------
            ----LOGICAL OPERATORS--------------
            -----------------------------------
        </member>
    <member name="M:whiteMath.Rational`2.op_Implicit(`0)~whiteMath.Rational{`0,`1}">
            -----------------------------------
            -------------CONVERSION OPERATORS--
            -----------------------------------
        </member>
    <member name="M:whiteMath.Rational`2.op_Explicit(whiteMath.Rational{`0,`1})~`0">
      <summary>
            Divides the numerator by the denominator using the 
            <typeparamref name="C" /> calculator's division operation
            and returns the result.
            
            If <typeparamref name="T" /> is integer type, may result in
            a loss of result's fractional part.
            </summary>
      <param name="obj">
            The number whose <typeparamref name="T" /> type equivalent
            is to be found.
            </param>
      <returns>
            The result of dividing the numerator by the denominator using 
            <typeparamref name="C" /> calculator's division function.
            </returns>
    </member>
    <member name="M:whiteMath.Rational`2.Clone">
      <summary>
            Gets the exact deep copy of the current number.
            </summary>
      <ensures inheritedFrom="M:System.ICloneable.Clone" inheritedFromTypeName="ICloneable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:whiteMath.Rational`2.GetHashCode">
      <summary>
            Gets the hash code for current number.
            Still works stupidly (though reasonable), but will be fixed soon.
            </summary>
      <returns />
    </member>
    <member name="M:whiteMath.Rational`2.Equals(System.Object)">
      <summary>
            Checks if two Rationals store the same numeric value.
            </summary>
      <param name="obj" />
      <returns />
    </member>
    <member name="M:whiteMath.Rational`2.ToString">
      <summary>
            Returns the string representation of current Rational number.
            </summary>
      <returns>The string value containing representation of the number.</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:whiteMath.Rational`2.Parse(System.String)">
      <summary>
            Parses the string containing the rational number.
            Syntax:
            
            1. [numerator; denominator]
            2. [numerator / denominator]
            3. numerator / denominator
            
            Numerator and denominator should be written in the format in accordance 
            to their own Parse methods.
            </summary>
      <param name="value" />
      <returns />
    </member>
    <member name="T:whiteMath.Rational`2.NumberFormat">
      <summary>
            Used by the overloaded ToString() method, provides one of the following number formats:
            
            1. IntegerPair:     [num; denom]
            2. Num_Div_Denom:   num/denom
            3. Both:            [num/denom]
            </summary>
    </member>
    <member name="M:whiteMath.General.ContainerExtensions.createContainingForm(System.Windows.Forms.UserControl,System.Windows.Forms.FormBorderStyle)">
      <summary>
            Creates the form that contains the invoking user control as its only child component.
            </summary>
    </member>
    <member name="T:whiteMath.General.ExcelReadDirection">
      <summary>
            Specifies the direction in which the Excel file reading should occur.
            </summary>
    </member>
    <member name="T:whiteMath.General.ExcelArrayReader">
      <summary>
            Reads arrays of elements from a Microsoft Office Excel (tm) file.
            </summary>
    </member>
    <member name="M:whiteMath.General.ExcelArrayReader.openConnection(System.String)">
      <summary>
            Opens a connection by running Microsoft Excel application and opening the file at the path specified.
            Never forget to close the connection after usage.
            </summary>
      <param name="path" />
      <returns />
    </member>
    <member name="M:whiteMath.General.ExcelArrayReader.checkStartCellIsSet">
      <summary>
            -SERVICE- check if the start cell is set
            </summary>
    </member>
    <member name="M:whiteMath.General.ExcelArrayReader.setDirection">
      <summary>
            -SERVICE- if both start and end cells are set, we can guess the reading direction
            </summary>
    </member>
    <member name="M:whiteMath.General.ExcelArrayReader.checkerStart(Microsoft.Office.Interop.Excel.Range)">
      <summary>
            Handler for cell changing during start cell capturing.
            </summary>
      <param name="range" />
    </member>
    <member name="M:whiteMath.General.ExcelArrayReader.checkerEnd(Microsoft.Office.Interop.Excel.Range)">
      <summary>
            Handler for cell changing during end cell capturing.
            </summary>
      <param name="range" />
    </member>
    <member name="M:whiteMath.General.ExcelArrayReader.closeConnection(Microsoft.Office.Interop.Excel.Workbook)">
      <summary>
            Closes the previously opened Excel connection and cleans up all the resources.
            </summary>
    </member>
    <member name="T:whiteMath.BoundedIntervalSplitOptions">
      <summary>
            This enum contains options to specify when splitting the interval into a sequence of non-intersecting intervals
            and the source interval does not contain a whole number of intervals of the desired length. 
            </summary>
    </member>
    <member name="F:whiteMath.BoundedIntervalSplitOptions.BiggerLastInterval">
      <summary>
            When using this option, in case of presence of the 'tail' length,
            the last interval will have length bigger than the desired.
            The overall number of intervals produced will be floor(currentInterval.length / desiredLength).
            </summary>
    </member>
    <member name="F:whiteMath.BoundedIntervalSplitOptions.SmallerLastInterval">
      <summary>
            When using this option, in case of presence of the 'tail' length,
            the last interval will have length smaller than the desired.
            The overall number of intervals produced will be ceil(currentInterval.length / desiredLength).
            </summary>
    </member>
    <member name="T:whiteMath.BoundedInterval`2">
      <summary>
            This struct represents a numeric interval with either inclusive or exclusive bounds.
            Is supposed to be bounded.
            </summary>
      <typeparam name="T">The type of numbers in the interval.</typeparam>
      <typeparam name="C">The calculator for the number type.</typeparam>
    </member>
    <member name="M:whiteMath.BoundedInterval`2.#ctor(`0,`0,System.Boolean,System.Boolean)">
      <summary>
            Creates a new instance of an interval.
            </summary>
      <param name="left">The leftmost interval bound.</param>
      <param name="leftInclusive">The flag determining whether the leftmost bound is included into the interval.</param>
      <param name="right">The rightmost interval bound.</param>
      <param name="rightInclusive">The flag determining whether the rightmost bound is included into the interval.</param>
    </member>
    <member name="M:whiteMath.BoundedInterval`2.Contains(`0)">
      <summary>
            Tests whether the point is located inside the interval bounds.
            </summary>
      <param name="x">The point to test.</param>
      <returns>True if the interval contains the specified point, false otherwise.</returns>
    </member>
    <member name="M:whiteMath.BoundedInterval`2.ToInclusiveIntegerInterval">
      <summary>
            For integer intervals, returns an interval 
            containing the same integer values as the current, 
            but whose left and right bounds are both inclusive.
            </summary>
      <exception cref="T:whiteMath.NonIntegerTypeException">
            A <c>NonIntegerTypeException</c> will be raised if
            <typeparamref name="T" /> is not an integer type.
            </exception>
      <exception cref="T:System.InvalidOperationException">
            An <c>InvalidOperationException</c> will be raised in case when
            the interval is empty so that it cannot be made both-bound inclusive.
            </exception>
      <returns>
            An interval 
            containing the same integer values as the current, 
            but whose left and right bounds are both inclusive.
            </returns>
      <requires description="The bounds of the interval should be of integer type." exception="T:whiteMath.NonIntegerTypeException" csharp="Calculator.isIntegerCalculator" vb="Calculator.isIntegerCalculator">whiteMath.Numeric&lt;T, C&gt;.Calculator.isIntegerCalculator</requires>
      <exception cref="T:whiteMath.NonIntegerTypeException">Numeric&gt;=T</exception>
    </member>
    <member name="M:whiteMath.BoundedInterval`2.ToExclusiveIntegerInterval">
      <summary>
            For integer intervals, returns an interval 
            containing the same integer values as the current, 
            but whose left and right bounds are both exclusive.
            </summary>
      <exception cref="T:whiteMath.NonIntegerTypeException">
            A <c>NonIntegerTypeException</c> will be raised if
            <typeparamref name="T" /> is not an integer type.
            </exception>
      <returns>
            An interval 
            containing the same integer values as the current, 
            but whose left and right bounds are both exclusive.
            </returns>
      <requires description="The bounds of the interval should be of integer type." exception="T:whiteMath.NonIntegerTypeException" csharp="Calculator.isIntegerCalculator" vb="Calculator.isIntegerCalculator">whiteMath.Numeric&lt;T, C&gt;.Calculator.isIntegerCalculator</requires>
      <exception cref="T:whiteMath.NonIntegerTypeException">Numeric&gt;=T</exception>
    </member>
    <member name="M:whiteMath.BoundedInterval`2.Split(System.Int32)">
      <summary>
            Splits the interval into a sequence of non-intersecting
            intervals of possibly equal length.
            </summary>
      <param name="parts">The number of parts.</param>
      <remarks>
            Due to roundoff errors the last interval of the sequence might be bigger than the others.
            </remarks>
      <returns>
            A <c>List</c> of [<c><paramref name="parts" /></c>] non-intersecting intervals which
            in union will make up the current.
            </returns>
      <requires description="The amount of parts should be a positive integer number." exception="T:System.ArgumentOutOfRangeException" csharp="parts &gt; 0" vb="parts &gt; 0">parts &gt; 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">parts &lt;= 0</exception>
      <requires description="The specified amount of parts will result in zero-length intervals due to the numeric precision." exception="T:System.ArgumentException" csharp="this.Length / op_Explicit((long)parts) != Zero" vb="Me.Length / operator ((Long )parts)  &lt;&gt; Zero ">this.Length / whiteMath.Numeric&lt;T, C&gt;.op_Explicit((long)parts) != whiteMath.Numeric&lt;T, C&gt;.Zero</requires>
      <exception cref="T:System.ArgumentException">!(this.Length / (Numeric&lt;T,C&gt;)parts != Numeric&lt;T)</exception>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures csharp="result.Count &gt; 0" vb="result.Count &gt; 0">result.Count &gt; 0</ensures>
    </member>
    <member name="M:whiteMath.BoundedInterval`2.Split(`0,whiteMath.BoundedIntervalSplitOptions)">
      <summary>
            Splits the current interval into a sequence of intervals of desired length.
            </summary>
      <param name="length">The desired length of the interval.</param>
      <param name="options">
            If the length of the current interval does not contain a whole number of desired lengths, 
            the 'tail' length will be packed into the last interval depending on the options.
            </param>
      <returns>
            A sequence of intervals which give the current interval in union and have all
            (maybe except for the last one) the desired length.
            </returns>
      <requires description="The desired length should be positive." exception="T:System.ArgumentOutOfRangeException" csharp="op_Implicit(length) &gt; Zero" vb="operator length &gt; Zero ">whiteMath.Numeric&lt;T, C&gt;.op_Implicit(length) &gt; whiteMath.Numeric&lt;T, C&gt;.Zero</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(length &gt; Numeric&lt;T)</exception>
      <requires description="The desired length should not exceed the current interval's length." exception="T:System.ArgumentOutOfRangeException" csharp="op_Implicit(length) &lt;= this.Length" vb="operator length &lt;= Me.Length ">whiteMath.Numeric&lt;T, C&gt;.op_Implicit(length) &lt;= this.Length</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(length &lt;= (Numeric&lt;T,C&gt;)this.Length)</exception>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:whiteMath.BoundedInterval`2.LeftBound">
      <summary>
            Gets the leftmost bound of the interval.
            </summary>
    </member>
    <member name="P:whiteMath.BoundedInterval`2.RightBound">
      <summary>
            Gets the rightmost bound of the interval.
            </summary>
    </member>
    <member name="P:whiteMath.BoundedInterval`2.IsLeftInclusive">
      <summary>
            Tests whether the leftmost bound is inclusive,.
            </summary>
    </member>
    <member name="P:whiteMath.BoundedInterval`2.IsRightInclusive">
      <summary>
            Tests whether the rightmost bound is inclusive.
            </summary>
    </member>
    <member name="P:whiteMath.BoundedInterval`2.IsZeroLength">
      <summary>
            Tests whether the interval has zero length.
            </summary>
    </member>
    <member name="P:whiteMath.BoundedInterval`2.IsEmptyReal">
      <summary>
            Tests whether the interval contains exactly 0 real-value points.
            </summary>
    </member>
    <member name="P:whiteMath.BoundedInterval`2.IsEmptyInteger">
      <summary>
            Tests whether the interval contains exactly 0 integer points.
            </summary>
    </member>
    <member name="P:whiteMath.BoundedInterval`2.Length">
      <summary>
            Returns the length of the interval.
            </summary>
    </member>
    <member name="P:whiteMath.BoundedInterval`2.Middle">
      <summary>
            Returns the arithmetic middle of the interval.
            </summary>
    </member>
    <member name="P:whiteMath.BoundedInterval`2.PointCount">
      <summary>
            Returns the amount of points in the interval.
            </summary>
      <remarks>Works only for integer <typeparamref name="T" /> types!</remarks>
      <getter>
        <requires description="The bounds of the interval should be of integer type." exception="T:whiteMath.NonIntegerTypeException" csharp="Calculator.isIntegerCalculator" vb="Calculator.isIntegerCalculator">whiteMath.Numeric&lt;T, C&gt;.Calculator.isIntegerCalculator</requires>
      </getter>
      <exception cref="T:whiteMath.NonIntegerTypeException">Numeric&gt;=T</exception>
    </member>
    <member name="T:whiteMath.BoundedInterval`2.IntervalComparisons">
      <summary>
            This class provides various-logic comparisons
            between bounded intervals.
            </summary>
    </member>
    <member name="P:whiteMath.BoundedInterval`2.IntervalComparisons.LeftBoundLazyComparison">
      <summary>
            Compares the two intervals basing on their left bounds.
            Inclusiveness or exclusiveness of the bound doesn't count.
            </summary>
    </member>
    <member name="P:whiteMath.BoundedInterval`2.IntervalComparisons.LeftBoundComparison">
      <summary>
            Compares the two intervals basing on their left bounds.
            Exclusive bound is 'less' than inclusive.
            </summary>
    </member>
    <member name="P:whiteMath.BoundedInterval`2.IntervalComparisons.RightBoundLazyComparison">
      <summary>
            Compares the two intervals basing on their right bounds.
            Inclusiveness or exclusiveness of the bound doesn't count.
            </summary>
    </member>
    <member name="P:whiteMath.BoundedInterval`2.IntervalComparisons.RightBoundComparison">
      <summary>
            Compares the two intervals basing on their right bounds.
            Exclusive bound is 'less' than inclusive.
            </summary>
    </member>
    <member name="P:whiteMath.BoundedInterval`2.IntervalComparisons.LengthComparison">
      <summary>
            Compares two intervals basing on the interval length.
            Inclusiveness or exclusiveness of the bounds doesn't count.
            </summary>
    </member>
    <member name="T:whiteMath.BoundedIntervalExtensions">
      <summary>
            This class provides different extensions (such as hit tests)
            for <c>BoundedInterval&lt;T, C&gt;</c> sequences.
            </summary>
    </member>
    <member name="M:whiteMath.BoundedIntervalExtensions.Max_LinearSearch``2(whiteMath.BoundedInterval{``0,``1},System.Predicate{``0})">
      <summary>
            Finds the maximum number '<c>k</c>' within a given integer interval such that a predicate
            holds for this number '<c>k</c>'.
            </summary>
      <typeparam name="T">The type of numbers contained inside the interval.</typeparam>
      <typeparam name="C">A calculator for the <typeparamref name="T" /> type.</typeparam>
      <param name="interval">
            An integer interval, containing at least one number for which the <paramref name="predicate" />
            holds.
            </param>
      <param name="predicate">
            A predicate that should hold for the desired number and not for every number that is bigger and located
            inside the interval.
            </param>
      <remarks>
            This method takes <c>O(n)</c> time for intervals of length '<c>n</c>'. Thus, it usually works significantly 
            slower than <see cref="M:whiteMath.BoundedIntervalExtensions.Max_BinarySearch``2(whiteMath.BoundedInterval{``0,``1},System.Predicate{``0})" />, but does not put any restrictions 
            on the <paramref name="interval" /> object passed.
            </remarks>
      <returns>
            A <c>PotentialResult&lt;Numeric&lt;T, C&gt;&gt;</c> object which will store
            the maximum number within a given interval for which the <paramref name="predicate" /> holds, if the algorithm
            finds one.
            </returns>
      <requires description="This method works only for integer numbers." exception="T:System.ArgumentException" csharp="Calculator.isIntegerCalculator" vb="Calculator.isIntegerCalculator">whiteMath.Numeric&lt;T, C&gt;.Calculator.isIntegerCalculator</requires>
      <exception cref="T:System.ArgumentException">Numeric&gt;=T</exception>
      <requires description="predicate" exception="T:System.ArgumentNullException" csharp="predicate != null" vb="predicate &lt;&gt; Nothing">predicate != null</requires>
      <exception cref="T:System.ArgumentNullException">predicate == null</exception>
      <requires description="The interval should contain at least one integer point." exception="T:System.ArgumentException" csharp="!interval.IsEmptyInteger" vb="Not interval.IsEmptyInteger">!interval.IsEmptyInteger</requires>
      <exception cref="T:System.ArgumentException">interval.IsEmptyInteger</exception>
    </member>
    <member name="M:whiteMath.BoundedIntervalExtensions.Max_BinarySearch``2(whiteMath.BoundedInterval{``0,``1},System.Predicate{``0})">
      <summary>
            Finds the maximum number '<c>k</c>' within a given integer interval of special structure 
            such that a predicate holds for this number '<c>k</c>'.
            </summary>
      <typeparam name="T">The type of numbers contained inside the interval.</typeparam>
      <typeparam name="C">A calculator for the <typeparamref name="T" /> type.</typeparam>
      <param name="interval">
        <para>
            An integer interval which has a structure such that all numbers, starting with the leftmost inclusive bound and 
            ending with the desired (sought-for) number, satisfy the predicate (and only these).
            In other words, the leftmost 'tail' of the interval should satisfy the predicate, 
            and the rightmost 'tail' should not; the rightmost tail, though, may be empty.
            </para>
        <para>
            It should be KNOWN that the interval has such structure and that at least the leftmost inclusive bound satisfies the predicate.
            Otherwise, the behaviour of the function is undefined.
            </para>
      </param>
      <param name="predicate">
            A predicate that should hold for all numbers, starting with the leftmost bound and ending with the 
            desired (sought-for) number, and only for these.
            </param>
      <returns>The maximum number within a given interval for which the <paramref name="predicate" /> holds.</returns>
      <requires description="This method works only for integer numbers." exception="T:whiteMath.NonIntegerTypeException" csharp="Calculator.isIntegerCalculator" vb="Calculator.isIntegerCalculator">whiteMath.Numeric&lt;T, C&gt;.Calculator.isIntegerCalculator</requires>
      <exception cref="T:whiteMath.NonIntegerTypeException">Numeric&gt;=T</exception>
      <requires description="The interval should contain at least one integer point." exception="T:System.ArgumentException" csharp="!interval.IsEmptyInteger" vb="Not interval.IsEmptyInteger">!interval.IsEmptyInteger</requires>
      <exception cref="T:System.ArgumentException">interval.IsEmptyInteger</exception>
    </member>
    <member name="M:whiteMath.BoundedIntervalExtensions.HitTest``2(System.Collections.Generic.IList{whiteMath.BoundedInterval{``0,``1}},``0)">
      <summary>
            Searches a special-way sorted list of non-intersecting <c>BoundedInterval&lt;<typeparamref name="T" />, <typeparamref name="C" />&gt;</c> 
            elements and returns the index of interval which contains the specified point.
            </summary>
      <typeparam name="T">A type of numbers contained inside the interval.</typeparam>
      <typeparam name="C">A calculator for the <typeparamref name="T" /> type.</typeparam>
      <param name="list">A list of non-intersecting intervals, sorted on their left bounds.</param>
      <param name="point">The point to search for.</param>
      <remarks>Warning! If the list is either not sorted on interval's left bounds or contains several intersecting intervals, the result of the function is undefined.</remarks>
      <returns>The index of interval containing the specified point, or a negative value if such interval hasn't been found.</returns>
      <requires description="list" exception="T:System.ArgumentNullException" csharp="list != null" vb="list &lt;&gt; Nothing">list != null</requires>
      <exception cref="T:System.ArgumentNullException">list == null</exception>
      <ensures csharp="result &lt; list.Count" vb="result &lt; list.Count">result &lt; list.Count</ensures>
    </member>
    <member name="T:whiteMath.General.GrapherExtensions">
      <summary>
            Class providing the extension methods used by graphers.
            </summary>
    </member>
    <member name="M:whiteMath.General.GrapherExtensions.CreateSmoothPieceLinearGrapher(whiteMath.Graphers.StandardGrapher)">
      <summary>
            Creates a piece-linear function from the grapher points array
            and then a FunctionGrapher object.
            
            This trick allows the grapher to behave more smoothly during scaling,
            no points usually are 'lost'.
            </summary>
      <returns />
    </member>
    <member name="T:whiteMath.General.Point`1">
      <summary>
            Represents the pair of objects as a logical point.
            </summary>
      <typeparam name="T">The type of the objects in the point.</typeparam>
    </member>
    <member name="M:whiteMath.General.Point`1.#ctor(`0,`0)">
      <summary>
            Constructs the point object using two separate objects.
            </summary>
      <param name="x">The first object.</param>
      <param name="y">The second object.</param>
    </member>
    <member name="M:whiteMath.General.Point`1.ZeroPoint``1">
      <summary>
            Provided with a calculator type for the type <typeparamref name="T" />,
            will return a zero-coordinate point where 'zero' value is
            specified by the <typeparamref name="C" /> calculator type.
            </summary>
      <typeparam name="C">A calculator for the <typeparamref name="T" /> numeric type.</typeparam>
      <returns>
            A zero-coordinate point where 'zero' value is
            specified by the <typeparamref name="C" /> calculator type.
            </returns>
    </member>
    <member name="M:whiteMath.General.Point`1.GetComparerOnX(System.Collections.Generic.IComparer{`0})">
      <summary>
            Returns the comparer for the points using the
            comparer for the point components of type <typeparamref name="T" />.
            
            The resulting comparer would compare two points on their X values.
            </summary>
      <param name="tComparer">A comparer for the point component type.</param>
      <returns>The resulting comparer that compares two points on their X values.</returns>
      <requires description="tComparer" exception="T:System.ArgumentNullException" csharp="tComparer != null" vb="tComparer &lt;&gt; Nothing">tComparer != null</requires>
      <exception cref="T:System.ArgumentNullException">tComparer == null</exception>
    </member>
    <member name="M:whiteMath.General.Point`1.GetComparerOnY(System.Collections.Generic.IComparer{`0})">
      <summary>
            Returns the comparer for the points using the
            comparer for the point components of type <typeparamref name="T" />.
            
            The resulting comparer would compare two points on their Y values.
            </summary>
      <param name="tComparer">A comparer for the point component type.</param>
      <returns>The resulting comparer that compares two points on their Y values.</returns>
      <requires description="tComparer" exception="T:System.ArgumentNullException" csharp="tComparer != null" vb="tComparer &lt;&gt; Nothing">tComparer != null</requires>
      <exception cref="T:System.ArgumentNullException">tComparer == null</exception>
    </member>
    <member name="P:whiteMath.General.Point`1.X">
      <summary>
            The X coordinate of the point.
            </summary>
    </member>
    <member name="P:whiteMath.General.Point`1.Y">
      <summary>
            The Y coordinate of the point.
            </summary>
    </member>
    <member name="P:whiteMath.General.Point`1.Item(System.Int32)">
      <summary>
            Provides an alternative way of accessing the point elements.
            </summary>
      <param name="index">The index value. Should be 0 or 1.</param>
      <returns>The value of the first or the second point element respectively.</returns>
    </member>
    <member name="T:whiteMath.General.Point`1.PointComparer">
      <summary>
            Сравниватель точек на основе сравнивателя аргументов точек.
            </summary>
      <invariant>this.tComparer != null</invariant>
    </member>
    <member name="T:whiteMath.General.ClassicEnumerator`1">
      <summary>
            The classic enumerator for IList<typeparamref name="T" />.
            </summary>
    </member>
    <member name="M:whiteMath.General.ClassicEnumerator`1.#ctor(System.Collections.Generic.IList{`0})">
      <summary>
            Creates a <see cref="T:whiteMath.General.ClassicEnumerator`1" /> for an <see cref="T:System.Collections.Generic.IList`1" />.
            </summary>
    </member>
    <member name="M:whiteMath.General.ClassicEnumerator`1.MoveNext">
      <summary>
            Moves the enumerator so that it points to the next element of the collection.
            </summary>
      <ensures inheritedFrom="M:System.Collections.IEnumerator.MoveNext" inheritedFromTypeName="IEnumerator" csharp="this.get_Model == old(this.get_Model)" vb="Me.get_Model = old(Me.get_Model)">this.get_Model == old(this.get_Model)</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerator.MoveNext" inheritedFromTypeName="IEnumerator" csharp="this.get_CurrentIndex &lt; this.get_Model.Length" vb="Me.get_CurrentIndex &lt; Me.get_Model.Length">this.get_CurrentIndex &lt; this.get_Model.Length</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerator.MoveNext" inheritedFromTypeName="IEnumerator" csharp="this.get_CurrentIndex &gt;= 0" vb="Me.get_CurrentIndex &gt;= 0">this.get_CurrentIndex &gt;= 0</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerator.MoveNext" inheritedFromTypeName="IEnumerator" csharp="this.get_CurrentIndex == old(this.get_CurrentIndex) + 1" vb="Me.get_CurrentIndex = old(Me.get_CurrentIndex) + 1">this.get_CurrentIndex == old(this.get_CurrentIndex) + 1</ensures>
    </member>
    <member name="M:whiteMath.General.ClassicEnumerator`1.Dispose">
      <summary>
            Disposes the enumerator so that it becomes stale (unusable),
            freeing all references to any objects.
            </summary>
    </member>
    <member name="M:whiteMath.General.ClassicEnumerator`1.Reset">
      <summary>
            Resets the enumerator so that it points to the
            'before-the-first' element of the collection.
            </summary>
    </member>
    <member name="P:whiteMath.General.ClassicEnumerator`1.System#Collections#IEnumerator#Current">
      <summary>
            Gets the element to which the enumerator currently points.
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.IEnumerator.get_Current" inheritedFromTypeName="IEnumerator" csharp="result == this.get_Model[this.get_CurrentIndex]" vb="result = Me.get_Model(Me.get_CurrentIndex)">result == this.get_Model[this.get_CurrentIndex]</ensures>
      </getter>
    </member>
    <member name="P:whiteMath.General.ClassicEnumerator`1.Current">
      <summary>
            Gets the element to which the enumerator currently points.
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.IEnumerator`1.get_Current" inheritedFromTypeName="IEnumerator" csharp="(object)result == this.get_Model[this.get_CurrentIndex]" vb="((Object)result) = Me.get_Model(Me.get_CurrentIndex)">(object)result == this.get_Model[this.get_CurrentIndex]</ensures>
      </getter>
    </member>
    <member name="T:whiteMath.General.DefaultList`1">
      <summary>
            This class is used to return a default element
            when the index specified is out of the bounds.
            </summary>
      <typeparam name="T" />
    </member>
    <member name="M:whiteMath.General.DefaultList`1.#ctor(System.Collections.Generic.IList{`0},`0)">
      <summary>
            Constructs a new instance of DefaultList.
            </summary>
      <param name="list" />
      <param name="defaultValue" />
    </member>
    <member name="T:whiteMath.General.ListFragment`1">
      <summary>
            Represents the list fragment determined by the parent list and a set of indices.
            Logically considered incontinuous.
            </summary>
      <typeparam name="T" />
    </member>
    <member name="M:whiteMath.General.ListFragment`1.IndexOf(`0)">
      <summary>
            Returns the logical index of the element that is equal to the key.
            </summary>
      <param name="key" />
      <returns />
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.IndexOf(`0)" inheritedFromTypeName="IList" csharp="result &gt;= -1" vb="result &gt;= -1">result &gt;= -1</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.IndexOf(`0)" inheritedFromTypeName="IList" csharp="result &lt; this.Count" vb="result &lt; Me.Count">result &lt; this.Count</ensures>
    </member>
    <member name="M:whiteMath.General.ListFragment`1.Contains(`0)">
      <summary>
            Returns true if the list fragment contains the element equal to the key specified.
            </summary>
      <param name="key" />
      <returns />
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Contains(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt; 0" vb="result Implies Me.Count &gt; 0">!result || this.Count &gt; 0</ensures>
    </member>
    <member name="M:whiteMath.General.ListFragment`1.CopyTo(`0[],System.Int32)">
      <summary>
            Copies all the elements from the list fragment to an array.
            </summary>
      <param name="array" />
      <param name="offset" />
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="array != null" vb="array &lt;&gt; Nothing">array != null</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &gt;= 0" vb="arrayIndex &gt;= 0">arrayIndex &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &lt;= array.Length - this.Count" vb="arrayIndex &lt;= array.Length - Me.Count">arrayIndex &lt;= array.Length - this.Count</requires>
    </member>
    <member name="M:whiteMath.General.ListFragment`1.getOdds(System.Collections.Generic.IList{`0})">
      <summary>
            Returns the list fragment containing all parent list elements with odd indices.
            </summary>
      <param name="list" />
      <returns />
    </member>
    <member name="M:whiteMath.General.ListFragment`1.getEvens(System.Collections.Generic.IList{`0})">
      <summary>
            Returns the list fragment containing all parent list elements with even indices.
            </summary>
      <param name="list" />
      <returns />
    </member>
    <member name="M:whiteMath.General.ListFragment`1.getBitReversed(System.Collections.Generic.IList{`0})">
      <summary>
            Returns the list fragment containing all the elements of the parent list
            in the order of Bit-Reverse-Permutation.
            
            Frequently used in iterational FFT and other algorithms.
            </summary>
      <param name="list" />
      <returns />
    </member>
    <member name="P:whiteMath.General.ListFragment`1.Item(System.Int32)">
      <summary>
            The indexer for the list fragment.
            </summary>
      <param name="index" />
      <returns />
      <getter>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.get_Item(System.Int32)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.get_Item(System.Int32)" inheritedFromTypeName="IList" csharp="index &lt; this.Count" vb="index &lt; Me.Count">index &lt; this.Count</requires>
      </getter>
      <setter>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.set_Item(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.set_Item(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &lt; this.Count" vb="index &lt; Me.Count">index &lt; this.Count</requires>
      </setter>
    </member>
    <member name="P:whiteMath.General.ListFragment`1.IsReadOnly">
      <summary>
            Returns true if the list fragment is read only.
            </summary>
    </member>
    <member name="P:whiteMath.General.ListFragment`1.Count">
      <summary>
            Returns the amount of elements in the list fragment.
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.get_Count" inheritedFromTypeName="ICollection" csharp="result &gt;= 0" vb="result &gt;= 0">result &gt;= 0</ensures>
      </getter>
    </member>
    <member name="T:whiteMath.General.ListSegment`1">
      <summary>
            Wrapper class which represents a segment of an IList&lt;<typeparamref name="T" />&gt;.
            </summary>
      <typeparam name="T">The type of elements in the list.</typeparam>
    </member>
    <member name="M:whiteMath.General.ListSegment`1.Add(`0)">
      <summary>
            Adds an element to the end of the segment.
            Is NOT quick. The length of the segment is automatically increased.
            </summary>
      <param name="value" />
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Add(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &gt;= old(this.Count)" vb="Me.Count &gt;= old(Me.Count)">this.Count &gt;= old(this.Count)</ensures>
    </member>
    <member name="M:whiteMath.General.ListSegment`1.Remove(`0)">
      <summary>
            Removes the first occurence of an object from the list segment.
            The length of the segment is automatically decreased if successful.
            </summary>
      <param name="key" />
    </member>
    <member name="M:whiteMath.General.ListSegment`1.CopyTo(`0[],System.Int32)">
      <summary>
            Copies the elements from the list segment to an array.
            </summary>
      <param name="array" />
      <param name="offset" />
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="array != null" vb="array &lt;&gt; Nothing">array != null</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &gt;= 0" vb="arrayIndex &gt;= 0">arrayIndex &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &lt;= array.Length - this.Count" vb="arrayIndex &lt;= array.Length - Me.Count">arrayIndex &lt;= array.Length - this.Count</requires>
    </member>
    <member name="M:whiteMath.General.ListSegment`1.Insert(System.Int32,`0)">
      <summary>
            Inserts the item into the segment.
            The length of the segment is automatically incremented.
            </summary>
      <param name="index" />
      <param name="value" />
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &lt;= this.Count" vb="index &lt;= Me.Count">index &lt;= this.Count</requires>
    </member>
    <member name="M:whiteMath.General.ListSegment`1.RemoveAt(System.Int32)">
      <summary>
            Removes an item from the segment.
            The length of the segment is automatically decreased.
            </summary>
      <param name="index" />
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList" csharp="index &lt; this.Count" vb="index &lt; Me.Count">index &lt; this.Count</requires>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList" csharp="this.Count == old(this.Count) - 1" vb="Me.Count = old(Me.Count) - 1">this.Count == old(this.Count) - 1</ensures>
    </member>
    <member name="M:whiteMath.General.ListSegment`1.Clear">
      <summary>
            Clears the current list segment.
            The parent list is also modified.
            </summary>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Clear" inheritedFromTypeName="ICollection" csharp="this.Count == 0" vb="Me.Count = 0">this.Count == 0</ensures>
    </member>
    <member name="M:whiteMath.General.ListSegment`1.IndexOf(`0)">
      <summary>
            Returns the list segment index of a key specified by user.
            If the key is not found within the segment, a negative value is returned.
            </summary>
      <param name="key" />
      <returns />
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.IndexOf(`0)" inheritedFromTypeName="IList" csharp="result &gt;= -1" vb="result &gt;= -1">result &gt;= -1</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.IndexOf(`0)" inheritedFromTypeName="IList" csharp="result &lt; this.Count" vb="result &lt; Me.Count">result &lt; this.Count</ensures>
    </member>
    <member name="M:whiteMath.General.ListSegment`1.transformIndex(System.Int32)">
      <summary>
            Transfors the inner index into the parent list index.
            </summary>
      <param name="ind" />
      <returns />
    </member>
    <member name="P:whiteMath.General.ListSegment`1.Count">
      <summary>
            Returns the element count in the current list segment
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.get_Count" inheritedFromTypeName="ICollection" csharp="result &gt;= 0" vb="result &gt;= 0">result &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:whiteMath.General.ListSegment`1.IsReadOnly">
      <summary>
            Returns true if current list segment is read-only.
            </summary>
    </member>
    <member name="T:whiteMath.General.ListSegmentationExtensions">
      <summary>
            This class provides convenience extension methods for <c>IList&lt;T&gt;</c> objects 
            related to creating <c>ListSegment</c>'s from them.
            </summary>
      <see cref="T:whiteMath.General.ListSegment`1" />
    </member>
    <member name="M:whiteMath.General.ListSegmentationExtensions.CoverWithSegments``1(System.Collections.Generic.IList{``0},System.Int32,whiteMath.General.ListSegmentationExtensions.SegmentationOptions)">
      <summary>
            Covers a <c>List&lt;T&gt;</c> with a sequence of non-intersecting <c>ListSegment</c>'s.
            </summary>
      <typeparam name="T">The type of elements in the list.</typeparam>
      <param name="list">The calling <c>List&lt;T&gt;</c> object.</param>
      <param name="segmentLength">
            The desired length of segments. Depending on the <paramref name="options" />,
            if the length of the <paramref name="list" /> does not contain a whole number
            of desired lengths, the last segment may be smaller or bigger.
            </param>
      <param name="options">
            Options which matter when the length of the <paramref name="list" />
            does not contain a whole number of desired length. This parameter
            will affect the length of the last segment and the total number of segments in this case.
            </param>
      <returns>A list of non-intersecting segments which cover the <paramref name="list" />.</returns>
      <requires description="list" exception="T:System.ArgumentNullException" csharp="list != null" vb="list &lt;&gt; Nothing">list != null</requires>
      <exception cref="T:System.ArgumentNullException">list == null</exception>
      <ensures csharp="(() =&gt; {
    {
        System.Collections.Generic.List&lt;whiteMath.General.ListSegment&lt;T&gt;&gt; local_0 = result;
    }
    return local_0 != null; })()" vb="(() =&gt; {
    System.Collections.Generic.List&lt;whiteMath.General.ListSegment&lt;T&gt;&gt; local_0 = result;
    return local_0 &lt;&gt; Nothing; })()">(() =&gt; {
    {
        System.Collections.Generic.List&lt;whiteMath.General.ListSegment&lt;T&gt;&gt; local_0 = result;
    }
    return local_0 != null; })()</ensures>
      <ensures csharp="Sum&lt;whiteMath.General.ListSegment&lt;T&gt;&gt;(local_0, (whiteMath.General.ListSegment&lt;T&gt; x) =&gt; x.Count) == list.Count" vb="Sum(local_0, (x As whiteMath.General.ListSegment(Of T)) =&gt; x.Count) = list.Count">System.Linq.Enumerable.Sum&lt;whiteMath.General.ListSegment&lt;T&gt;&gt;(local_0, (whiteMath.General.ListSegment&lt;T&gt; x) =&gt; x.Count) == list.Count</ensures>
      <ensures csharp="(options != default(whiteMath.General.ListSegmentationExtensions.SegmentationOptions) || Last&lt;whiteMath.General.ListSegment&lt;T&gt;&gt;(local_0).Count &lt; segmentLength &amp;&amp; !(options == (whiteMath.General.ListSegmentationExtensions.SegmentationOptions)1 &amp;&amp; Last&lt;whiteMath.General.ListSegment&lt;T&gt;&gt;(local_0).Count &lt;= segmentLength)) != 0" vb="(options &lt;&gt; Nothing OrElse Last(local_0).Count &lt; segmentLength AndAlso Not (options = ((whiteMath.General.ListSegmentationExtensions.SegmentationOptions)1) AndAlso Last(local_0).Count &lt;= segmentLength)) &lt;&gt; 0">(options != default(whiteMath.General.ListSegmentationExtensions.SegmentationOptions) || System.Linq.Enumerable.Last&lt;whiteMath.General.ListSegment&lt;T&gt;&gt;(local_0).Count &lt; segmentLength &amp;&amp; !(options == (whiteMath.General.ListSegmentationExtensions.SegmentationOptions)1 &amp;&amp; System.Linq.Enumerable.Last&lt;whiteMath.General.ListSegment&lt;T&gt;&gt;(local_0).Count &lt;= segmentLength)) != 0</ensures>
    </member>
    <member name="T:whiteMath.General.ListSegmentationExtensions.SegmentationOptions">
      <summary>
            This enum contains options to specify when covering an <c>IList&lt;T&gt;</c> into a sequence of 
            <c>ListSegment</c>'s and the length of the source list does not contain a whole number of desired lengths. 
            </summary>
    </member>
    <member name="F:whiteMath.General.ListSegmentationExtensions.SegmentationOptions.BiggerLastSegment">
      <summary>
            When using this option, in case of presence of the 'tail' length,
            the last segment will have length bigger than the desired.
            The overall number of segments produced will be floor(list.length / desiredLength).
            </summary>
    </member>
    <member name="F:whiteMath.General.ListSegmentationExtensions.SegmentationOptions.SmallerLastSegment">
      <summary>
            When using this option, in case of presence of the 'tail' length,
            the last segment will have length smaller than the desired.
            The overall number of intervals produced will be ceil(list.length / desiredLength).
            </summary>
    </member>
    <member name="M:whiteMath.General.OddEvenListWrappers.getListOfOdds``1(System.Collections.Generic.IList{``0})">
      <summary>
            Gets the list wrapper 'containing' all the odd elements of the parent list.
            Provides continuous indexing of odd elements. Does not support any insertion/removal operations.
            </summary>
      <typeparam name="T">The type of elements in the list</typeparam>
      <param name="obj">The parent list to be wrapped</param>
      <returns>The list wrapper containing all the odd elements of the parent list</returns>
    </member>
    <member name="M:whiteMath.General.OddEvenListWrappers.getListOfEvens``1(System.Collections.Generic.IList{``0})">
      <summary>
            Gets the list wrapper 'containing' all the even elements of the parent list.
            Provides continuous indexing of even elements. Does not support any insertion/removal operations.
            </summary>
      <typeparam name="T">The type of elements in the list</typeparam>
      <param name="obj">The parent list to be wrapped</param>
      <returns>The list wrapper containing all the odd elements of the parent list</returns>
    </member>
    <member name="T:whiteMath.General.OddEvenListWrappers.HalfList`1">
      <summary>
            The class providing the basic interface for EvenList and OddList implementers.
            </summary>
      <typeparam name="T" />
    </member>
    <member name="T:whiteMath.General.ReverseList`1">
      <summary>
            Creates the wrapper to access the elements of some particular list, but in reverse order.
            e.g. accessing element number [i] in the reverse list is exactly the same as accessing element number[parent.Count - i - 1] in the parent list.
            e.g. adding to the end of a reverse list is equivalent to adding to the beginning of the parent list.
            </summary>
      <typeparam name="T">The type of elements in the list.</typeparam>
    </member>
    <member name="M:whiteMath.General.ReverseList`1._ic(System.Int32)">
      <summary>
            Index conversion.
            </summary>
    </member>
    <member name="M:whiteMath.General.ListShufflingExtensions.ShuffleQuick``1(System.Collections.Generic.IList{``0})">
      <summary>
            Performs a quick, linear-complexity random shuffling of the list.
            The quality of shuffling is medium.
            Uses a standard system-provided integer random number generator.
            </summary>
      <typeparam name="T">The type of elements in the list.</typeparam>
      <param name="list">The calling list object.</param>
      <requires description="list" exception="T:System.ArgumentNullException" csharp="list != null" vb="list &lt;&gt; Nothing">list != null</requires>
      <exception cref="T:System.ArgumentNullException">list == null</exception>
    </member>
    <member name="M:whiteMath.General.ListShufflingExtensions.ShuffleQuick``1(System.Collections.Generic.IList{``0},whiteMath.Randoms.IRandomBounded{System.Int32})">
      <summary>
            Performs a quick, linear-complexity random shuffling of the list.
            The quality of shuffling is medium.
            Makes use of a user-provided integer random number generator.
            </summary>
      <typeparam name="T">The type of elements in the list.</typeparam>
      <param name="list">The calling list object.</param>
      <param name="randomGenerator">A user-provided integer random number generator.</param>
      <requires description="list" exception="T:System.ArgumentNullException" csharp="list != null" vb="list &lt;&gt; Nothing">list != null</requires>
      <exception cref="T:System.ArgumentNullException">list == null</exception>
      <requires description="randomGenerator" exception="T:System.ArgumentNullException" csharp="randomGenerator != null" vb="randomGenerator &lt;&gt; Nothing">randomGenerator != null</requires>
      <exception cref="T:System.ArgumentNullException">randomGenerator == null</exception>
    </member>
    <member name="M:whiteMath.General.ListShufflingExtensions.Shuffle``1(System.Collections.Generic.IList{``0})">
      <summary>
            Performs a high-quality random shuffling of the list.
            </summary>
      <typeparam name="T">The type of elements in the list.</typeparam>
      <param name="list">The calling list object.</param>
      <requires description="list" exception="T:System.ArgumentNullException" csharp="list != null" vb="list &lt;&gt; Nothing">list != null</requires>
      <exception cref="T:System.ArgumentNullException">list == null</exception>
    </member>
    <member name="M:whiteMath.General.ListShufflingExtensions.Shuffle``2(System.Collections.Generic.IList{``0},whiteMath.Randoms.IRandomFloatingPoint{``1},System.Collections.Generic.IComparer{``1})">
      <summary>
            Performs a high-quality random shuffling of the list.
            Uses a user-provided random number generator, which
            </summary>
      <typeparam name="T">The type of elements in the list.</typeparam>
      <typeparam name="N">The type of numbers generated by the random numbers generator.</typeparam>
      <param name="list">The calling list object.</param>
      <param name="generator">A floating-point random number generator for the <typeparamref name="N" /> type.</param>
      <param name="numericComparer">An optional numeric comparer for <typeparamref name="N" /> type. If <c>null</c>, a standard comparer will be used (if exists, otherwise, an exception will be thrown).</param>
      <requires description="list" exception="T:System.ArgumentNullException" csharp="list != null" vb="list &lt;&gt; Nothing">list != null</requires>
      <exception cref="T:System.ArgumentNullException">list == null</exception>
      <requires description="generator" exception="T:System.ArgumentNullException" csharp="generator != null" vb="generator &lt;&gt; Nothing">generator != null</requires>
      <exception cref="T:System.ArgumentNullException">generator == null</exception>
    </member>
    <member name="T:whiteMath.General.ServiceMethods">
      <summary>
            Provides different service methods, e.g. copying between the lists.
            </summary>
    </member>
    <member name="M:whiteMath.General.ServiceMethods.GetNodes``1(System.Collections.Generic.LinkedList{``0})">
      <summary>
            Returns the array of linked list nodes, starting with the first and ending with the last.
            Takes O(N) time.
            
            Warning! The array may go to obsolete/inconsistent state, stopping to represent
            the full collection of linked list nodes in their supposed order, if
            the list object is changed after or during getting the nodes list. (e.g. nodes are reordered, added, removed etc.)
            
            Consider using IsObsolete() with checkOrder parameter equal to true for such an array, if you are in doubt.
            </summary>
      <typeparam name="T">The type of elements stored in the list.</typeparam>
      <param name="list">The calling linked list object.</param>
      <returns>The array of linked list nodes.</returns>
    </member>
    <member name="M:whiteMath.General.ServiceMethods.IsObsolete``1(System.Collections.Generic.IList{System.Collections.Generic.LinkedListNode{``0}},System.Collections.Generic.LinkedList{``0},System.Boolean)">
      <summary>
            Checks whether the linked list's nodes list
            that is supposed to represent all of the linked list's nodes
            is in obsolete state:
            
            1) Either does not represent all of the list's nodes.
            2) Either contains nodes than aren't in the list.
            3) Or not every next node in the array is the result of Next() method of the previous node - if flag <paramref name="checkOrder" /> is true.
            </summary>
      <typeparam name="T">The type of values stored in the nodes.</typeparam>
      <param name="nodesList">The list of linked list nodes supposed to represent all the list nodes (if <paramref name="checkOrder" /> is true, the method also checks if the order of nodes in the array is the same as they their order within the list).</param>
      <returns>The boolean flag equal to true if the nodes array is obsolete, false otherwise.</returns>
    </member>
    <member name="M:whiteMath.General.ServiceMethods.Reorder_As_In_NodeList``1(System.Collections.Generic.LinkedList{``0},System.Collections.Generic.IList{System.Collections.Generic.LinkedListNode{``0}})">
      <summary>
            Reorders the nodes within the list so that their order is
            the same as nodes order within the nodes list object passed.
            
            Requirement: the nodes list passed should contain unique nodes which are all the nodes of the linked list, not less and not more;
            This is automatically true if the nodes list passes the <see cref="M:whiteMath.General.ServiceMethods.IsObsolete``1(System.Collections.Generic.IList{System.Collections.Generic.LinkedListNode{``0}},System.Collections.Generic.LinkedList{``0},System.Boolean)" /> test with <c>checkOrder</c> set to false.
            </summary>
      <typeparam name="T">The type of values stored in the linked list.</typeparam>
      <param name="list">The calling linked list object to be reordered.</param>
      <param name="nodesList">A nodes list containing unrepeatedly all the nodes of the linked list, and nothing more.</param>
    </member>
    <member name="M:whiteMath.General.ServiceMethods.ExchangeNodes``1(System.Collections.Generic.LinkedList{``0},System.Collections.Generic.LinkedListNode{``0},System.Collections.Generic.LinkedListNode{``0})">
      <summary>
            Exchanges the positions the two linked list nodes.
            </summary>
      <typeparam name="T">The type of values stored in the linked list.</typeparam>
      <param name="list">The calling linked list object.</param>
      <param name="one">The first node to be exchanged.</param>
      <param name="two">The second node to be exchanged.</param>
    </member>
    <member name="M:whiteMath.General.ServiceMethods.Copy``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0})">
      <summary>
            Copies the entire source list to the destination list.
            </summary>
      <typeparam name="T">The type of the elements in the list.</typeparam>
      <param name="source">The source list.</param>
      <param name="destination">The destination list.</param>
    </member>
    <member name="M:whiteMath.General.ServiceMethods.Copy``1(System.Collections.Generic.IList{``0},System.Int32,System.Collections.Generic.IList{``0},System.Int32)">
      <summary>
            Copies the elements from the source list (starting from sourceIndex)
            to the destination list. The filling of the destination list is started
            from destinationIndex.
            </summary>
      <typeparam name="T" />
      <param name="source" />
      <param name="sourceIndex" />
      <param name="destination" />
      <param name="destinationIndex" />
    </member>
    <member name="M:whiteMath.General.ServiceMethods.Copy``1(System.Collections.Generic.IList{``0},System.Int32,System.Collections.Generic.IList{``0},System.Int32,System.Int32)">
      <summary>
            Copies the elements from the source list (starting from sourceIndex, overall 'length' elements are copied)
            to the destination list. The filling of the destination list is started
            from destinationIndex.
            </summary>
      <typeparam name="T" />
      <param name="source" />
      <param name="sourceIndex" />
      <param name="destination" />
      <param name="destinationIndex" />
      <param name="length" />
    </member>
    <member name="M:whiteMath.General.ServiceMethods.Swap``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32)">
      <summary>
            Performs the swapping of two list elements with specified indices.
            </summary>
      <typeparam name="T">The type of elements in the list.</typeparam>
      <param name="list">The list object reference.</param>
      <param name="index1">The index of the first element to be swapped.</param>
      <param name="index2">The index of the second element to be swapped.</param>
    </member>
    <member name="M:whiteMath.General.ServiceMethods.Randomize(System.Collections.Generic.IList{System.Int32},System.Int32)">
      <summary>
            Randomizes the long integer digits array.
            </summary>
      <param name="arr">The calling array object.</param>
      <param name="BASE">The base of the digits in the long integer number.</param>
    </member>
    <member name="M:whiteMath.General.ServiceMethods.Randomize(System.Collections.Generic.IList{System.Int32},System.Int32,System.Int32)">
      <summary>
            Randomizes the integer list.
            The numbers being filled vary from minimum inclusive bound to the maximum exclusive bound.
            </summary>
      <param name="arr">The calling array object.</param>
      <param name="minInclusive">The lower inclusive bound of elements' value.</param>
      <param name="maxExclusive">The upper exclusive bound of elements' value.</param>
    </member>
    <member name="M:whiteMath.General.ServiceMethods.WhiteBinarySearch``1(System.Collections.Generic.IList{``0},``0,System.Collections.Generic.IComparer{``0})">
      <summary>
            Searches an entire sorted sequence of objects
            for a specific an <c>IComparer&lt;<typeparamref name="T" />&gt;</c> instance. 
            </summary>
      <typeparam name="T">The type of the element to search for.</typeparam>
      <param name="list">The list that is sorted ascending according to the <paramref name="comparer" /></param>
      <param name="key">The element to search for.</param>
      <param name="comparer">An optional <c>IComparer</c> for <c><typeparamref name="T" /></c> objects. If <c>null</c>, a default comparer will be used (or an exception will be thrown if one doesn't exist).</param>
      <returns>
            The index of the specified <paramref name="key" /> 
            in the specified <paramref name="list" />, if <paramref name="key" /> is found. 
            
            If value is not found and value is less than one or more elements in <paramref name="list" />, 
            a negative number which is the bitwise complement of the 
            index of the first element that is larger than value. 
            
            If value is not found and value is greater than any of the elements in <paramref name="list" />, 
            a negative number which is the bitwise complement of (the index of the last element plus 1). 
            </returns>
      <requires description="list" exception="T:System.ArgumentNullException" csharp="list != null" vb="list &lt;&gt; Nothing">list != null</requires>
      <exception cref="T:System.ArgumentNullException">list == null</exception>
    </member>
    <member name="M:whiteMath.General.ServiceMethods.WhiteBinarySearch``2(System.Collections.Generic.IList{``1},System.Func{``1,``0},``0,System.Collections.Generic.IComparer{``0})">
      <summary>
            Searches an entire sorted sequence of <c><typeparamref name="M" /></c>-typed objects
            for a specific <c><typeparamref name="T" /></c>-typed element, using
            a <c><typeparamref name="M" />=&gt;<typeparamref name="T" /></c> projector function
            and an <c>IComparer&lt;<typeparamref name="T" />&gt;</c> instance. 
            </summary>
      <typeparam name="T">The type of the element to search for.</typeparam>
      <typeparam name="M">The type of elements in the list.</typeparam>
      <param name="list">The list that is sorted ascending according to the <paramref name="projector" /> function and the <paramref name="comparer" /></param>
      <param name="projector">A function that maps <c><typeparamref name="M" /></c> to <c><typeparamref name="T" /></c></param>
      <param name="key">The element to search for.</param>
      <param name="comparer">An optional <c>IComparer</c> for <c><typeparamref name="T" /></c> objects. If <c>null</c>, a default comparer will be used (or an exception will be thrown if one doesn't exist).</param>
      <returns>
            The index of the specified <paramref name="key" /> (as the result of <paramref name="projector" /> function applied) 
            in the specified <paramref name="list" />, if <paramref name="key" /> is found. 
            
            If value is not found and value is less than one or more elements in <paramref name="list" />, 
            a negative number which is the bitwise complement of the 
            index of the first element that is larger than value. 
            
            If value is not found and value is greater than any of the elements in <paramref name="list" />, 
            a negative number which is the bitwise complement of (the index of the last element plus 1). 
            </returns>
      <requires description="list" exception="T:System.ArgumentNullException" csharp="list != null" vb="list &lt;&gt; Nothing">list != null</requires>
      <exception cref="T:System.ArgumentNullException">list == null</exception>
    </member>
    <member name="M:whiteMath.General.ServiceMethods.CountSignificant(System.Collections.Generic.IList{System.Int32})">
      <summary>
            For long integers. Returns the amount of significant digits in the 
            digits array (excluding the leading zeroes).
            </summary>
      <param name="list">The long integer digits list.</param>
      <returns>The number of significant digits in the number.</returns>
    </member>
    <member name="M:whiteMath.General.ServiceMethods.CountSignificant``2(System.Collections.Generic.IList{whiteMath.Numeric{``0,``1}})">
      <summary>
            For polynoms. Returns the amount of significant coefficients in the
            coefficients array (excluding the leading zeroes).
            </summary>
      <typeparam name="T">The type of polynom coefficients.</typeparam>
      <typeparam name="C">The calculator for the coefficient type.</typeparam>
      <param name="list">The list of coefficients.</param>
      <returns>The number of significant coefficients of the polynom.</returns>
    </member>
    <member name="M:whiteMath.General.ServiceMethods.Cut(System.Collections.Generic.IList{System.Int32})">
      <summary>
            Used with long integers digit arrays. Cuts the incoming list
            so that it contains only significant digits.
            </summary>
      <param name="list">The incoming digits list.</param>
      <returns>The list without leading zeroes.</returns>
    </member>
    <member name="M:whiteMath.General.ServiceMethods.Cut(System.Collections.Generic.List{System.Int32})">
      <summary>
            Used with long integers digit arrays. Cuts the incoming list
            so that it contains only significant digits.
            </summary>
      <param name="list">The list of the digits.</param>
      <returns>The list without any leading zeroes.</returns>
    </member>
    <member name="M:whiteMath.General.ServiceMethods.CutInPlace(System.Collections.Generic.List{System.Int32})">
      <summary>
            Used with long integers digit arrays. Cut the incoming list
            so that it contains only significant digits.
            
            The cutting is performed in-place, without creation of new objects.
            </summary>
      <param name="list">The digits list to be cut.</param>
    </member>
    <member name="M:whiteMath.General.ServiceMethods.Cut``2(System.Collections.Generic.IList{whiteMath.Numeric{``0,``1}})">
      <summary>
            Used with long integers digit arrays. Cuts the incoming list
            so that it contains only significant digits.
            </summary>
      <param name="list">The incoming digits list.</param>
      <returns>The list without leading zeroes.</returns>
    </member>
    <member name="M:whiteMath.General.NativeMethods.QueryPerformanceCounter(System.Int64@)">
      <summary>
            Returns the current value of CPU performance counter in ticks.
            The value is written to the variable passed.
            </summary>
      <param name="x">The variable to store the query result.</param>
      <returns>Negative value if the call is unsuccessfull, and a positive value in ticks otherwise.</returns>
    </member>
    <member name="M:whiteMath.General.NativeMethods.QueryPerformanceFrequency(System.Int64@)">
      <summary>
            Return the current CPU frequency, in ticks per second.
            The value is written to the variable passed.
            </summary>
      <param name="x">The variable to store the query result.</param>
      <returns>Negative value if the call is unsuccessful, and a positive value otherwise.</returns>
    </member>
    <member name="M:whiteMath.General.OtherExtensions.AsRectangle(System.Drawing.RectangleF)">
      <summary>
            Transforms the <c>RectangleF</c> object into a <c>Rectangle</c> by rounding
            coordinates of its upper-left point and the size to nearby integer values.
            </summary>
      <param name="obj">A <c>RectangleF</c> object to transform.</param>
      <returns>A <c>Rectangle</c> object with rounded coordinates and size.</returns>
      <see cref="T:System.Drawing.Rectangle" />
    </member>
    <member name="M:whiteMath.General.OtherExtensions.GetLinkedListNodeComparer``1(System.Collections.Generic.IComparer{``0})">
      <summary>
            Creates a comparer for linked list nodes basing on the
            comparer for linked list node values.
            </summary>
      <typeparam name="T">The type of linked list node values.</typeparam>
      <param name="valueComparer">The comparer for linked list node values/</param>
      <returns>The comparer for linked list nodes basing on the comparer for linked list node values.</returns>
    </member>
    <member name="M:whiteMath.General.OtherExtensions.createKVPComparerOnKey``2(System.Collections.Generic.IComparer{``0})">
      <summary>
            Creates a KeyValuePair comparer on the basis of provided key comparer object.
            </summary>
      <typeparam name="TKey">The type of key objects.</typeparam>
      <typeparam name="TVal">The type of value objects.</typeparam>
      <param name="keyComparer">The comparer for the key type.</param>
      <returns>An IComparer for key-value pairs on the basis of provided key comparer object.</returns>
    </member>
    <member name="M:whiteMath.General.OtherExtensions.createKVPComparerOnValue``2(System.Collections.Generic.IComparer{``1})">
      <summary>
            Creates a KeyValuePair comparer on the basis of provided value comparer object.
            </summary>
      <typeparam name="TKey">The type of key objects.</typeparam>
      <typeparam name="TVal">The type of value objects.</typeparam>
      <param name="valueComparer">The comparer for the value type.</param>
      <returns>An IComparer for key-value pairs on the basis of provided value comparer object.</returns>
    </member>
    <member name="M:whiteMath.General.OtherExtensions.GetReverseComparer``1(System.Collections.Generic.IComparer{``0})">
      <summary>
            Returns the reverse comparer for an IComparer() object.
            For example, each time the incoming comparer would tell 
            that object A is 'more' than object B (returns positive value),
            this comparer will tell the opposite and return the same absolute value, but with negative sign.
            </summary>
      <typeparam name="T">The type of comparable objects.</typeparam>
      <param name="comparer">The IComparer(<typeparamref name="T" />) object used to compare objects of type <typeparamref name="T" />.</param>
      <returns>The reverse comparer for the IComparer(<typeparamref name="T" />) object passed.</returns>
    </member>
    <member name="M:whiteMath.General.OtherExtensions.CreateComparer``1(System.Comparison{``0})">
      <summary>
            Creates the IComparer<typeparamref name="T" /> object from the calling Comparison(<typeparamref name="T" />) object.
            </summary>
      <typeparam name="T">The type of comparable values.</typeparam>
      <param name="comparison">The comparison delegate comparing values of type <typeparamref name="T" />.</param>
      <returns>The IComparer(<typeparamref name="T" />) object doing the same as the comparison object passed.</returns>
    </member>
    <member name="M:whiteMath.General.OtherExtensions.CharacterCount(System.String,System.Char)">
      <summary>
            Returns the overall number of a particular char occurences in 
            the calling string object.
            </summary>
      <param name="obj">The calling string object for which the count is performed.</param>
      <param name="value">The char value to count.</param>
      <returns>The overall number of passed char value occurences in the string.</returns>
    </member>
    <member name="M:whiteMath.General.OtherExtensions.SubstringToIndex(System.String,System.Int32,System.Int32)">
      <summary>
            Returns the substring of a calling string object starting with
            startIndex and ending with (exclusive) endIndex.
            </summary>
      <param name="obj">The calling string object to receive substring from.</param>
      <param name="startIndex">The inclusive starting index in the original string.</param>
      <param name="endIndex">The exclusive ending index in the original string.</param>
      <returns />
    </member>
    <member name="T:whiteMath.General.OtherExtensions._LLNComparer`1">
      <summary>
            Класс, который создает компаратор для узлов связного списка
            на основе компаратора для значений этих узлов.
            </summary>
    </member>
    <member name="T:whiteMath.General.OtherExtensions._KVPComparerKey`2">
      <summary>
            Класс, который создает компаратор пар ключ-значение
            на основе компаратора ключей.
            </summary>
    </member>
    <member name="T:whiteMath.General.OtherExtensions._KVPComparerValue`2">
      <summary>
            Класс, который создает компаратор пар ключ-значение
            на основе компаратора значений.
            </summary>
    </member>
    <member name="T:whiteMath.General.OtherExtensions._ReverseComparer`1">
      <summary>
            Класс, создающий обратный компаратор на основе прямого компаратора.
            </summary>
    </member>
    <member name="T:whiteMath.General.OtherExtensions.ComparisonComparer`1">
      <summary>
            Class comparing two objects basing on the Comparison delegate.
            </summary>
      <typeparam name="T" />
    </member>
    <member name="M:whiteMath.Statistics.SequenceFilteringExtensions.filterSurgesByEpsilonDeviationFromValue``2(System.Collections.Generic.IEnumerable{``0},``0,``0,whiteMath.Statistics.DeviationType,System.Collections.Generic.ICollection{``0})">
      <summary>
            Filters the surges in a sequence whose absolute values deviate from the specified positive value by a 
            nonnegative value specified.
            </summary>
      <typeparam name="T">The type of elements in the incoming sequence.</typeparam>
      <typeparam name="C">The calculator for the sequence elements type.</typeparam>
      <param name="sequence">A calling sequence object.</param>
      <param name="centerValue">Some value. Sequence elements that deviate from this value by more than <paramref name="allowedEpsilon" /> will be filtered out.</param>
      <param name="allowedEpsilon">The allowed nonnegative value of deviation from <paramref name="centerValue" />.</param>
      <param name="deviationType">
            If deviation type is Downwards, values which are smaller than <paramref name="centerValue" /> 
            by <paramref name="allowedEpsilon" /> will be filtered.
            If deviation type is Upwards, values which are bigger than <paramref name="centerValue" /> 
            by <paramref name="allowedEpsilon" /> will be filtered.
            If deviation type is EitherSide, all values that differ from the <paramref name="centerValue" />
            by <paramref name="allowedEpsilon" /> will be filtered.
            </param>
      <param name="filteredValues">A reference to a collection to store the filtered values. May be null.</param>
      <returns>The list containing all incoming values except for the filtered ones.</returns>
    </member>
    <member name="M:whiteMath.Statistics.SequenceFilteringExtensions.filterSurgesByAbsoluteFactorDeviationFromValue``2(System.Collections.Generic.IEnumerable{``0},``0,System.Double,whiteMath.Statistics.DeviationType,System.Collections.Generic.ICollection{``0})">
      <summary>
            Filters the surges in a sequence whose absolute values deviate from the specified positive value by a 
            positive factor specified.
            </summary>
      <typeparam name="T">The type of elements in the incoming sequence.</typeparam>
      <typeparam name="C">The calculator for the sequence elements type.</typeparam>
      <param name="sequence">A calling sequence object.</param>
      <param name="centerValue">A nonnegative value. Sequence elements that deviate from this value by more than <paramref name="allowedDeviationFactor" /> will be filtered out.</param>
      <param name="allowedDeviationFactor">The allowed factor of absolute deviation.</param>
      <param name="deviationType">
            If deviation type is Downwards, values which are smaller than <paramref name="centerValue" /> 
            by a factor of <paramref name="allowedDeviationFactor" /> will be filtered.
            If deviation type is Upwards, values which are bigger than <paramref name="centerValue" /> 
            by a factor of <paramref name="allowedDeviationFactor" /> will be filtered.
            If deviation type is EitherSide, all values that differ from the <paramref name="centerValue" />
            by a factor of <paramref name="allowedDeviationFactor" /> will be filtered.
            </param>
      <param name="filteredValues">A reference to a collection to store the filtered values. May be null.</param>
      <returns>The list containing all incoming values except for the filtered ones.</returns>
    </member>
    <member name="M:whiteMath.Statistics.SequenceSurgesAddingExtensions.addAbsoluteSurgesFromSymmetricDistribution``2(System.Collections.Generic.IEnumerable{``0},whiteMath.Randoms.IRandomUnbounded{``0},whiteMath.Statistics.DeviationType)">
      <summary>
            Adds absolute surges from a symmetric distribution random generator to each value of a numeric sequence and returns the
            noisy sequence in the form of a list.
            </summary>
      <typeparam name="T">The type of elements in the numeric sequence.</typeparam>
      <typeparam name="C">The calculator for the <typeparamref name="T" /> type.</typeparam>
      <param name="sequence">The calling numeric sequence object.</param>
      <param name="symmetricDistributionGenerator">A random generator providing values of some symmetric distribution.</param>
      <param name="deviationType">Which deviations (positive, negative or both) should be added to the sequence.</param>
      <returns>The list containing values from the incoming sequence by preserving the order, noised by absolute values from symmetric distribution generator.</returns>
    </member>
    <member name="M:whiteMath.Statistics.SequenceSurgesAddingExtensions.addRelativeSurgesFromSymmetricDistribution``2(System.Collections.Generic.IEnumerable{``0},whiteMath.Randoms.IRandomUnbounded{``0},whiteMath.Statistics.DeviationType)">
      <summary>
            Adds relative (factor) surges from a symmetric distribution random generator to each value of a numeric sequence
            and returns the nosiy sequence in the form of a list.
            </summary>
      <typeparam name="T">The type of elements in the numeric sequence.</typeparam>
      <typeparam name="C">The calculator for the <typeparamref name="T" /> type.</typeparam>
      <param name="sequence">The calling numeric sequence object.</param>
      <param name="symmetricDistributionGenerator">A random generator providing values of some symmetric distribution.</param>
      <param name="deviationType">Which deviations (positive, negative or both) should be added to the sequence.</param>
      <returns />
    </member>
    <member name="M:whiteMath.Statistics.CLNRM.EstimateLeastSquaresCoefficients``2(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0})">
      <summary>
            TODO: write documentation
            </summary>
      <typeparam name="T" />
      <typeparam name="C" />
      <param name="xValues" />
      <param name="yValues" />
      <returns />
    </member>
    <member name="M:whiteMath.Statistics.CLNRM.EstimateLeastSquaresCoefficients``2(System.Collections.Generic.IList{whiteMath.General.Point{``0}})">
      <summary>
            TODO: write documentation
            </summary>
      <typeparam name="T" />
      <typeparam name="C" />
      <param name="points" />
      <returns />
    </member>
    <member name="M:whiteMath.Statistics.CLNRM.EstimateLeastSquaresCoefficients``2(whiteMath.Matrices.Matrix{``0,``1})">
      <summary>
            Estimates the least squares coefficients for the regression formula: Y = a + bX_1 + cX_2 + ... + dX_k 
            </summary>
      <typeparam name="T">The type of observation values and the regression coefficients.</typeparam>
      <typeparam name="C">The calculator for the observations' value type.</typeparam>
      <param name="observationRows">The matrix of observations having rows in the following format: X_11 | X_12 | ... | X_1K | Y_1</param>
      <returns>The vector of estimated least squares regression coefficients. Its first term is a free term, and all the following terms correspond to X_1, X_2 etc. up to X_k</returns>
    </member>
    <member name="M:whiteMath.Statistics.CLNRM.LeastSquares_RSS``2(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0})">
      <summary>
            TODO: write the documentation
            </summary>
      <typeparam name="T" />
      <typeparam name="C" />
      <param name="estimatedY" />
      <param name="realY" />
      <returns />
    </member>
    <member name="M:whiteMath.Statistics.CLNRM.LeastSquares_ESS``2(System.Collections.Generic.IList{``0},``0)">
      <summary>
            TODO: write the documentation
            </summary>
      <typeparam name="T" />
      <typeparam name="C" />
      <param name="estimatedY" />
      <param name="averageY" />
      <returns />
    </member>
    <member name="M:whiteMath.Statistics.CLNRM.LeastSquares_TSS``2(System.Collections.Generic.IList{``0},``0)">
      <summary>
            TODO: write the documentation
            </summary>
      <typeparam name="T" />
      <typeparam name="C" />
      <param name="realY" />
      <param name="averageY" />
      <returns />
    </member>
    <member name="M:whiteMath.Statistics.StatisticExtensionMethods.SampleAverage``2(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Calculates the sample average for a sequence of observations.
            </summary>
      <typeparam name="T">The type of observations' values.</typeparam>
      <typeparam name="C">A calculator for the <typeparamref name="T" /> type.</typeparam>
      <param name="values">The sequence of observations.</param>
      <returns>The sample average for the sequence of observations passed.</returns>
    </member>
    <member name="M:whiteMath.Statistics.StatisticExtensionMethods.SampleMedian``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})">
      <summary>
            Calculates the sample median value for a sequence of observations, that is,
            such a value that (approximately) 50% of all observations in the sequence are less than
            (or equal to) this value, and other 50% are bigger than (or equal to) it.
            
            Please note that if the number of observations is even (2k), the median
            returned may not be an element of the source sequence at all, 
            being calculated as an arithmetic average of the middle two adjacent
            observations in the sorted sequence (see the definition of sample median).
            </summary>
      <typeparam name="T">The type of observations' values.</typeparam>
      <typeparam name="C">A calculator for the <typeparamref name="T" /> type.</typeparam>
      <param name="values">The sequence of observations.</param>
      <param name="comparer">A comparer object used to sort the incoming sequence ascending.</param>
      <returns>The sample median for the sequence of observations passed.</returns>
      <requires description="values" exception="T:System.ArgumentNullException" csharp="values != null" vb="values &lt;&gt; Nothing">values != null</requires>
      <exception cref="T:System.ArgumentNullException">values == null</exception>
      <ensures description="The value returned does not satisfy the requirements for the median." csharp="Count&lt;T&gt;(Where&lt;T&gt;(values, (T x) =&gt; op_Implicit(x) &lt; op_Implicit(result))) == Count&lt;T&gt;(values) / 2" vb="Count(Where(values, (x As T) =&gt; operator x &lt; operator result )) = Count(values) / 2">System.Linq.Enumerable.Count&lt;T&gt;(System.Linq.Enumerable.Where&lt;T&gt;(values, (T x) =&gt; whiteMath.Numeric&lt;T, C&gt;.op_Implicit(x) &lt; whiteMath.Numeric&lt;T, C&gt;.op_Implicit(result))) == System.Linq.Enumerable.Count&lt;T&gt;(values) / 2</ensures>
    </member>
    <member name="M:whiteMath.Statistics.StatisticExtensionMethods.RunsTest_SeriesCount``2(System.Collections.Generic.IEnumerable{``0},``0)">
      <summary>
            Returns the runs test series count for a sequence of observations.
            The sample median for that sequence must first be calculated.
            </summary>
      <typeparam name="T">The type of observations' values.</typeparam>
      <typeparam name="C">The calculator for the <typeparamref name="T" /> type.</typeparam>
      <param name="values">The list of observations.</param>
      <param name="sampleMedian">The sample median of the observations' sequence.</param>
      <returns>The amount of series for the runs test.</returns>
    </member>
    <member name="M:whiteMath.Statistics.StatisticExtensionMethods.SampleUnbiasedVariance``2(System.Collections.Generic.IEnumerable{``0},``0)">
      <summary>
            Calculates the sample unbiased variation for a sequence of observations. 
            </summary>
      <typeparam name="T">The type of observations' values.</typeparam>
      <typeparam name="C">A calculator for the <typeparamref name="T" /> type.</typeparam>
      <param name="values">The sequence of observations.</param>
      <param name="sampleAverage">The sample average for the observations sequence.</param>
      <returns>The sample unbiased variation for the sequence of observations.</returns>
      <requires description="values" exception="T:System.ArgumentNullException" csharp="values != null" vb="values &lt;&gt; Nothing">values != null</requires>
      <exception cref="T:System.ArgumentNullException">values == null</exception>
      <ensures description="The variance should not be negative." csharp="op_Implicit(result) &gt;= _0" vb="operator result &gt;= _0 ">whiteMath.Numeric&lt;T, C&gt;.op_Implicit(result) &gt;= whiteMath.Numeric&lt;T, C&gt;._0</ensures>
    </member>
    <member name="M:whiteMath.Statistics.StatisticExtensionMethods.SampleVariance``2(System.Collections.Generic.IEnumerable{``0},``0)">
      <summary>
            Calculates the sample biased variation for a sequence of observations. 
            </summary>
      <typeparam name="T">The type of observations' values.</typeparam>
      <typeparam name="C">A calculator for the <typeparamref name="T" /> type.</typeparam>
      <param name="values">The sequence of observations.</param>
      <param name="sampleAverage">The sample average for the observations sequence.</param>
      <returns>The sample biased variation for the sequence of observations.</returns>
      <requires description="values" exception="T:System.ArgumentNullException" csharp="values != null" vb="values &lt;&gt; Nothing">values != null</requires>
      <exception cref="T:System.ArgumentNullException">values == null</exception>
      <ensures description="The variance should not be negative." csharp="op_Implicit(result) &gt;= _0" vb="operator result &gt;= _0 ">whiteMath.Numeric&lt;T, C&gt;.op_Implicit(result) &gt;= whiteMath.Numeric&lt;T, C&gt;._0</ensures>
    </member>
    <member name="M:whiteMath.Statistics.StatisticExtensionMethods.__getWindowSequence``1(System.Collections.Generic.IList{``0},System.Int32,whiteMath.Statistics.StatisticExtensionMethods.WindowType,whiteMath.Statistics.StatisticExtensionMethods.TailValuesHandling,System.Int32)">
      <summary>
            Having passed the list of values,
            a non-negative window width, and
            a <see cref="T:whiteMath.Statistics.StatisticExtensionMethods.TailValuesHandling" /> flag,
            returns the appropriate segment of the source
            list containing the values falling in the window.
            </summary>
      <typeparam name="T">The type of elements in the sequence.</typeparam>
      <param name="values">The source sequence.</param>
      <param name="windowWidth">A non-negative window width.</param>
      <param name="currentIndex">
            The current index in the source sequence 
            pointing to the current element (for which the window sequence is calculated)</param>
      <param name="tailValuesHandling">A tail values handling flag, see <see cref="T:whiteMath.Statistics.StatisticExtensionMethods.TailValuesHandling" /></param>
      <param name="windowType">The window type, see <see cref="T:whiteMath.Statistics.StatisticExtensionMethods.WindowType" />.</param>
      <returns>
            A window sequence for the current element (referenced by <paramref name="currentIndex" />).
            The sequence can then be used for calculating the average or the median value.
            
            If the value is a tail value that should be excluded (see <see cref="F:whiteMath.Statistics.StatisticExtensionMethods.TailValuesHandling.DoNotInclude" />), 
            this method returns an empty list segment.
            </returns>
      <requires description="values" exception="T:System.ArgumentNullException" csharp="values != null" vb="values &lt;&gt; Nothing">values != null</requires>
      <exception cref="T:System.ArgumentNullException">values == null</exception>
      <requires description="The window width should be non-negative." exception="T:System.ArgumentOutOfRangeException" csharp="windowWidth &gt;= 0" vb="windowWidth &gt;= 0">windowWidth &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">windowWidth &lt; 0</exception>
      <requires description="The index is out of range" exception="T:System.IndexOutOfRangeException" csharp="currentIndex &gt;= 0 &amp;&amp; currentIndex &lt; values.Count" vb="currentIndex &gt;= 0 AndAlso currentIndex &lt; values.Count">currentIndex &gt;= 0 &amp;&amp; currentIndex &lt; values.Count</requires>
      <exception cref="T:System.IndexOutOfRangeException">currentIndex &lt; 0 || currentIndex &gt;= values.Count</exception>
    </member>
    <member name="M:whiteMath.Statistics.StatisticExtensionMethods.MovingStatistic``2(System.Collections.Generic.IList{``0},System.Int32,whiteMath.Statistics.StatisticExtensionMethods.WindowType,whiteMath.Statistics.StatisticExtensionMethods.TailValuesHandling,System.Func{System.Collections.Generic.IEnumerable{``0},``0})">
      <summary>
            Finds the moving statistic sequence from the sequence of values 
            using the specified non-negative window width and the statistic functor
            <paramref name="statistic" /> of type <c>Func&lt;IEnumerable&lt;T&gt;, T&gt;"</c>. 
            
            The tail values (such that there is not enough data in the window around them
            get handled using <see cref="T:whiteMath.Statistics.StatisticExtensionMethods.TailValuesHandling" /> flag passed).
            </summary>
      <typeparam name="T">The type of elements in the sequence.</typeparam>
      <typeparam name="C">The numeric calculator for the <typeparamref name="T" /> type.</typeparam>
      <param name="values">The sequence of values.</param>
      <param name="windowWidth">
            A non-negative window width applied to both sides of the current value.
            It means that, e.g. when the window width is 1, the window will consist
            of three values: the current value, one value to the left and one value to the right.
            </param>
      <param name="windowType">
            The type of the window for calculation of the average. 
            See <see cref="T:whiteMath.Statistics.StatisticExtensionMethods.WindowType" /></param>
      <param name="tailValuesHandling">
            A flag specifying how the tail values should be handled 
            (such that there is not enough data in the window around them).
            See <see cref="T:whiteMath.Statistics.StatisticExtensionMethods.TailValuesHandling" />.
            </param>
      <param name="statistic">
            A functor object taking an <c>IEnumerable&lt;T&gt;</c> sequence of observations
            and returning a statistic such as sample average, sample median, sample variance / standard
            deviation etc.
            </param>
      <returns>
            A sequence of statictics calculated in the window
            around each value from the source sequence.
            i.e. the i-th index in the result sequence means
            that the <paramref name="statistic" /> was calculated in the
            respective window around the i-th element of the source sequence.
            </returns>
      <requires description="values" exception="T:System.ArgumentNullException" csharp="values != null" vb="values &lt;&gt; Nothing">values != null</requires>
      <exception cref="T:System.ArgumentNullException">values == null</exception>
      <requires description="The window width should be non-negative" exception="T:System.ArgumentOutOfRangeException" csharp="windowWidth &gt;= 0" vb="windowWidth &gt;= 0">windowWidth &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">windowWidth &lt; 0</exception>
      <requires description="Symmetric tail values handling is only available for symmetric windows." exception="T:System.ArgumentException" csharp="tailValuesHandling != (whiteMath.Statistics.StatisticExtensionMethods.TailValuesHandling)1 || windowType == (whiteMath.Statistics.StatisticExtensionMethods.WindowType)0" vb="tailValuesHandling &lt;&gt; ((whiteMath.Statistics.StatisticExtensionMethods.TailValuesHandling)1) OrElse windowType = ((whiteMath.Statistics.StatisticExtensionMethods.WindowType)0)">tailValuesHandling != (whiteMath.Statistics.StatisticExtensionMethods.TailValuesHandling)1 || windowType == (whiteMath.Statistics.StatisticExtensionMethods.WindowType)0</requires>
      <exception cref="T:System.ArgumentException">
                tailValuesHandling == TailValuesHandling.UseSymmetricAvailableWindow &amp;&amp; windowType != WindowType.Symmetric</exception>
    </member>
    <member name="M:whiteMath.Statistics.StatisticExtensionMethods.MovingAverage``2(System.Collections.Generic.IList{``0},System.Int32,whiteMath.Statistics.StatisticExtensionMethods.WindowType,whiteMath.Statistics.StatisticExtensionMethods.TailValuesHandling)">
      <summary>
            Finds the moving average sequence from the sequence of values
            and the specified non-negative window width. The tail values
            (such that there is not enough data in the window around them
            get handled using <see cref="T:whiteMath.Statistics.StatisticExtensionMethods.TailValuesHandling" /> flag passed).
            </summary>
      <typeparam name="T">The type of elements in the sequence.</typeparam>
      <typeparam name="C">The numeric calculator for the <typeparamref name="T" /> type.</typeparam>
      <param name="values">The sequence of values.</param>
      <param name="windowWidth">
            A non-negative window width applied to both sides of the current value.
            It means that, e.g. when the window width is 1, the window will consist
            of three values: the current value, one value to the left and one value to the right.
            </param>
      <param name="windowType">
            The type of the window for calculation of the average. 
            See <see cref="T:whiteMath.Statistics.StatisticExtensionMethods.WindowType" /></param>
      <param name="tailValuesHandling">
            A flag specifying how the tail values should be handled 
            (such that there is not enough data in the window around them).
            See <see cref="T:whiteMath.Statistics.StatisticExtensionMethods.TailValuesHandling" />.
            </param>
      <returns>A sequence of moving averages calculated from the source sequence.</returns>
      <requires description="values" exception="T:System.ArgumentNullException" csharp="values != null" vb="values &lt;&gt; Nothing">values != null</requires>
      <exception cref="T:System.ArgumentNullException">values == null</exception>
      <requires description="The window width should be non-negative" exception="T:System.ArgumentOutOfRangeException" csharp="windowWidth &gt;= 0" vb="windowWidth &gt;= 0">windowWidth &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">windowWidth &lt; 0</exception>
      <requires description="Symmetric tail values handling is only available for symmetric windows." exception="T:System.ArgumentException" csharp="tailValuesHandling != (whiteMath.Statistics.StatisticExtensionMethods.TailValuesHandling)1 || windowType == (whiteMath.Statistics.StatisticExtensionMethods.WindowType)0" vb="tailValuesHandling &lt;&gt; ((whiteMath.Statistics.StatisticExtensionMethods.TailValuesHandling)1) OrElse windowType = ((whiteMath.Statistics.StatisticExtensionMethods.WindowType)0)">tailValuesHandling != (whiteMath.Statistics.StatisticExtensionMethods.TailValuesHandling)1 || windowType == (whiteMath.Statistics.StatisticExtensionMethods.WindowType)0</requires>
      <exception cref="T:System.ArgumentException">
                tailValuesHandling == TailValuesHandling.UseSymmetricAvailableWindow &amp;&amp; windowType != WindowType.Symmetric</exception>
    </member>
    <member name="M:whiteMath.Statistics.StatisticExtensionMethods.MovingMedian``2(System.Collections.Generic.IList{``0},System.Int32,whiteMath.Statistics.StatisticExtensionMethods.WindowType,whiteMath.Statistics.StatisticExtensionMethods.TailValuesHandling)">
      <summary>
            Finds the moving median sequence from the sequence of values
            and the specified non-negative window width. The tail values
            (such that there is not enough data in the window around them
            get handled using <see cref="T:whiteMath.Statistics.StatisticExtensionMethods.TailValuesHandling" /> flag passed).
            </summary>
      <typeparam name="T">The type of elements in the sequence.</typeparam>
      <typeparam name="C">The numeric calculator for the <typeparamref name="T" /> type.</typeparam>
      <param name="values">The sequence of values.</param>
      <param name="windowWidth">
            A non-negative window width applied to both sides of the current value.
            It means that, e.g. when the window width is 1, the window will consist
            of three values: the current value, one value to the left and one value to the right.
            </param>
      <param name="windowType">
            The type of the window for calculation of the median. 
            See <see cref="T:whiteMath.Statistics.StatisticExtensionMethods.WindowType" /></param>
      <param name="tailValuesHandling">
            A flag specifying how the tail values should be handled 
            (such that there is not enough data in the window around them).
            See <see cref="T:whiteMath.Statistics.StatisticExtensionMethods.TailValuesHandling" />.
            </param>
      <returns>A sequence of moving medians calculated from the source sequence.</returns>
      <requires description="values" exception="T:System.ArgumentNullException" csharp="values != null" vb="values &lt;&gt; Nothing">values != null</requires>
      <exception cref="T:System.ArgumentNullException">values == null</exception>
      <requires description="The window width should be non-negative" exception="T:System.ArgumentOutOfRangeException" csharp="windowWidth &gt;= 0" vb="windowWidth &gt;= 0">windowWidth &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">windowWidth &lt; 0</exception>
      <requires description="Symmetric tail values handling is only available for symmetric windows." exception="T:System.ArgumentException" csharp="tailValuesHandling != (whiteMath.Statistics.StatisticExtensionMethods.TailValuesHandling)1 || windowType == (whiteMath.Statistics.StatisticExtensionMethods.WindowType)0" vb="tailValuesHandling &lt;&gt; ((whiteMath.Statistics.StatisticExtensionMethods.TailValuesHandling)1) OrElse windowType = ((whiteMath.Statistics.StatisticExtensionMethods.WindowType)0)">tailValuesHandling != (whiteMath.Statistics.StatisticExtensionMethods.TailValuesHandling)1 || windowType == (whiteMath.Statistics.StatisticExtensionMethods.WindowType)0</requires>
      <exception cref="T:System.ArgumentException">
                tailValuesHandling == TailValuesHandling.UseSymmetricAvailableWindow &amp;&amp; windowType != WindowType.Symmetric</exception>
    </member>
    <member name="T:whiteMath.Statistics.StatisticExtensionMethods.WindowType">
      <summary>
            Specifies the type of the 
            window in calculation of the moving
            statistics. 
            </summary>
    </member>
    <member name="F:whiteMath.Statistics.StatisticExtensionMethods.WindowType.Symmetric">
      <summary>
            A symmetric window includes
            values both to the left and to the right
            of the current value.
            
            Window width = 2
            Array:
            1 2 3 4 5
            
            A symmetric window for 3 will include 1, 2, 3, 4 and 5.
            </summary>
    </member>
    <member name="F:whiteMath.Statistics.StatisticExtensionMethods.WindowType.Forward">
      <summary>
            A forward window only includes
            values to the right of the current
            value.
            
            Window width = 2
            Array:
            1 2 3 4 5
            
            A forward window for 3 will include 3, 4 and 5.
            </summary>
    </member>
    <member name="F:whiteMath.Statistics.StatisticExtensionMethods.WindowType.Backward">
      <summary>
            A backward window only includes
            values to the left of the current value.
            
            Window width = 2
            Array:
            1 2 3 4 5
            
            A backward window for 3 will include 1, 2 and 3.
            </summary>
    </member>
    <member name="T:whiteMath.Statistics.StatisticExtensionMethods.TailValuesHandling">
      <summary>
            Specifies the method of handling the tail
            values during the calculation of moving averages
            and moving medians.
            
            A tail value is such a value that does not
            have enough values in the specified window interval
            (e.g. the first and the second value of the array 
            when the window width is 2):
            
            EXAMPLE:
            Symmetric (centered) moving average.
            
            Window width = 2
            Array:
            1 2 3 4 5 6
            Tail flags:
            T T - - T T
            </summary>
    </member>
    <member name="F:whiteMath.Statistics.StatisticExtensionMethods.TailValuesHandling.UseAllAvailableWindow">
      <summary>
            This method will use any available 
            window for averaging / median finding,
            even if it means that the window
            becomes non-symmetric.
            
            Symmetric moving average:
            
            Window width = 2
            Array:
            1 2 3 4 5 6
            T T - - T T
            
            For 1, the window will include 1, 2 and 3 (since the two values to the left of 1 are not available).
            For 2, the window will include 1, 2, 3 and 4 (since only one of the two values to the left of 2 is available).
            For 3, the window will include 1, 2, 3, 4 and 5 (all the values in the symmetric window are available).
            ...
            
            Result array:
            2 2.5 3 4 4.5 5
            </summary>
    </member>
    <member name="F:whiteMath.Statistics.StatisticExtensionMethods.TailValuesHandling.UseSymmetricAvailableWindow">
      <summary>
            This flag only works for symmetric moving statistics.
            
            This method will force the window to be centered (symmetric),
            even if it means that the window width will be decreased.
            
            Symmetric moving average:
            
            Window width = 2
            Array
            1 2 3 4 5 6
            T T - - T T
            
            For 1, the window will only include 1 
            (since the two values to the left of 1 are not available, 
            values to the right cannot be used either under the requirement
            of symmetric window - thus, the window width decreases to 0 for this value)
            
            For 2, the window will include 1, 2 and 3
            (since only one of the two values to the left of 2 are available,
            only one value to the right can be used under the requirement
            of symmetric window - thus, the window width decreases to 1 for this value)
            
            For 3, the window will include all the necessary values.
            
            Result array:
            1 2 3 4 5 6
            </summary>
    </member>
    <member name="F:whiteMath.Statistics.StatisticExtensionMethods.TailValuesHandling.DoNotTouch">
      <summary>
            This flag leaves the tail values 
            as is and does not apply the window averaging
            to them.
            
            Backward window moving average:
            
            Window width = 2
            Array
            1 2 3 4 5
            T T - - -
            
            For 1, the value isn't touched, since there are no two values to the left of 1.
            For 2, the value isn't touched, since there is only one of two values to the left of 2.
            For 3, the value gets averaged between 1, 2 and 3.
            ...
            
            Result array:
            1 2 2 3 4
            </summary>
    </member>
    <member name="F:whiteMath.Statistics.StatisticExtensionMethods.TailValuesHandling.DoNotInclude">
      <summary>
            This flag forces the method to 
            exclude the tail values from the resulting array.
            
            Backward window moving average:
            
            Window width = 2
            Array
            1 2 3 4 5
            T T - - -
            
            For 1, the value gets excluded.
            For 2, the value gets excluded.
            For 3, the value gets averaged between 1, 2 and 3.
            ...
            
            Result array:
            2 3 4 
            </summary>
    </member>
    <member name="T:whiteMath.Time.NanoStopWatch">
      <summary>
            The class designed to accurately measure time intervals.
            </summary>
    </member>
    <member name="M:whiteMath.Time.NanoStopWatch.start">
      <summary>
            Starts the timer.
            </summary>
    </member>
    <member name="M:whiteMath.Time.NanoStopWatch.pause">
      <summary>
            Temporarily pauses the timer.
            If used frequently, precision can be lost significantly.
            </summary>
    </member>
    <member name="M:whiteMath.Time.NanoStopWatch.stop">
      <summary>
            Stops the timer so the result can be evaluated.
            </summary>
    </member>
    <member name="M:whiteMath.Time.NanoStopWatch.reset">
      <summary>
            Resets the timer in any condition to the all-zero state.
            </summary>
    </member>
    <member name="P:whiteMath.Time.NanoStopWatch.Finished">
      <summary>
            Returns the boolean value determining whether the timer has finished working.
            </summary>
    </member>
    <member name="P:whiteMath.Time.NanoStopWatch.Paused">
      <summary>
            Returns the boolean value determining whether the timer is currently paused, but not stopped.
            </summary>
    </member>
    <member name="T:whiteMath.Vector`2">
      <summary>
            The vector of numeric objects.
            TODO: write the documentation.
            </summary>
      <typeparam name="T">The type of numbers stored by the vector.</typeparam>
    </member>
    <member name="M:whiteMath.Vector`2.#ctor(whiteMath.Vector{`0,`1})">
      <summary>
            The copy constructor.
            Creates an independent clone of the vector object passed.
            </summary>
      <param name="copy" />
    </member>
    <member name="M:whiteMath.Vector`2.#ctor(System.Int32)">
      <summary>
            Creates a new vector filled up with zero numeric values.
            </summary>
      <param name="dimension" />
    </member>
    <member name="M:whiteMath.Vector`2.#ctor(System.Int32,`0)">
      <summary>
            Creates a new vector with elements all initialized equal to the value passed.
            </summary>
      <param name="dimension" />
      <param name="value" />
    </member>
    <member name="M:whiteMath.Vector`2.#ctor(`0[])">
      <summary>
            Private constructor used by helper methods.
            </summary>
      <param name="array" />
    </member>
    <member name="M:whiteMath.Vector`2.CreateWrapper(`0[])">
      <summary>
            Creates the vector as a wrapper for the array passed.
            (!) All changes to the vector will be reflected on the array, and vice versa.
            </summary>
      <param name="array" />
      <returns />
    </member>
    <member name="M:whiteMath.Vector`2.CreateIndependent(`0[])">
      <summary>
            Creates the vector using the shallow copy for the array passed.
            If the shallow array copy is logically deep, no changes to the vector
            will be reflected on the array, and vice versa.
            </summary>
      <param name="array" />
      <returns />
    </member>
    <member name="M:whiteMath.Vector`2.AsNumericArray">
      <summary>
            Unwraps the current vector to present it as a Numeric array.
            </summary>
    </member>
    <member name="M:whiteMath.Vector`2.ToString(System.String,System.String)">
      <summary>
            Returns the string representation of the current vector using 
            the specified format string for each of the vector elements.
            </summary>
      <param name="vectorElementsFormatter">The format string for vector elements</param>
      <param name="elementSeparator">The string that separates different vector elements, ex.: "; "</param>
      <returns />
    </member>
    <member name="M:whiteMath.Vector`2.ToString">
      <summary>
            Returns the string representation of the current vector using
            the default string format for each of the vector elements.
            </summary>
      <returns />
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:whiteMath.Vector`2.Length">
      <summary>
            Gets the length of the vector.
            </summary>
    </member>
    <member name="P:whiteMath.Vector`2.Item(System.Int32)">
      <summary>
            The indexer of the vector.
            </summary>
    </member>
    <member name="P:whiteMath.Vector`2.UnwrappedToSimpleArray">
      <summary>
            Unwraps the current vector to present it as a simple T array.
            All changes to the array object returned will be reflected on the vector,
            and vice versa.
            </summary>
      <returns />
    </member>
    <member name="M:whiteMath.Functions.LagrangePolynom`2.Clone">
      <ensures inheritedFrom="M:System.ICloneable.Clone" inheritedFromTypeName="ICloneable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:whiteMath.Functions.Polynom`2.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:whiteMath.FunctionStringSyntaxException.Message">
      <getter>
        <ensures inheritedFrom="M:System.Exception.get_Message" inheritedFromTypeName="Exception" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="M:whiteMath.Combinatorics.Permutator`1.System#Collections#IEnumerable#GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_CurrentIndex == -1" vb="result.get_CurrentIndex = -1">result.get_CurrentIndex == -1</ensures>
    </member>
    <member name="M:whiteMath.Combinatorics.Permutator`1.GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
    </member>
    <member name="M:whiteMath.Combinatorics.Permutator`1.System#Collections#Generic#IList{T}#Insert(System.Int32,`0)">
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &lt;= this.Count" vb="index &lt;= Me.Count">index &lt;= this.Count</requires>
    </member>
    <member name="M:whiteMath.Combinatorics.Permutator`1.System#Collections#Generic#IList{T}#RemoveAt(System.Int32)">
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList" csharp="index &lt; this.Count" vb="index &lt; Me.Count">index &lt; this.Count</requires>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList" csharp="this.Count == old(this.Count) - 1" vb="Me.Count = old(Me.Count) - 1">this.Count == old(this.Count) - 1</ensures>
    </member>
    <member name="M:whiteMath.Combinatorics.Permutator`1.System#Collections#Generic#ICollection{T}#Add(`0)">
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Add(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &gt;= old(this.Count)" vb="Me.Count &gt;= old(Me.Count)">this.Count &gt;= old(this.Count)</ensures>
    </member>
    <member name="M:whiteMath.Combinatorics.Permutator`1.System#Collections#Generic#ICollection{T}#Clear">
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Clear" inheritedFromTypeName="ICollection" csharp="this.Count == 0" vb="Me.Count = 0">this.Count == 0</ensures>
    </member>
    <member name="M:whiteMath.Combinatorics.Permutator`1.Contains(`0)">
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Contains(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt; 0" vb="result Implies Me.Count &gt; 0">!result || this.Count &gt; 0</ensures>
    </member>
    <member name="M:whiteMath.Combinatorics.Permutator`1.CopyTo(`0[],System.Int32)">
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="array != null" vb="array &lt;&gt; Nothing">array != null</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &gt;= 0" vb="arrayIndex &gt;= 0">arrayIndex &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &lt;= array.Length - this.Count" vb="arrayIndex &lt;= array.Length - Me.Count">arrayIndex &lt;= array.Length - this.Count</requires>
    </member>
    <member name="M:whiteMath.Combinatorics.Permutator`1.IndexOf(`0)">
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.IndexOf(`0)" inheritedFromTypeName="IList" csharp="result &gt;= -1" vb="result &gt;= -1">result &gt;= -1</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.IndexOf(`0)" inheritedFromTypeName="IList" csharp="result &lt; this.Count" vb="result &lt; Me.Count">result &lt; this.Count</ensures>
    </member>
    <member name="P:whiteMath.Combinatorics.Permutator`1.Count">
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.get_Count" inheritedFromTypeName="ICollection" csharp="result &gt;= 0" vb="result &gt;= 0">result &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:whiteMath.Graphers.GrapherGraphException.Message">
      <getter>
        <ensures inheritedFrom="M:System.Exception.get_Message" inheritedFromTypeName="Exception" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="M:whiteMath.Graphers.CoordinateTransformer`2.#ctor(`0,`0,`0,`0,System.Func{`0,System.Double},System.Drawing.RectangleF)">
      <requires description="xMin" exception="T:System.ArgumentNullException" csharp="(object)xMin != null" vb="((Object)xMin) &lt;&gt; Nothing">(object)xMin != null</requires>
      <exception cref="T:System.ArgumentNullException">xMin == null</exception>
      <requires description="xMax" exception="T:System.ArgumentNullException" csharp="(object)xMax != null" vb="((Object)xMax) &lt;&gt; Nothing">(object)xMax != null</requires>
      <exception cref="T:System.ArgumentNullException">xMax == null</exception>
      <requires description="yMin" exception="T:System.ArgumentNullException" csharp="(object)yMin != null" vb="((Object)yMin) &lt;&gt; Nothing">(object)yMin != null</requires>
      <exception cref="T:System.ArgumentNullException">yMin == null</exception>
      <requires description="yMax" exception="T:System.ArgumentNullException" csharp="(object)yMax != null" vb="((Object)yMax) &lt;&gt; Nothing">(object)yMax != null</requires>
      <exception cref="T:System.ArgumentNullException">yMax == null</exception>
      <requires description="toDouble" exception="T:System.ArgumentNullException" csharp="toDouble != null" vb="toDouble &lt;&gt; Nothing">toDouble != null</requires>
      <exception cref="T:System.ArgumentNullException">toDouble == null</exception>
    </member>
    <member name="M:whiteMath.Graphers.CoordinateTransformer`2.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:whiteMath.Graphers.HistoGraphingArgs.Clone">
      <ensures inheritedFrom="M:System.ICloneable.Clone" inheritedFromTypeName="ICloneable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:whiteMath.Graphers.DimensionTransformer`2.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:whiteMath.Graphers.GrapherSettingsException.Message">
      <getter>
        <ensures inheritedFrom="M:System.Exception.get_Message" inheritedFromTypeName="Exception" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:whiteMath.Graphers.GrapherActionImpossibleException.Message">
      <getter>
        <ensures inheritedFrom="M:System.Exception.get_Message" inheritedFromTypeName="Exception" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="M:whiteMath.Graphers.HistoGrapherBrushFactory.CreateValueDependentBrushes(whiteMath.Graphers.HistoGrapher,System.Double,System.Double,System.Drawing.Color,System.Drawing.Color)">
      <requires description="hg" exception="T:System.ArgumentNullException" csharp="(() =&gt; {
    {
        new whiteMath.Graphers.HistoGrapherBrushFactory.&lt;&gt;c__DisplayClass1().minColor = minColor;
    }
    return hg != null; })()" vb="(() =&gt; {
    New whiteMath.Graphers.HistoGrapherBrushFactory.&lt;&gt;c__DisplayClass1().minColor = minColor
    return hg &lt;&gt; Nothing; })()">(() =&gt; {
    {
        new whiteMath.Graphers.HistoGrapherBrushFactory.&lt;&gt;c__DisplayClass1().minColor = minColor;
    }
    return hg != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">hg == null</exception>
      <requires description="The minimum value should be less than the maximum value." exception="T:System.ArgumentException" csharp="minValue &lt; maxValue" vb="minValue &lt; maxValue">minValue &lt; maxValue</requires>
      <exception cref="T:System.ArgumentException">minValue &gt;= maxValue</exception>
      <requires description="HistoGrapher's values should not exceed the explicitly specified bounds of colour." exception="T:System.ArgumentException" csharp="hg.MinValue &gt;= minValue &amp;&amp; !!(hg.MaxValue &lt;= maxValue)" vb="hg.MinValue &gt;= minValue AndAlso Not !(hg.MaxValue &lt;= maxValue)">hg.MinValue &gt;= minValue &amp;&amp; !!(hg.MaxValue &lt;= maxValue)</requires>
      <exception cref="T:System.ArgumentException">hg.MinValue &lt; minValue || hg.MaxValue &gt; maxValue</exception>
    </member>
    <member name="M:whiteMath.Graphers.HistoGrapherBrushFactory.CreateValueDependentBrushes(whiteMath.Graphers.HistoGrapher,System.Double,System.Double,System.Func{System.Double,System.Drawing.Color})">
      <requires description="hg" exception="T:System.ArgumentNullException" csharp="(() =&gt; {
    {
        whiteMath.Graphers.HistoGrapherBrushFactory.&lt;&gt;c__DisplayClass4 local_0 = new whiteMath.Graphers.HistoGrapherBrushFactory.&lt;&gt;c__DisplayClass4();
        local_0.colorMapper = colorMapper;
    }
    return hg != null; })()" vb="(() =&gt; {
    whiteMath.Graphers.HistoGrapherBrushFactory.&lt;&gt;c__DisplayClass4 local_0 = New whiteMath.Graphers.HistoGrapherBrushFactory.&lt;&gt;c__DisplayClass4();
    local_0.colorMapper = colorMapper
    return hg &lt;&gt; Nothing; })()">(() =&gt; {
    {
        whiteMath.Graphers.HistoGrapherBrushFactory.&lt;&gt;c__DisplayClass4 local_0 = new whiteMath.Graphers.HistoGrapherBrushFactory.&lt;&gt;c__DisplayClass4();
        local_0.colorMapper = colorMapper;
    }
    return hg != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">hg == null</exception>
      <requires description="colorMapper" exception="T:System.ArgumentNullException" csharp="local_0.colorMapper != null" vb="local_0.colorMapper &lt;&gt; Nothing">local_0.colorMapper != null</requires>
      <exception cref="T:System.ArgumentNullException">colorMapper == null</exception>
      <requires description="The minimum value should be less than the maximum value." exception="T:System.ArgumentException" csharp="minValue &lt; maxValue" vb="minValue &lt; maxValue">minValue &lt; maxValue</requires>
      <exception cref="T:System.ArgumentException">minValue &gt;= maxValue</exception>
      <requires description="HistoGrapher's values should not exceed the explicitly specified bounds of colour." exception="T:System.ArgumentException" csharp="hg.MinValue &gt;= minValue &amp;&amp; !!(hg.MaxValue &lt;= maxValue)" vb="hg.MinValue &gt;= minValue AndAlso Not !(hg.MaxValue &lt;= maxValue)">hg.MinValue &gt;= minValue &amp;&amp; !!(hg.MaxValue &lt;= maxValue)</requires>
      <exception cref="T:System.ArgumentException">hg.MinValue &lt; minValue || hg.MaxValue &gt; maxValue</exception>
    </member>
    <member name="M:whiteMath.Graphers.HistoGrapherBrushFactory.CreateValueDependentBrushes(whiteMath.Graphers.HistoGrapher,System.Double,System.Double,System.Func{System.Double,System.Drawing.Brush})">
      <requires description="hg" exception="T:System.ArgumentNullException" csharp="hg != null" vb="hg &lt;&gt; Nothing">hg != null</requires>
      <exception cref="T:System.ArgumentNullException">hg == null</exception>
      <requires description="brushMapper" exception="T:System.ArgumentNullException" csharp="brushMapper != null" vb="brushMapper &lt;&gt; Nothing">brushMapper != null</requires>
      <exception cref="T:System.ArgumentNullException">brushMapper == null</exception>
      <requires description="The minimum value should be less than the maximum value." exception="T:System.ArgumentException" csharp="minValue &lt; maxValue" vb="minValue &lt; maxValue">minValue &lt; maxValue</requires>
      <exception cref="T:System.ArgumentException">minValue &gt;= maxValue</exception>
      <requires description="HistoGrapher's values should not exceed the explicitly specified bounds of colour." exception="T:System.ArgumentException" csharp="hg.MinValue &gt;= minValue &amp;&amp; !!(hg.MaxValue &lt;= maxValue)" vb="hg.MinValue &gt;= minValue AndAlso Not !(hg.MaxValue &lt;= maxValue)">hg.MinValue &gt;= minValue &amp;&amp; !!(hg.MaxValue &lt;= maxValue)</requires>
      <exception cref="T:System.ArgumentException">hg.MinValue &lt; minValue || hg.MaxValue &gt; maxValue</exception>
    </member>
    <member name="M:whiteMath.ArithmeticLong.Bases.B_Var.getBase">
      <ensures description="The base of number digits should be positive and more than 1." inheritedFrom="M:whiteMath.ArithmeticLong.IBase.getBase" inheritedFromTypeName="IBase" csharp="result &gt; 1" vb="result &gt; 1">result &gt; 1</ensures>
    </member>
    <member name="M:whiteMath.ArithmeticLong.Bases.B_100k.getBase">
      <ensures description="The base of number digits should be positive and more than 1." inheritedFrom="M:whiteMath.ArithmeticLong.IBase.getBase" inheritedFromTypeName="IBase" csharp="result &gt; 1" vb="result &gt; 1">result &gt; 1</ensures>
    </member>
    <member name="M:whiteMath.ArithmeticLong.Bases.B_10k.getBase">
      <ensures description="The base of number digits should be positive and more than 1." inheritedFrom="M:whiteMath.ArithmeticLong.IBase.getBase" inheritedFromTypeName="IBase" csharp="result &gt; 1" vb="result &gt; 1">result &gt; 1</ensures>
    </member>
    <member name="M:whiteMath.ArithmeticLong.Bases.B_1000.getBase">
      <ensures description="The base of number digits should be positive and more than 1." inheritedFrom="M:whiteMath.ArithmeticLong.IBase.getBase" inheritedFromTypeName="IBase" csharp="result &gt; 1" vb="result &gt; 1">result &gt; 1</ensures>
    </member>
    <member name="M:whiteMath.ArithmeticLong.Bases.B_100.getBase">
      <ensures description="The base of number digits should be positive and more than 1." inheritedFrom="M:whiteMath.ArithmeticLong.IBase.getBase" inheritedFromTypeName="IBase" csharp="result &gt; 1" vb="result &gt; 1">result &gt; 1</ensures>
    </member>
    <member name="M:whiteMath.ArithmeticLong.Bases.B_10.getBase">
      <ensures description="The base of number digits should be positive and more than 1." inheritedFrom="M:whiteMath.ArithmeticLong.IBase.getBase" inheritedFromTypeName="IBase" csharp="result &gt; 1" vb="result &gt; 1">result &gt; 1</ensures>
    </member>
    <member name="M:whiteMath.ArithmeticLong.Bases.B_256.getBase">
      <ensures description="The base of number digits should be positive and more than 1." inheritedFrom="M:whiteMath.ArithmeticLong.IBase.getBase" inheritedFromTypeName="IBase" csharp="result &gt; 1" vb="result &gt; 1">result &gt; 1</ensures>
    </member>
    <member name="M:whiteMath.ArithmeticLong.Bases.B_32768.getBase">
      <ensures description="The base of number digits should be positive and more than 1." inheritedFrom="M:whiteMath.ArithmeticLong.IBase.getBase" inheritedFromTypeName="IBase" csharp="result &gt; 1" vb="result &gt; 1">result &gt; 1</ensures>
    </member>
    <member name="M:whiteMath.ArithmeticLong.Bases.B_65536.getBase">
      <ensures description="The base of number digits should be positive and more than 1." inheritedFrom="M:whiteMath.ArithmeticLong.IBase.getBase" inheritedFromTypeName="IBase" csharp="result &gt; 1" vb="result &gt; 1">result &gt; 1</ensures>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.Helper.PowerIntegerModularSlow``1(whiteMath.ArithmeticLong.LongInt{``0},whiteMath.ArithmeticLong.LongInt{``0},whiteMath.ArithmeticLong.LongInt{``0})">
      <requires description="number" exception="T:System.ArgumentNullException" csharp="number != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null" vb="number &lt;&gt; ((whiteMath.ArithmeticLong.LongInt(Of B))Nothing) ">number != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">number == null</exception>
      <requires description="power" exception="T:System.ArgumentNullException" csharp="power != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null" vb="power &lt;&gt; ((whiteMath.ArithmeticLong.LongInt(Of B))Nothing) ">power != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">power == null</exception>
      <requires description="modulus" exception="T:System.ArgumentNullException" csharp="modulus != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null" vb="modulus &lt;&gt; ((whiteMath.ArithmeticLong.LongInt(Of B))Nothing) ">modulus != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">modulus == null</exception>
    </member>
    <member name="M:whiteMath.ArithmeticLong.LongInt`1.Helper_NTT_OLD.MultiplyNTT(whiteMath.ArithmeticLong.LongInt{`0},whiteMath.ArithmeticLong.LongInt{`0})">
      <requires description="one" exception="T:System.ArgumentNullException" csharp="one != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null" vb="one &lt;&gt; ((whiteMath.ArithmeticLong.LongInt(Of B))Nothing) ">one != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">one == null</exception>
      <requires description="two" exception="T:System.ArgumentNullException" csharp="two != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null" vb="two &lt;&gt; ((whiteMath.ArithmeticLong.LongInt(Of B))Nothing) ">two != (whiteMath.ArithmeticLong.LongInt&lt;B&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">two == null</exception>
    </member>
    <member name="P:whiteMath.FunctionActionExecutionException.Message">
      <getter>
        <ensures inheritedFrom="M:System.Exception.get_Message" inheritedFromTypeName="Exception" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:whiteMath.FunctionBadArgumentException.Message">
      <getter>
        <ensures inheritedFrom="M:System.Exception.get_Message" inheritedFromTypeName="Exception" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:whiteMath.FunctionActionSyntaxException.Message">
      <getter>
        <ensures inheritedFrom="M:System.Exception.get_Message" inheritedFromTypeName="Exception" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="M:whiteMath.Cryptography.OneTimePadBreaker.addCipherText(System.Byte[])">
      <requires description="cipherText" exception="T:System.ArgumentNullException" csharp="cipherText != null" vb="cipherText &lt;&gt; Nothing">cipherText != null</requires>
      <exception cref="T:System.ArgumentNullException">cipherText == null</exception>
      <requires description="The ciphertext should not be empty" exception="T:System.ArgumentException" csharp="cipherText.Length &gt; 0" vb="cipherText.Length &gt; 0">cipherText.Length &gt; 0</requires>
      <exception cref="T:System.ArgumentException">cipherText.Length &lt;= 0</exception>
    </member>
    <member name="M:whiteMath.Matrices.IndexPair.ToString">
      <ensures inheritedFrom="M:System.ValueType.ToString" inheritedFromTypeName="ValueType" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:whiteMath.Matrices.MatrixSingularityException.Message">
      <getter>
        <ensures inheritedFrom="M:System.ArgumentException.get_Message" inheritedFromTypeName="ArgumentException" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
        <ensures inheritedFrom="M:System.Exception.get_Message" inheritedFromTypeName="Exception" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:whiteMath.Matrices.MatrixSizeException.Message">
      <getter>
        <ensures inheritedFrom="M:System.ArgumentException.get_Message" inheritedFromTypeName="ArgumentException" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
        <ensures inheritedFrom="M:System.Exception.get_Message" inheritedFromTypeName="Exception" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="M:whiteMath.Complex.ToString">
      <ensures inheritedFrom="M:System.ValueType.ToString" inheritedFromTypeName="ValueType" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:whiteMath.FunctionActionUserThrownException.Message">
      <getter>
        <ensures inheritedFrom="M:System.Exception.get_Message" inheritedFromTypeName="Exception" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="M:whiteMath.Vector`2.Clone">
      <ensures inheritedFrom="M:System.ICloneable.Clone" inheritedFromTypeName="ICloneable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:whiteMath.Rational`2.Positive_Infinity.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:whiteMath.Rational`2.Negative_Infinity.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:whiteMath.Rational`2.NotANumber.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:whiteMath.BoundedInterval`2.ToString">
      <ensures inheritedFrom="M:System.ValueType.ToString" inheritedFromTypeName="ValueType" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:whiteMath.Randoms.RandomStandard.whiteMath#Randoms#IRandomBounded{System#Int32}#Next(System.Int32,System.Int32)">
      <requires csharp="min &lt; max" vb="min &lt; max">min &lt; max</requires>
    </member>
    <member name="M:whiteMath.Randoms.RandomStandard.whiteMath#Randoms#IRandomBounded{System#Int64}#Next(System.Int64,System.Int64)">
      <requires csharp="minValue &lt; maxValue" vb="minValue &lt; maxValue">minValue &lt; maxValue</requires>
    </member>
    <member name="M:whiteMath.Randoms.RandomStandard.whiteMath#Randoms#IRandomBounded{System#UInt64}#Next(System.UInt64,System.UInt64)">
      <requires csharp="min &lt; max" vb="min &lt; max">min &lt; max</requires>
    </member>
    <member name="M:whiteMath.General.DefaultList`1.Add(`0)">
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Add(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &gt;= old(this.Count)" vb="Me.Count &gt;= old(Me.Count)">this.Count &gt;= old(this.Count)</ensures>
    </member>
    <member name="M:whiteMath.General.DefaultList`1.Clear">
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Clear" inheritedFromTypeName="ICollection" csharp="this.Count == 0" vb="Me.Count = 0">this.Count == 0</ensures>
    </member>
    <member name="M:whiteMath.General.DefaultList`1.Contains(`0)">
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Contains(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt; 0" vb="result Implies Me.Count &gt; 0">!result || this.Count &gt; 0</ensures>
    </member>
    <member name="M:whiteMath.General.DefaultList`1.CopyTo(`0[],System.Int32)">
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="array != null" vb="array &lt;&gt; Nothing">array != null</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &gt;= 0" vb="arrayIndex &gt;= 0">arrayIndex &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &lt;= array.Length - this.Count" vb="arrayIndex &lt;= array.Length - Me.Count">arrayIndex &lt;= array.Length - this.Count</requires>
    </member>
    <member name="M:whiteMath.General.DefaultList`1.IndexOf(`0)">
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.IndexOf(`0)" inheritedFromTypeName="IList" csharp="result &gt;= -1" vb="result &gt;= -1">result &gt;= -1</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.IndexOf(`0)" inheritedFromTypeName="IList" csharp="result &lt; this.Count" vb="result &lt; Me.Count">result &lt; this.Count</ensures>
    </member>
    <member name="M:whiteMath.General.DefaultList`1.Insert(System.Int32,`0)">
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &lt;= this.Count" vb="index &lt;= Me.Count">index &lt;= this.Count</requires>
    </member>
    <member name="M:whiteMath.General.DefaultList`1.RemoveAt(System.Int32)">
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList" csharp="index &lt; this.Count" vb="index &lt; Me.Count">index &lt; this.Count</requires>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList" csharp="this.Count == old(this.Count) - 1" vb="Me.Count = old(Me.Count) - 1">this.Count == old(this.Count) - 1</ensures>
    </member>
    <member name="M:whiteMath.General.DefaultList`1.System#Collections#IEnumerable#GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_CurrentIndex == -1" vb="result.get_CurrentIndex = -1">result.get_CurrentIndex == -1</ensures>
    </member>
    <member name="M:whiteMath.General.DefaultList`1.GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
    </member>
    <member name="P:whiteMath.General.DefaultList`1.Item(System.Int32)">
      <getter>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.get_Item(System.Int32)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.get_Item(System.Int32)" inheritedFromTypeName="IList" csharp="index &lt; this.Count" vb="index &lt; Me.Count">index &lt; this.Count</requires>
      </getter>
      <setter>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.set_Item(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.set_Item(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &lt; this.Count" vb="index &lt; Me.Count">index &lt; this.Count</requires>
      </setter>
    </member>
    <member name="P:whiteMath.General.DefaultList`1.Count">
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.get_Count" inheritedFromTypeName="ICollection" csharp="result &gt;= 0" vb="result &gt;= 0">result &gt;= 0</ensures>
      </getter>
    </member>
    <member name="M:whiteMath.General.Point`1.PointComparer.#ctor(System.Collections.Generic.IComparer{`0},System.Boolean)">
      <requires csharp="tComparer != null" vb="tComparer &lt;&gt; Nothing">tComparer != null</requires>
    </member>
    <member name="M:whiteMath.General.OddEvenListWrappers.HalfList`1.System#Collections#IEnumerable#GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_CurrentIndex == -1" vb="result.get_CurrentIndex = -1">result.get_CurrentIndex == -1</ensures>
    </member>
    <member name="M:whiteMath.General.OddEvenListWrappers.HalfList`1.GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
    </member>
    <member name="M:whiteMath.General.OddEvenListWrappers.HalfList`1.CopyTo(`0[],System.Int32)">
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="array != null" vb="array &lt;&gt; Nothing">array != null</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &gt;= 0" vb="arrayIndex &gt;= 0">arrayIndex &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &lt;= array.Length - this.Count" vb="arrayIndex &lt;= array.Length - Me.Count">arrayIndex &lt;= array.Length - this.Count</requires>
    </member>
    <member name="M:whiteMath.General.OddEvenListWrappers.HalfList`1.Contains(`0)">
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Contains(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt; 0" vb="result Implies Me.Count &gt; 0">!result || this.Count &gt; 0</ensures>
    </member>
    <member name="M:whiteMath.General.OddEvenListWrappers.HalfList`1.IndexOf(`0)">
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.IndexOf(`0)" inheritedFromTypeName="IList" csharp="result &gt;= -1" vb="result &gt;= -1">result &gt;= -1</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.IndexOf(`0)" inheritedFromTypeName="IList" csharp="result &lt; this.Count" vb="result &lt; Me.Count">result &lt; this.Count</ensures>
    </member>
    <member name="M:whiteMath.General.OddEvenListWrappers.HalfList`1.Add(`0)">
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Add(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &gt;= old(this.Count)" vb="Me.Count &gt;= old(Me.Count)">this.Count &gt;= old(this.Count)</ensures>
    </member>
    <member name="M:whiteMath.General.OddEvenListWrappers.HalfList`1.Insert(System.Int32,`0)">
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &lt;= this.Count" vb="index &lt;= Me.Count">index &lt;= this.Count</requires>
    </member>
    <member name="M:whiteMath.General.OddEvenListWrappers.HalfList`1.RemoveAt(System.Int32)">
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList" csharp="index &lt; this.Count" vb="index &lt; Me.Count">index &lt; this.Count</requires>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList" csharp="this.Count == old(this.Count) - 1" vb="Me.Count = old(Me.Count) - 1">this.Count == old(this.Count) - 1</ensures>
    </member>
    <member name="M:whiteMath.General.OddEvenListWrappers.HalfList`1.Clear">
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Clear" inheritedFromTypeName="ICollection" csharp="this.Count == 0" vb="Me.Count = 0">this.Count == 0</ensures>
    </member>
    <member name="P:whiteMath.General.OddEvenListWrappers.HalfList`1.Item(System.Int32)">
      <getter>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.get_Item(System.Int32)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.get_Item(System.Int32)" inheritedFromTypeName="IList" csharp="index &lt; this.Count" vb="index &lt; Me.Count">index &lt; this.Count</requires>
      </getter>
      <setter>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.set_Item(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.set_Item(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &lt; this.Count" vb="index &lt; Me.Count">index &lt; this.Count</requires>
      </setter>
    </member>
    <member name="P:whiteMath.General.OddEvenListWrappers.HalfList`1.Count">
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.get_Count" inheritedFromTypeName="ICollection" csharp="result &gt;= 0" vb="result &gt;= 0">result &gt;= 0</ensures>
      </getter>
    </member>
    <member name="M:whiteMath.General.ListFragment`1.System#Collections#IEnumerable#GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_CurrentIndex == -1" vb="result.get_CurrentIndex = -1">result.get_CurrentIndex == -1</ensures>
    </member>
    <member name="M:whiteMath.General.ListFragment`1.GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
    </member>
    <member name="M:whiteMath.General.ListFragment`1.RemoveAt(System.Int32)">
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList" csharp="index &lt; this.Count" vb="index &lt; Me.Count">index &lt; this.Count</requires>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList" csharp="this.Count == old(this.Count) - 1" vb="Me.Count = old(Me.Count) - 1">this.Count == old(this.Count) - 1</ensures>
    </member>
    <member name="M:whiteMath.General.ListFragment`1.Clear">
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Clear" inheritedFromTypeName="ICollection" csharp="this.Count == 0" vb="Me.Count = 0">this.Count == 0</ensures>
    </member>
    <member name="M:whiteMath.General.ListFragment`1.Add(`0)">
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Add(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &gt;= old(this.Count)" vb="Me.Count &gt;= old(Me.Count)">this.Count &gt;= old(this.Count)</ensures>
    </member>
    <member name="M:whiteMath.General.ListFragment`1.Insert(System.Int32,`0)">
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &lt;= this.Count" vb="index &lt;= Me.Count">index &lt;= this.Count</requires>
    </member>
    <member name="M:whiteMath.General.TwoDimensionalArrayRow`1.Add(`0)">
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Add(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &gt;= old(this.Count)" vb="Me.Count &gt;= old(Me.Count)">this.Count &gt;= old(this.Count)</ensures>
    </member>
    <member name="M:whiteMath.General.TwoDimensionalArrayRow`1.RemoveAt(System.Int32)">
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList" csharp="index &lt; this.Count" vb="index &lt; Me.Count">index &lt; this.Count</requires>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList" csharp="this.Count == old(this.Count) - 1" vb="Me.Count = old(Me.Count) - 1">this.Count == old(this.Count) - 1</ensures>
    </member>
    <member name="M:whiteMath.General.TwoDimensionalArrayRow`1.Clear">
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Clear" inheritedFromTypeName="ICollection" csharp="this.Count == 0" vb="Me.Count = 0">this.Count == 0</ensures>
    </member>
    <member name="M:whiteMath.General.TwoDimensionalArrayRow`1.Insert(System.Int32,`0)">
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &lt;= this.Count" vb="index &lt;= Me.Count">index &lt;= this.Count</requires>
    </member>
    <member name="M:whiteMath.General.ListSegment`1.#ctor(System.Collections.Generic.IList{`0},System.Int32,System.Int32)">
      <requires description="list" exception="T:System.ArgumentNullException" csharp="list != null" vb="list &lt;&gt; Nothing">list != null</requires>
      <exception cref="T:System.ArgumentNullException">list == null</exception>
      <requires description="The length must be non-negative" exception="T:System.ArgumentOutOfRangeException" csharp="length &gt;= 0" vb="length &gt;= 0">length &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">length &lt; 0</exception>
      <requires description="The offset index is out of the list bounds." exception="T:System.IndexOutOfRangeException" csharp="offset &gt;= 0 &amp;&amp; offset &lt; list.Count" vb="offset &gt;= 0 AndAlso offset &lt; list.Count">offset &gt;= 0 &amp;&amp; offset &lt; list.Count</requires>
      <exception cref="T:System.IndexOutOfRangeException">offset &lt; 0 || offset &gt;= list.Count</exception>
      <requires description="The length specified runs out of the list bound." exception="T:System.IndexOutOfRangeException" csharp="offset + length &lt;= list.Count" vb="offset + length &lt;= list.Count">offset + length &lt;= list.Count</requires>
      <exception cref="T:System.IndexOutOfRangeException">offset + length &gt; list.Count</exception>
    </member>
    <member name="M:whiteMath.General.ListSegment`1.GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
    </member>
    <member name="M:whiteMath.General.ListSegment`1.System#Collections#IEnumerable#GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_CurrentIndex == -1" vb="result.get_CurrentIndex = -1">result.get_CurrentIndex == -1</ensures>
    </member>
    <member name="M:whiteMath.General.ListSegment`1.Contains(`0)">
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Contains(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt; 0" vb="result Implies Me.Count &gt; 0">!result || this.Count &gt; 0</ensures>
    </member>
    <member name="M:whiteMath.General.ListSegment`1.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:whiteMath.General.ListSegment`1.Item(System.Int32)">
      <getter>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.get_Item(System.Int32)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.get_Item(System.Int32)" inheritedFromTypeName="IList" csharp="index &lt; this.Count" vb="index &lt; Me.Count">index &lt; this.Count</requires>
      </getter>
      <setter>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.set_Item(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.set_Item(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &lt; this.Count" vb="index &lt; Me.Count">index &lt; this.Count</requires>
      </setter>
    </member>
    <member name="M:whiteMath.General.ClassicEnumerator`1.System#Collections#IEnumerator#get_Current">
      <ensures inheritedFrom="M:System.Collections.IEnumerator.get_Current" inheritedFromTypeName="IEnumerator" csharp="result == this.get_Model[this.get_CurrentIndex]" vb="result = Me.get_Model(Me.get_CurrentIndex)">result == this.get_Model[this.get_CurrentIndex]</ensures>
    </member>
    <member name="M:whiteMath.General.ReverseList`1.System#Collections#IEnumerable#GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_CurrentIndex == -1" vb="result.get_CurrentIndex = -1">result.get_CurrentIndex == -1</ensures>
    </member>
    <member name="M:whiteMath.General.ReverseList`1.GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
    </member>
    <member name="M:whiteMath.General.ReverseList`1.Add(`0)">
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Add(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &gt;= old(this.Count)" vb="Me.Count &gt;= old(Me.Count)">this.Count &gt;= old(this.Count)</ensures>
    </member>
    <member name="M:whiteMath.General.ReverseList`1.Contains(`0)">
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Contains(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt; 0" vb="result Implies Me.Count &gt; 0">!result || this.Count &gt; 0</ensures>
    </member>
    <member name="M:whiteMath.General.ReverseList`1.Clear">
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Clear" inheritedFromTypeName="ICollection" csharp="this.Count == 0" vb="Me.Count = 0">this.Count == 0</ensures>
    </member>
    <member name="M:whiteMath.General.ReverseList`1.IndexOf(`0)">
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.IndexOf(`0)" inheritedFromTypeName="IList" csharp="result &gt;= -1" vb="result &gt;= -1">result &gt;= -1</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.IndexOf(`0)" inheritedFromTypeName="IList" csharp="result &lt; this.Count" vb="result &lt; Me.Count">result &lt; this.Count</ensures>
    </member>
    <member name="M:whiteMath.General.ReverseList`1.Insert(System.Int32,`0)">
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &lt;= this.Count" vb="index &lt;= Me.Count">index &lt;= this.Count</requires>
    </member>
    <member name="M:whiteMath.General.ReverseList`1.RemoveAt(System.Int32)">
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList" csharp="index &lt; this.Count" vb="index &lt; Me.Count">index &lt; this.Count</requires>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList" csharp="this.Count == old(this.Count) - 1" vb="Me.Count = old(Me.Count) - 1">this.Count == old(this.Count) - 1</ensures>
    </member>
    <member name="M:whiteMath.General.ReverseList`1.CopyTo(`0[],System.Int32)">
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="array != null" vb="array &lt;&gt; Nothing">array != null</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &gt;= 0" vb="arrayIndex &gt;= 0">arrayIndex &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &lt;= array.Length - this.Count" vb="arrayIndex &lt;= array.Length - Me.Count">arrayIndex &lt;= array.Length - this.Count</requires>
    </member>
    <member name="P:whiteMath.General.ReverseList`1.Count">
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.get_Count" inheritedFromTypeName="ICollection" csharp="result &gt;= 0" vb="result &gt;= 0">result &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:whiteMath.General.ReverseList`1.Item(System.Int32)">
      <getter>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.get_Item(System.Int32)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.get_Item(System.Int32)" inheritedFromTypeName="IList" csharp="index &lt; this.Count" vb="index &lt; Me.Count">index &lt; this.Count</requires>
      </getter>
      <setter>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.set_Item(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.set_Item(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &lt; this.Count" vb="index &lt; Me.Count">index &lt; this.Count</requires>
      </setter>
    </member>
    <member name="M:whiteMath.General.TreeNode`1.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:whiteMath.General.TreeNodeSmart`1.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="T:whiteMath.General.HitTester`2">
      <invariant>this.intervalList != null</invariant>
      <invariant>this.intervalHits != null</invariant>
    </member>
    <member name="M:whiteMath.General.BinaryHeap`1.BinaryHeapNode.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:whiteMath.General.LTDefaultList`1.System#Collections#IEnumerable#GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_CurrentIndex == -1" vb="result.get_CurrentIndex = -1">result.get_CurrentIndex == -1</ensures>
    </member>
    <member name="M:whiteMath.General.LTDefaultList`1.GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
    </member>
    <member name="M:whiteMath.General.LTDefaultList`1.Add(`0)">
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Add(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &gt;= old(this.Count)" vb="Me.Count &gt;= old(Me.Count)">this.Count &gt;= old(this.Count)</ensures>
    </member>
    <member name="M:whiteMath.General.LTDefaultList`1.Insert(System.Int32,`0)">
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &lt;= this.Count" vb="index &lt;= Me.Count">index &lt;= this.Count</requires>
    </member>
    <member name="M:whiteMath.General.LTDefaultList`1.Contains(`0)">
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Contains(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt; 0" vb="result Implies Me.Count &gt; 0">!result || this.Count &gt; 0</ensures>
    </member>
    <member name="M:whiteMath.General.LTDefaultList`1.Clear">
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Clear" inheritedFromTypeName="ICollection" csharp="this.Count == 0" vb="Me.Count = 0">this.Count == 0</ensures>
    </member>
    <member name="M:whiteMath.General.LTDefaultList`1.CopyTo(`0[],System.Int32)">
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="array != null" vb="array &lt;&gt; Nothing">array != null</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &gt;= 0" vb="arrayIndex &gt;= 0">arrayIndex &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &lt;= array.Length - this.Count" vb="arrayIndex &lt;= array.Length - Me.Count">arrayIndex &lt;= array.Length - this.Count</requires>
    </member>
    <member name="M:whiteMath.General.LTDefaultList`1.IndexOf(`0)">
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.IndexOf(`0)" inheritedFromTypeName="IList" csharp="result &gt;= -1" vb="result &gt;= -1">result &gt;= -1</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.IndexOf(`0)" inheritedFromTypeName="IList" csharp="result &lt; this.Count" vb="result &lt; Me.Count">result &lt; this.Count</ensures>
    </member>
    <member name="M:whiteMath.General.LTDefaultList`1.RemoveAt(System.Int32)">
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList" csharp="index &lt; this.Count" vb="index &lt; Me.Count">index &lt; this.Count</requires>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList" csharp="this.Count == old(this.Count) - 1" vb="Me.Count = old(Me.Count) - 1">this.Count == old(this.Count) - 1</ensures>
    </member>
    <member name="P:whiteMath.General.LTDefaultList`1.Count">
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.get_Count" inheritedFromTypeName="ICollection" csharp="result &gt;= 0" vb="result &gt;= 0">result &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:whiteMath.General.LTDefaultList`1.Item(System.Int32)">
      <getter>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.get_Item(System.Int32)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.get_Item(System.Int32)" inheritedFromTypeName="IList" csharp="index &lt; this.Count" vb="index &lt; Me.Count">index &lt; this.Count</requires>
      </getter>
      <setter>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.set_Item(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.set_Item(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &lt; this.Count" vb="index &lt; Me.Count">index &lt; this.Count</requires>
      </setter>
    </member>
    <member name="M:whiteMath.CalcULong.fromInt(System.Int64)">
      <requires description="Cannot convert a negative value to an ulong." exception="T:System.ArgumentOutOfRangeException" csharp="equivalent &gt;= (long)0" vb="equivalent &gt;= ((Long )0)">equivalent &gt;= (long)0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">equivalent &lt; 0</exception>
    </member>
  </members>
</doc>