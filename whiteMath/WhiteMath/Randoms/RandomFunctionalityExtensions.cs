using System;

using WhiteStructs.Conditions;

namespace WhiteMath.Randoms
{
    /// <summary>
    /// Represents a method which is able to generate
    /// random numbers in the whole range of the <typeparamref name="T"/>
    /// type.
    /// </summary>
    /// <typeparam name="T">The type of numbers generated by the method.</typeparam>
    /// <returns>A random value from all of the possible finite values of numeric type <typeparamref name="T"/>.</returns>
    public delegate T GenerateUnbounded<T>();

    /// <summary>
    /// Represents a method which is able to generate
    /// non-negative random numbers smaller than the specified
    /// value.
    /// </summary>
    /// <typeparam name="T">The type of numbers generated by the method.</typeparam>
    /// <param name="maxValue">An exlusive upper boundary for generated numbers.</param>
    /// <returns>A non-negative random value which is smaller than <paramref name="maxValue"/>.</returns>
    public delegate T GenerateUpperBounded<T>(T maxValue);

    /// <summary>
    /// Represents a method which is able to generate
    /// random numbers in the specified range.
    /// </summary>
    /// <typeparam name="T">The type of numbers generated by the method.</typeparam>
    /// <param name="minValue">A lower inclusive boundary for generated numbers.</param>
    /// <param name="maxValue">An upper exclusive boundary for generated numbers.</param>
    /// <returns>A random value in the interval <c>[minValue; maxValue)</c></returns>
    public delegate T GenerateBounded<T>(T minValue, T maxValue);

    /// <summary>
    /// Represents a method which accepts a <c>byte[]</c>
    /// buffer and fills it with random values.
    /// </summary>
    /// <param name="buffer">An array to be filled with random values.</param>
    public delegate void GenerateBytes(byte[] buffer);

    /// <summary>
    /// This class provides methods for extending functionality of
    /// existing random generators by making use of their methods
    /// to create new ones.
    /// </summary>
    /// <see cref="IRandomUnitInterval&lt;T&gt;"/>
    /// <see cref="IRandomBytes"/>
    /// <see cref="IRandomUnbounded&lt;T&gt;"/>
    /// <see cref="IRandomBounded&lt;T&gt;"/>
    public static class RandomFunctionalityExtensions
    {
        /// <summary>
        /// Returns a delegate that is able to generate random byte 
        /// sequences on the basis of random <c>int</c> generator delegate.
        /// </summary>
        /// <param name="intGenerator">A delegate which returns a random integer number, recommended to cover the whole range <c>[int.MinValue; int.MaxValue]</c>.</param>
        /// <returns>A delegate that wraps around the <paramref name="intGenerator"/> to produce random byte sequences.</returns>
        public static GenerateBytes CreateNextBytes(GenerateUnbounded<int> intGenerator)
        {
			return delegate(byte[] buffer)
            {
                for (int i = 0; i < buffer.Length; i += 4)
                {
                    int nextInt = intGenerator();

                    for (int j = i; j < i + 4 && j < buffer.Length; j++)
                    {
                        buffer[j] = (byte)(nextInt & 0xFF);
                        nextInt >>= 8;
                    }
                }
            };
        }

        /// <summary>
        /// Returns a delegate that is able to generate random byte sequences 
        /// on the basis of a random <see cref="long"/> generator.
        /// </summary>
        /// <param name="longGenerator">A delegate which returns a random long number, recommended to cover the whole range <c>[long.MinValue; long.MaxValue]</c>.</param>
        /// <returns>A delegate that wraps around the <paramref name="longGenerator"/> to produce random byte sequences.</returns>
        public static GenerateBytes CreateNextBytes(GenerateUnbounded<long> longGenerator)
        {
			return delegate(byte[] buffer)
            {
                for (int i = 0; i < buffer.Length; i += 8)
                {
                    long nextLong = longGenerator();

                    for (int j = i; j < i + 8 && j < buffer.Length; j++)
                    {
                        buffer[j] = (byte)(nextLong & 0xFF);
                        nextLong >>= 8;
                    }
                }
            };
        }

        /// <summary>
        /// На основе генератора случайных байтов возвращает 
        /// генератор uint, который дает числа не больше заданного значения.
        /// </summary>
		private static Func<uint, uint> CreateNextUIntUpperBoundedInclusive(GenerateBytes byteGenerator)
        {
			return delegate(uint maxInclusiveValue)
            {
				if (maxInclusiveValue == 0)
				{
					return 0;
				}

				int wholeBytes;
				int tailBits;

				wholeBytes = GetWholeSignificantBytesCount(maxInclusiveValue, out tailBits);

				uint sampledValue;

				while (true)
				{
					byte[] buffer = new byte[4];
					byteGenerator(buffer);

					// All elder places after the whole number of bytes 
					// should be zeroed out.
					// -
					for (int byteIndex = wholeBytes + 1; byteIndex < 4; ++byteIndex)
					{
						buffer[byteIndex] = 0;
					}

					if (wholeBytes < 4)
					{
						if (tailBits > 0)
						{
							// tailbits = 1 --> mask = 00000001
							// tailbits = 3 --> mask = 00000111

							byte mask = 1;

							for (int j = 1; j < tailBits; j++)
							{
								mask <<= 1;
								mask += 1;
							}

							buffer[wholeBytes] &= mask;
						}
						else
						{
							buffer[wholeBytes] = 0;
						}
					}

					sampledValue = BitConverter.ToUInt32(buffer, 0);

					if (sampledValue <= maxInclusiveValue)
					{
						break;
					}
				}

                return sampledValue;
            };
        }

		/// <summary>
		/// Based on the random bytes generator function, produces a function
		/// that generates upper-bounded inclusive <see cref="ulong"/> generator 
		/// function.
		/// </summary>
		internal static Func<ulong, ulong> CreateNextULongUpperBoundedInclusive(GenerateBytes byteGenerator)
		{
			return delegate (ulong maxInclusiveValue)
			{
				if (maxInclusiveValue == 0)
				{
					return 0;
				}

				int wholeBytes;
				int tailBits;

				wholeBytes = GetWholeSignificantBytesCount(maxInclusiveValue, out tailBits);

				ulong sampledValue;

				while (true)
				{
					byte[] buffer = new byte[8];
					byteGenerator(buffer);

					// All elder places after the whole
					// number of bytes should be zeroed out.
					// -
					for (int byteIndex = wholeBytes + 1; byteIndex < 8; byteIndex++)
					{
						buffer[byteIndex] = 0;
					}

					if (wholeBytes < 8)
					{
						if (tailBits > 0)
						{
							// tailbits = 1 --> mask = 00000001
							// tailbits = 3 --> mask = 00000111

							byte mask = 1;

							for (int j = 1; j < tailBits; j++)
							{
								mask <<= 1;
								mask += 1;
							}

							buffer[wholeBytes] &= mask;
						}
						else
						{
							buffer[wholeBytes] = 0;
						}
					}

					sampledValue = BitConverter.ToUInt64(buffer, 0);

					if (sampledValue <= maxInclusiveValue)
					{
						break;
					}
				}

				return sampledValue;
			};
		}

        /// <summary>
        /// Returns a delegate that is able to generate random
        /// <c>uint</c> numbers in the whole range of <c>uint</c> numeric type.
        /// </summary>
        /// <param name="byteGenerator">A delegate that fills the passed byte array with random values.</param>
        /// <returns>
        /// A delegate that wraps around the <paramref name="byteGenerator"/> to produce random 
        /// <c>uint</c> values in the whole range of <c>uint</c> numeric type.
        /// </returns>
        public static GenerateUnbounded<uint> CreateNextUIntUnbounded(GenerateBytes byteGenerator)
        {
            return delegate
            {
                byte[] buffer = new byte[4];
                byteGenerator(buffer);

                return BitConverter.ToUInt32(buffer, 0);
            };
        }

        /// <summary>
        /// Returns a delegate that is able to generate random
        /// <c>uint</c> numbers which are strictly smaller than the specified value.
        /// </summary>
        /// <param name="byteGenerator">A delegate that fills the passed byte array with random values.</param>
        /// <returns>
        /// A delegate that wraps around the <paramref name="byteGenerator"/> to produce random <c>uint</c> values 
        /// which are strictly smaller than the argument passed to the delegate.
        /// </returns>
        public static GenerateUpperBounded<uint> CreateNextUIntUpperBounded(GenerateBytes byteGenerator)
        {
			Func<uint, uint> nextUIntInclusive = CreateNextUIntUpperBoundedInclusive(byteGenerator);

            return
                maxValue => nextUIntInclusive(maxValue - 1);
        }

        /// <summary>
        /// Returns a delegate that is able to generate random
        /// <c>uint</c> numbers in an arbitrary range.
        /// </summary>
        /// <param name="byteGenerator">A delegate that fills the passed byte array with random values.</param>
        /// <returns>A delegate that wraps around the <paramref name="byteGenerator"/> to produce random <c>uint</c> values 
        /// in the specified range.</returns>
        public static GenerateBounded<uint> CreateNextUIntBounded(GenerateBytes byteGenerator)
        {
            Func<uint, uint> nextUIntInclusive = CreateNextUIntUpperBoundedInclusive(byteGenerator);

            return
                (minValue, maxValue) => minValue + nextUIntInclusive(maxValue - minValue - 1);
        }

        /// <summary>
        /// Returns a delegate that is able to generate random
        /// <c>int</c> numbers in an the whole range of <c>int</c> numeric type.
        /// </summary>
        /// <param name="byteGenerator">A delegate that fills the passed byte array with random values.</param>
        /// <returns>
        /// A delegate that wraps around the <paramref name="byteGenerator"/> to 
        /// produce random <c>int</c> values in the whole range of <c>int</c> numeric type.
        /// </returns>
        public static GenerateUnbounded<int> CreateNextIntUnbounded(GenerateBytes byteGenerator)
        {
            GenerateUnbounded<uint> nextUIntUnbounded = CreateNextUIntUnbounded(byteGenerator);

            return
                () => (int)nextUIntUnbounded();
        }

        /// <summary>
        /// Returns a delegate that is able to generate random
        /// <c>int</c> numbers which are strictly smaller than the specified value.
        /// </summary>
        /// <param name="byteGenerator">
        /// A delegate that fills the passed byte array with random values.
        /// </param>
        /// <returns>
        /// A delegate that wraps around the <paramref name="byteGenerator"/> to produce random <c>int</c> values 
        /// which are strictly smaller than the argument passed to the delegate.
        /// </returns>
        public static GenerateUpperBounded<int> CreateNextIntUpperBounded(GenerateBytes byteGenerator)
        {
            Func<uint, uint> nextUIntInclusive = CreateNextUIntUpperBoundedInclusive(byteGenerator);

            return
                ((int maxValue) => (int)nextUIntInclusive((uint)(maxValue - 1)));
        }

        /// <summary>
        /// Returns a delegate that is able to generate random
        /// <c>int</c> numbers in an arbitrary range.
        /// </summary>
        /// <param name="byteGenerator">A delegate that fills the passed byte array with random values.</param>
        /// <returns>
        /// A delegate that wraps around the <paramref name="byteGenerator"/> 
        /// to produce random <c>int</c> values in the range supplied as its argument.
        /// </returns>
        public static GenerateBounded<int> CreateNextIntBounded(GenerateBytes byteGenerator)
        {
            GenerateUpperBounded<long> nextLongUpperBounded = CreateNextLongUpperBounded(byteGenerator);

            return ((int minValue, int maxValue) => 
                minValue + (int)nextLongUpperBounded((long)maxValue - minValue));
        }

		/// <summary>
		/// For the specified value, gets the number of significant 
		/// bytes, and the number of remaining significant bits.
		/// </summary>
		/// <remarks>
		/// To get the total number of significant bits, multiply the 
		/// resulting value by 8 and add the value of 
		/// <paramref name="tailBits"/>.
		/// </remarks>
		internal static int GetWholeSignificantBytesCount(ulong value, out int tailBits)
		{
			int significantBytes = 0;

			tailBits = 0;

			while (value > 0)
			{
				++tailBits;

				if (tailBits == 8)
				{
					++significantBytes;
					tailBits = 0;
				}

				value >>= 1;
			}

			return significantBytes;
		}

        /// <summary>
        /// Returns a delegate that is able to generate random
        /// <c>ulong</c> numbers in the whole range of <c>ulong</c> numeric type.
        /// </summary>
        /// <param name="byteGenerator">A delegate that fills the passed byte array with random values.</param>
        /// <returns>A delegate that wraps around the <paramref name="byteGenerator"/> to produce random <c>ulong</c> values in the whole range of <c>ulong</c> numeric type.</returns>
        public static GenerateUnbounded<ulong> CreateNextULongUnbounded(GenerateBytes byteGenerator)
        {
            return delegate
            {
                byte[] buffer = new byte[8];
                byteGenerator(buffer);

                return BitConverter.ToUInt64(buffer, 0);
            };
        }

        /// <summary>
        /// Returns a delegate that is able to generate random
        /// <c>ulong</c> numbers which are strictly smaller than the specified value.
        /// </summary>
        /// <param name="byteGenerator">A delegate that fills the passed byte array with random values.</param>
        /// <returns>
        /// A delegate that wraps around the <paramref name="byteGenerator"/> to produce random <c>ulong</c> values 
        /// which are strictly smaller than the argument passed to the delegate.
        /// </returns>
        public static GenerateUpperBounded<ulong> CreateNextULongUpperBounded(GenerateBytes byteGenerator)
        {
            Func<ulong, ulong> nextULongInclusive = CreateNextULongUpperBoundedInclusive(byteGenerator);

            return
                maxValue => nextULongInclusive(maxValue - 1);
        }

        /// <summary>
        /// Returns a delegate that is able to generate random
        /// <c>ulong</c> numbers in an arbitrary range.
        /// </summary>
        /// <param name="byteGenerator">A delegate that fills the passed byte array with random values.</param>
        /// <returns>A delegate that wraps around the <paramref name="byteGenerator"/> to produce random <c>ulong</c> values 
        /// in the specified range.</returns>
        public static GenerateBounded<ulong> CreateNextULongBounded(GenerateBytes byteGenerator)
        {
            Func<ulong, ulong> nextULongInclusive = CreateNextULongUpperBoundedInclusive(byteGenerator);

            return
                (minValue, maxValue) => minValue + nextULongInclusive(maxValue - minValue - 1);
        }

        /// <summary>
        /// Returns a delegate that is able to generate random
        /// <c>long</c> numbers in an arbitrary range.
        /// </summary>
        /// <param name="byteGenerator">A delegate that fills the passed byte array with random values.</param>
        /// <returns>A delegate that wraps around the <paramref name="byteGenerator"/> to produce random <c>ulong</c> values in the whole range of <c>long</c> numeric type.</returns>
        public static GenerateUnbounded<long> CreateNextLongUnbounded(GenerateBytes byteGenerator)
        {
            GenerateUnbounded<ulong> nextULongUnbounded = CreateNextULongUnbounded(byteGenerator);

            return
                () => (long)nextULongUnbounded();
        }

        /// <summary>
        /// Returns a delegate that is able to generate random
        /// <c>long</c> numbers which are strictly smaller than the specified value.
        /// </summary>
        /// <param name="byteGenerator">A delegate that fills the passed byte array with random values.</param>
        /// <returns>
        /// A delegate that wraps around the <paramref name="byteGenerator"/> to produce random <c>long</c> values 
        /// which are strictly smaller than the argument passed to the delegate.
        /// </returns>
        public static GenerateUpperBounded<long> CreateNextLongUpperBounded(GenerateBytes byteGenerator)
        {
            Func<ulong, ulong> nextULongInclusive = CreateNextULongUpperBoundedInclusive(byteGenerator);

            return
                (long maxValue) => (long)nextULongInclusive((ulong)(maxValue - 1));
        }

        /// <summary>
        /// Returns a delegate that is able to generate random
        /// <c>long</c> numbers in an arbitrary range.
        /// </summary>
        /// <param name="byteGenerator">A delegate that fills the passed byte array with random values.</param>
        /// <returns>
        /// A delegate that wraps around the <paramref name="byteGenerator"/> 
        /// to produce random <c>long</c> values in the range supplied as its argument.
        /// </returns>
        public static GenerateBounded<long> CreateNextLongBounded(GenerateBytes byteGenerator)
        {
            Func<ulong, ulong> nextULongInclusive = CreateNextULongUpperBoundedInclusive(byteGenerator);

			return delegate(long minInclusiveValue, long maxExclusiveValue)
            {
				Condition
					.Validate(minInclusiveValue < maxExclusiveValue)
					.OrArgumentOutOfRangeException("The minimum inclusive boundary should be smaller than the maximum exclusive boundary.");

				// If both numbers lie on the same side from zero,
				// it is safe to subtract because there will be no
				// overflow during subtraction.
				// -
				if (minInclusiveValue >= 0 || maxExclusiveValue < 0)
				{
					return minInclusiveValue + (long)nextULongInclusive((ulong)(maxExclusiveValue - minInclusiveValue - 1));
				}
				else
				{
					// maxExclusiveValue is definitely larger than zero, and
					// minInclusiveValue is definitely smaller than zero.
					// -
					// We will separately handle the case, when negating the
					// minInclusiveValue will overflow the long type.
					// -
					if (minInclusiveValue == long.MinValue)
                    {
						ulong temp = nextULongInclusive((ulong)maxExclusiveValue + 9223372036854775808 - 1);

						if (temp > 9223372036854775808)
						{
							// If this is bigger than minInclusiveValue, we can safely
							// subtract, the result will be positive.
							// -
							return (long)(temp - 9223372036854775808);
						}
						else
						{
							return -(long)(9223372036854775808 - temp);
						}
                    }
                    else
                    {
                        // As long as minInclusiveValue is not long.Minvalue, the
						// expression -minInclusiveValue will not overflow.
						// .
                        ulong minusMinimum = (ulong)(-minInclusiveValue);

						ulong temp = nextULongInclusive((ulong)maxExclusiveValue + minusMinimum - 1);

						if (temp > minusMinimum)
						{
							return (long)(temp - minusMinimum);
						}
						else
						{
							return -(long)(minusMinimum - temp);
						}
                    }
                }
            };
        }
    }
}
